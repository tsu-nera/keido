[{"id":0,"href":"/notes/20220302144013/","title":"20220302144013th","parent":"🎓Keido HOME","content":"Clojureのファイル操作他.\nup: 📂Clojure Core Languages\nclojure.core    slurp    引数で与えられたファイルを読み込んで文字列を返す.\nwith-open    clojure.java.io    clojure.java.io/file    java.io.Fileオブジェクトを作成する.\n(require \u0026#39;[clojure.java.io :as io]) (io/file \u0026#34;config.edn\u0026#34;) ;; =\u0026gt; #object[java.io.File 0x71fda6e1 \u0026#34;config.edn\u0026#34;] (io/resource \u0026#34;config.edn\u0026#34;) ;; =\u0026gt; #object[java.net.URL 0x7f3b3463 \u0026#34;file:/home/tsu-nera/hogehoge/resources/config.edn\u0026#34;]  io/fileでJavaのFileオブジェクトを扱う. io/resourceで resource-pathにあるFileオブジェクトを扱う.   メモ, これはJava7で導入された java.nio.fileとは違うことに注意. 昔Javaのファイル周りはけっこう調べて業務的に詳しかったことを思い出した.\n 🖊Java7 の Java.nio.file.Files で ファイルのコピーをしてみる | Futurismo  clojure.java.io/resource    https://clojuredocs.org/clojure.java.io/resource\nここでいうresourceとは, Javaの仕組みの１つ. Javaリソースとはクラスパスにある.classファイル以外の実行時に使うデータ.\n https://docs.oracle.com/javase/jp/1.5.0/guide/lang/resources.html https://www.ne.jp/asahi/hishidama/home/tech/java/resource.html   clojureのresourceに関する情報は漁ってもみつからないのだが, deps.ednだと :pathsに含まれる.classファイル以外ならいいのか？\nclojure.java.io/reader, clojure.java.io/writer    java.io.BufferedReader/BufferedWriterを扱う.\nclojure.java.io/input-stream, clojure.java.io/output-stream    java.io.BufferedInputStream/BufferedOutputStreamを扱う.\nReferences     https://clojuredocs.org/clojure.java.io Clojureの入出力の関数とIOFactoryプロトコル - Qiita  "},{"id":1,"href":"/notes/20220405210206/","title":"20220405210206th","parent":"🎓Keido HOME","content":"Common Lispのマクロについての本.\n url: オンラインで読める.  (en) On Lisp (ja) On Lisp   tags  🏷Common Lisp 🏷Paul Graham    "},{"id":2,"href":"/notes/nothung/","title":"⚡My Emacs Config - Nothung","parent":"🎓Keido HOME","content":"Emacsを極限まで叩き上げ, なによりも強靭な刃にする. 一つのことを極める.\n副題のノートォング(Nothung)とは勇者ジークフリートの持つ伝説の剣である.\n https://www.youtube.com/watch?v=B6wChr_geAg https://www.youtube.com/watch?v=v31N8zxGhQY   packageの並び順は Doom Emacs の Molule Index (アルファベット順)に従う.\nref: https://github.com/tsu-nera/nothung\nいつも忘れるDoom Emacs Configuration記法は ここ.\n use-package! は:defer, :hook, :commands, or :after が省略されると起動時に loadされる. after! は package が load されたときに評価される. add-hook! は mode 有効化のとき. setq-hook!は equivalent.  どれを使うかの正解はないがすべて use-package!だと起動が遅くなるので場合によってカスタマイズせよ，とのこと.\nref. 過去の設定はこちら.\n;;; $DOOMDIR/config.el -*- lexical-binding: t; -*- (load-file \u0026#34;~/.doom.d/private/config.el\u0026#34;) App    Twitter    ;; App ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;; twittering-mode ;; この設定がないと認証が失敗した. ;; twittering-oauth-get-access-token: Failed to retrieve a request token (use-package! twittering-mode :init (setq twittering-allow-insecure-server-cert t)) eww    Emacsのテキストブラウザ(Manual)\nnotes:\n ewwを起動しただけだとminibufferなのでC-gで消えてしまうので大きくC-x 1とかで大きくする. C-u M-x ewwでひとつのbufferを使いまわすのではなく別のBufferでewwを開く. M-RETでURLを新しいBufferで開く. Doom EmacsだとC-c s o(online)でいろいろと検索できる(w/Chrome). helm-google-suggest的な.   (use-package! eww :bind (\u0026#34;C-c s w\u0026#34; . eww-search-words) (\u0026#34;C-c o w\u0026#34; . eww-open-in-new-buffer))  ace-linkをつかうとewwのlinkをインタラクティブに選択できて便利.   (use-package! ace-link :config (eval-after-load \u0026#39;eww \u0026#39;(define-key eww-mode-map \u0026#34;f\u0026#34; \u0026#39;ace-link-eww)) (ace-link-setup-default)) org-web-tools    ewwとorgを便利にするツール群(https://github.com/alphapapa/org-web-tools).\n(use-package! org-web-tools :bind (\u0026#34;C-c i l\u0026#34; . org-web-tools-insert-link-for-url)) Pocket    あとで読むサービス.\n(global-set-key (kbd \u0026#34;C-x w p\u0026#34;) \u0026#39;pocket-reader) (use-package! pocket-reader :bind (\u0026#34;C-x w l\u0026#34; . pocker-reader-add-link) :config (setq pocket-reader-open-url-default-function #\u0026#39;eww) (setq pocket-reader-pop-to-url-default-function #\u0026#39;eww)) RSS(Elfeed)    ;; elfeed (global-set-key (kbd \u0026#34;C-x w w\u0026#34;) \u0026#39;elfeed) (use-package! elfeed :config (setq elfeed-feeds \u0026#39;( (\u0026#34;https://yuchrszk.blogspot.com/feeds/posts/default\u0026#34; blog) ; パレオな男 (\u0026#34;https://www.youtube.com/feeds/videos.xml?channel_id=UCFo4kqllbcQ4nV83WCyraiw\u0026#34; youtube) ; 中田敦彦 (\u0026#34;https://www.youtube.com/feeds/videos.xml?channel_id=UCFdBehO71GQaIom4WfVeGSw\u0026#34; youtube) ;メンタリストDaiGo (\u0026#34;https://www.youtube.com/feeds/videos.xml?playlist_id=PL3N_SB4Wr_S2cGYuI02bdb4UN9XTZRNDu\u0026#34; youtube) ; 与沢の流儀 (\u0026#34;http://www.aaronsw.com/2002/feeds/pgessays.rss\u0026#34; blog) ; Paul Graham )) (setq-default elfeed-search-filter \u0026#34;@1-week-ago +unread \u0026#34;) (defun elfeed-search-format-date (date) (format-time-string \u0026#34;%Y-%m-%d %H:%M\u0026#34; (seconds-to-time date))) ) Habitica    (use-package! habitica :commands habitica-tasks :init (bind-key \u0026#34;C-x t g\u0026#34; \u0026#39;habitica-tasks) :config (setq habitica-show-streak t) (setq habitica-turn-on-highlighting nil)) Checkers    ;; Checkers ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Completion    ;; Completion ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; (use-package! avy :bind (\u0026#34;M-g c\u0026#34; . avy-goto-char) ;; doom の keybind 上書き. (\u0026#34;M-g l\u0026#34; . avy-goto-line) ;; doom の keybind 上書き. (\u0026#34;M-g g\u0026#34;. avy-goto-word-1)) ;; うまく動かないので封印 doom との相性が悪いのかも. ;; ひとまず migemo したいときは isearch で対応. ;; (use-package! avy-migemo ;; :after migemo ;; :bind ;; (\u0026#34;M-g m m\u0026#34; . avy-migemo-mode) ;; (\u0026#34;M-g c\u0026#34; . avy-migemo-goto-char-timer) ;; doom の keybind 上書き. ;; :config ;; (avy-migemo-mode 1) ;; (setq avy-timeout-seconds nil)) (use-package! swiper :bind ; (\u0026#34;C-s\u0026#34; . swiper) ;; migemo とうまく連携しないので isearch 置き換えを保留. C-c s s で swiper 起動. :config (ivy-mode 1)) ;; avy-migemo-e.g.swiper だけバクる ;; https://github.com/abo-abo/swiper/issues/2249 ;;(after! avy-migemo ;; (require \u0026#39;avy-migemo-e.g.swiper)) ;; org-roam の completion-at-point が動作しないのはこいつかな... ;; (add-hook! \u0026#39;org-mode-hook (company-mode -1)) ;; company はなにげに使いそうだからな，TAB でのみ補完発動させるか. (setq company-idle-delay nil) (global-set-key (kbd \u0026#34;TAB\u0026#34;) #\u0026#39;company-indent-or-complete-common) affe    fuzzy find. あいまい検索 for consult.\nhttps://github.com/minad/affe\n(use-package! affe :after consult :config (defun affe-orderless-regexp-compiler (input _type) (setq input (orderless-pattern-compiler input)) (cons input (lambda (str) (orderless--highlight input str)))) (setq affe-regexp-compiler #\u0026#39;affe-orderless-regexp-compiler)) all-the-icons-completion    https://github.com/iyefrat/all-the-icons-completion\n(use-package! all-the-icons-completion :init (all-the-icons-completion-mode)) (add-hook! marginalia-mode-hook #\u0026#39;all-the-icons-completion-marginalia-setup) Config    ;; Config ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;; ;; doom specific config ;; (setq user-full-name \u0026#34;John Doe\u0026#34; ;; user-mail-address \u0026#34;john@doe.com\u0026#34;) (setq confirm-kill-emacs nil) ; 終了時の確認はしない. ;; フルスクリーンで Emacs 起動 ;; ブラウザと並べて表示することが多くなったのでいったんマスク ;; (add-to-list \u0026#39;initial-frame-alist \u0026#39;(fullscreen . maximized)) ;; This is to use pdf-tools instead of doc-viewer (use-package! pdf-tools :config (pdf-tools-install) ;; This means that pdfs are fitted to width by default when you open them (setq-default pdf-view-display-size \u0026#39;fit-width) :custom (pdf-annot-activate-created-annotations t \u0026#34;automatically annotate highlights\u0026#34;)) Editor    ;; Editor ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;; 英数字と日本語の間にスペースをいれる. (use-package! pangu-spacing :config (global-pangu-spacing-mode 1) ;; 保存時に自動的にスペースを入れるのを抑止.あくまで入力時にしておく. (setq pangu-spacing-real-insert-separtor nil)) ;; 記号の前後にスペースを入れる. (use-package! electric-operator) (add-hook! \u0026#39;org-mode-hook #\u0026#39;electric-operator-mode) 改行(newline)と折り返し(wrap)    まず改行(newline)と折り返し(wrap)の２つの概念があることに注意.\n方針として自動改行は無効, 自動折り返しは許す.\nauto-fill-modeで自動改行される. これは無効にする.\n追記: 方針変更. コードではauto-fillを許す. そして単に(auto-fill-mode -1)をところでmodeのhookによって再度有効になる気がする.\n;; (auto-fill-mode -1) 問題はMarkdownやOrg-modeでautl-fillが発動して改行されるところ. org-modeで再度hookが走り有効になる気がするのでコレで息を止める.\n-\u0026gt;息が止まらないので諦めた. いくら無効にしてもorg-mode-hookの延長でauto-fill-modeをonにしてしまう人がいる. そしてその犯人が誰か２時間追求しても結局わからない. Doom Emacsの設定の仕業はある.\n(auto-fill-mode -1) (remove-hook \u0026#39;org-mode-hook #\u0026#39;auto-fill-mode) ;; (remove-hook \u0026#39;org-mode-hook #\u0026#39;turn-on-auto-fill) ;; (remove-hook \u0026#39;text-mode-hook #\u0026#39;auto-fill-mode) ;; (remove-hook \u0026#39;text-mode-hook #\u0026#39;turn-on-auto-fill) ;; (add-hook \u0026#39;org-mode-hook #\u0026#39;turn-off-auto-fill) ;; (add-hook \u0026#39;text-mode-hook #\u0026#39;turn-off-auto-fill) ;; (add-hook \u0026#39;org-roam-mode-hook #\u0026#39;turn-off-auto-fill) これによって折り返しの限界を80から99999にすることにして回避する.\n(setq-default fill-column 99999) (setq fill-column 99999) これにより折り返しで / や $ 記号が表示される. 以下の設定で消す.\n;; / を削除 (set-display-table-slot standard-display-table \u0026#39;wrap ?\\ ) ;; $ を削除 (set-display-table-slot standard-display-table 0 ?\\ ) さらに折り返しの次のラインにインデントが挿入される. これはelectric-indent-modeの仕業. 現在org-modeのみで無効中.\n折り返しoff/onは, M-x toggle-truncate-linesで切り替えることができる.\nvisual-line-mode    単語単位での折り返しをするEmacs標準実装のモード.\nEmacsはウィンドウの右端の近くの単語の境界で折り返すよう試みる. これは単語の途中で折り返さないことにより可読性を高めるため.\nhttps://ayatakesi.github.io/emacs/25.1/Visual-Line-Mode.html\nこの設定はスクリーンの幅によって判定されるためたとえば文字列80で折り返すとかではない.\n日本語と英語が入り交じるときの解釈が変なので以下を設定した.\n(setq word-wrap-by-category t) ref: Word-wrap problem with Chinese or Japanese characters : emacs\nvisual-fill-column    Doomだといらないかもだけど.\n;; (add-hook! visual-line-mode \u0026#39;visual-fill-column-mode) -\u0026gt; perfect-marginとの相性が悪い気がするのでいったん無効.\n ref.  memo: Emacs の visual-fill-column.el が便利だった    perfect-margin    いい感じにmarginをとってくれる (https://github.com/mpwang/perfect-margin)\n(use-package! perfect-margin :config (perfect-margin-mode 1)) ターミナルの縦分割線をUTF-8できれいに描く    ref: How do I make the vertical window divider more pretty? : emacs\n(unless (display-graphic-p) ;; ターミナルの縦分割線をUTF-8できれいに描く (defun my-change-window-divider () (interactive) (let ((display-table (or buffer-display-table standard-display-table (make-display-table)))) (set-display-table-slot display-table 5 ?│) (set-window-display-table (selected-window) display-table))) (add-hook \u0026#39;window-configuration-change-hook \u0026#39;my-change-window-divider)) whitespace    余分な空白/タブに色づけ.\n(use-package! whitespace :config ;; limit lie length -\u0026gt; display-fill-column-indicator-modeを使うためマスク. ;; (setq whitespace-line-column 80) (setq whitespace-style \u0026#39;(face ;;lines-tail )) ;; 全角スペースを可視化 (setq whitespace-space-regexp \u0026#34;\\\\(\\u3000+\\\\)\u0026#34;) (global-whitespace-mode 1)) display-fill-column-indicator-mode    Emacsの画面に1行80文字のところに線を薄く引く.\nプログラミングの世界では昔から80 columns ruleがあり, Emacsで80文字目を表示する機能もいろいろあったものの, Emacs 27.0.90からdefault機能として提供されるようになった.\n(最も80charは昔の話で, 最近のディスプレイの大きさだと100charがいいという議論もある).\n今つかっているモニタで縦に３分割すると74がちょうどいいことがわかった. (先頭に行番号表示4char+1charのmarginあり).\n(setq-default display-fill-column-indicator-column 74) (global-display-fill-column-indicator-mode) Emacs    ;; Emacs ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; (pixel-scroll-precision-mode) ;; doomだとhelpが割り当てられていたがdoomのhelpはF1をつかう. (global-set-key (kbd \u0026#34;C-h\u0026#34;) \u0026#39;backward-delete-char) (global-set-key (kbd \u0026#34;C-c h r\u0026#34;) \u0026#39;doom/reload) ;; Emacs起動時にいちいち質問されるのはうざい. ;; default tではなぜか無視できないので:allを設定しておく. (setq enable-local-variables :all) ace-window     3つ以上のwindowの選択が番号でできる. defaultでC-x oを上書きしてる? C-u C-x o だとwindowをswapできる(ace-swap-window).  Email    ;; Email ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Input    ;; Input ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; (set-language-environment \u0026#34;Japanese\u0026#34;) (prefer-coding-system \u0026#39;utf-8) (set-default \u0026#39;buffer-filecoding-system \u0026#39;utf-8) ;; migemo (use-package! migemo :config (setq migemo-command \u0026#34;cmigemo\u0026#34;) (setq migemo-options \u0026#39;(\u0026#34;-q\u0026#34; \u0026#34;--emacs\u0026#34; \u0026#34;-i\u0026#34; \u0026#34;\\a\u0026#34;)) (setq migemo-dictionary \u0026#34;/usr/share/migemo/utf-8/migemo-dict\u0026#34;) (setq migemo-user-dictionary nil) (setq migemo-regex-dictionary nil) (setq migemo-coding-system \u0026#39;utf-8-unix) (migemo-init)) fcitx    (use-package! fcitx :config (setq fcitx-remote-command \u0026#34;fcitx5-remote\u0026#34;) (fcitx-aggressive-setup) ;; Linux なら t が推奨されるものの、fcitx5 には未対応なためここは nil (setq fcitx-use-dbus nil)) artist mode    EmacsWiki: Artist Mode\nEmacs上でカーソルやマウスを使って線が書ける.\n M-x artist-modeで起動. C-c C-c で終了. defaultでは . を描写, Shiftで - になる.  昔なんちゃってelispを書いたけど, なんだdefaultであったのか.\nref: 秀丸のような罫線マクロないかなと思ってelisp作成した | Futurismo\nLang    編集補助の中でも特にコーディング支援をまとめる.\nGenerals    言語に依存しないコーディング支援ツール.\nsmartparens    https://github.com/Fuco1/smartparens\nEmacsでカッコの対応を取りつつ編集をするminor-mode. pareditを新しくrewriteした.\nrefs:\n https://ebzzry.com/en/emacs-pairs/ http://kimi.im/2021-11-27-sexp-operations-in-emacs  doom emacsのsmartparens定義. +bindings +smartparensで有効.\n;;; smartparens (:after smartparens :map smartparens-mode-map \u0026#34;C-M-a\u0026#34; #\u0026#39;sp-beginning-of-sexp \u0026#34;C-M-e\u0026#34; #\u0026#39;sp-end-of-sexp \u0026#34;C-M-f\u0026#34; #\u0026#39;sp-forward-sexp \u0026#34;C-M-b\u0026#34; #\u0026#39;sp-backward-sexp \u0026#34;C-M-n\u0026#34; #\u0026#39;sp-next-sexp \u0026#34;C-M-p\u0026#34; #\u0026#39;sp-previous-sexp \u0026#34;C-M-u\u0026#34; #\u0026#39;sp-up-sexp \u0026#34;C-M-d\u0026#34; #\u0026#39;sp-down-sexp \u0026#34;C-M-k\u0026#34; #\u0026#39;sp-kill-sexp \u0026#34;C-M-t\u0026#34; #\u0026#39;sp-transpose-sexp \u0026#34;C-M-\u0026lt;backspace\u0026gt;\u0026#34; #\u0026#39;sp-splice-sexp) 足りないのは自分で定義する必要あり. というかいろいろ再定義するか\u0026hellip;\n(use-package! smartparens-config :bind (\u0026#34;C-\u0026lt;right\u0026gt;\u0026#34; . sp-forward-slurp-sexp) (\u0026#34;M-\u0026lt;right\u0026gt;\u0026#34; . sp-forward-barf-sexp) (\u0026#34;C-\u0026lt;left\u0026gt;\u0026#34; . sp-backward-slurp-sexp) (\u0026#34;M-\u0026lt;left\u0026gt;\u0026#34; . sp-backward-barf-sexp) (\u0026#34;C-M-w\u0026#34; . sp-copy-sexp) (\u0026#34;M-[\u0026#34; . sp-backward-unwrap-sexp) (\u0026#34;M-]\u0026#34; . sp-unwrap-sexp) :config (add-hook! \u0026#39;clojure-mode-hook \u0026#39;smartparens-strict-mode)) symbol-overlay    シンボルのハイライトをキー入力で制御できる.\nhttps://github.com/wolray/symbol-overlay/\n使ってないし companyとkeybindがかぶったのでいったん封印.\n(use-package! symbol-overlay :config (global-set-key (kbd \u0026#34;M-i\u0026#34;) \u0026#39;symbol-overlay-put) (global-set-key (kbd \u0026#34;M-n\u0026#34;) \u0026#39;symbol-overlay-switch-forward) (global-set-key (kbd \u0026#34;M-p\u0026#34;) \u0026#39;symbol-overlay-switch-backward) (global-set-key (kbd \u0026#34;\u0026lt;f7\u0026gt;\u0026#34;) \u0026#39;symbol-overlay-mode) (global-set-key (kbd \u0026#34;\u0026lt;f8\u0026gt;\u0026#34;) \u0026#39;symbol-overlay-remove-all)) codic    よい変数名を教えてくれるwebサービスcodicクライアント.\ncodic - プログラマーのためのネーミング辞書\n M-x codic: 英語 =\u0026gt; 日本語 M-x codic-translate =\u0026gt; 日本語 =\u0026gt; 英語(要token)  codic-translateを使うにはtokenを codic-api-tokenに設定する必要がある. 現状は\u0026quot;private/config.el\u0026quot;に書いて読み込んでいる.\n(use-package! codic)  codic - GitHub 英語力を向上させたいのでまずは Emacs からはじめた | Futurismo  Clojure    ref: doom-emacs/README.org - GitHub\nとりあえず，doomのclojureモジュール有効.\n cider clj-refactor flycheck-clj-kondo  その他，\n rainbow-delimiters, smartparensはdoomのcoreパッケージとしてすでにはいっている. pereditはciderの中に入っている.   ;; やりすぎindent mode (add-hook! \u0026#39;clojure-mode-hook \u0026#39;aggressive-indent-mode) ;; 自動でalign整形. (setq clojure-align-forms-automatically t) (use-package! cider :bind ;; desing journal用にbinding追加 (\u0026#34;C-c C-v C-p\u0026#34; . cider-pprint-eval-defun-to-comment) (\u0026#34;C-c C-v M-p\u0026#34; . cider-pprint-eval-last-sexp-to-comment) :config ;; connectとともにREPL bufferを表示. (setq cider-repl-pop-to-buffer-on-connect t) ;; replに 出力しすぎてEmacsがハングするのを防ぐ. (setq cider-repl-buffer-size-limit 100) ;; companyでのあいまい補完. (add-hook \u0026#39;cider-repl-mode-hook #\u0026#39;cider-company-enable-fuzzy-completion) (add-hook \u0026#39;cider-mode-hook #\u0026#39;cider-company-enable-fuzzy-completion) ;; stack-frame表示をプロジェクトに限定 (setq cider-stacktrace-default-filters \u0026#39;(project)) ;; cider-connectで固定portを選択候補に表示. ;; 固定port自体は tools.depsからのnrepl起動時optionで指定. (setq cider-known-endpoints \u0026#39;((\u0026#34;kotori\u0026#34; \u0026#34;0.0.0.0\u0026#34; \u0026#34;34331\u0026#34;))) ) clj-refactor    Emacs CIDERでClojureを書くための便利なファクタツール提供.\nhttps://github.com/clojure-emacs/clj-refactor.el\n(add-hook! clojure-mode (clj-refactor-mode 1) (yas-minor-mode 1) ; for adding require/use/import statements ;; This choice of keybinding leaves cider-macroexpand-1 unbound (cljr-add-keybindings-with-prefix \u0026#34;C-c C-m\u0026#34;))  cljr-clean-nsでnamespaceを整理, cljr-project-cleanでプロジェクト全体に適用.  cljstyle: formatter for Clojure    ref: GitHub\nDoom Emascの editor/format moduleと連携可能. Clojureだとdefaultが node-cljfmtなのでcljstyleを使うには設定が必要.\n(add-hook! clojure-mode (set-formatter! \u0026#39;cljstyle \u0026#34;cljstyle pipe\u0026#34; :modes \u0026#39;(clojure-mode)) (add-hook \u0026#39;before-save-hook \u0026#39;format-all-buffer t t)) clj-kondo: linter for Clojure    ref: GitHub\nportal    Data Visualization for Clojure.\nref. https://github.com/djblue/portal\n(defun portal.api/open () (interactive) (cider-nrepl-sync-request:eval \u0026#34;(require \u0026#39;portal.api) (portal.api/tap) (portal.api/open)\u0026#34;)) (defun portal.api/clear () (interactive) (cider-nrepl-sync-request:eval \u0026#34;(portal.api/clear)\u0026#34;)) (defun portal.api/close () (interactive) (cider-nrepl-sync-request:eval \u0026#34;(portal.api/close)\u0026#34;)) rest    (use-package! restclient :mode ((\u0026#34;\\\\.rest\\\\\u0026#39;\u0026#34; . restclient-mode) (\u0026#34;\\\\.restclient\\\\\u0026#39;\u0026#34; . restclient-mode))) (use-package! ob-restclient :after org restclient :init (org-babel-do-load-languages \u0026#39;org-babel-load-languages \u0026#39;((restclient . t)))) Os    ;; OS ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; EXWM    EmacsのWindow Manager.\nもはやこれをつかうと世界がEmacsになりEmacs 引きこもり生活が完成する.\n(use-package! exwm :after counsel :init (setq counsel-linux-app-format-function #\u0026#39;counsel-linux-app-format-function-name-only) (map! :leader :prefix (\u0026#34;z\u0026#34; . \u0026#34;exwm\u0026#34;) \u0026#34;c\u0026#34; #\u0026#39;exwm-reset \u0026#34;o\u0026#34; (lambda (command) (interactive (list (read-shell-command \u0026#34;$ \u0026#34;))) (start-process-shell-command command nil command)) \u0026#34;z\u0026#34; #\u0026#39;exwm-workspace-switch \u0026#34;m\u0026#34; #\u0026#39;exwm-workspace-move-window \u0026#34;a\u0026#34; #\u0026#39;counsel-linux-app \u0026#34;s\u0026#34; #\u0026#39;counsel-search ;; open chrome and search ) (add-hook \u0026#39;exwm-input--input-mode-change-hook \u0026#39;force-mode-line-update) (add-hook \u0026#39;exwm-update-class-hook (lambda () (exwm-workspace-rename-buffer exwm-class-name))) ;; どうもChromeを立ち上げるとハングするので無効にしておく. (winner-mode -1) :config (require \u0026#39;exwm-randr) (setq exwm-randr-workspace-output-plist \u0026#39;(0 \u0026#34;HDMI-1\u0026#34;)) (add-hook \u0026#39;exwm-randr-screen-change-hook (lambda () (start-process-shell-command \u0026#34;xrandr\u0026#34; nil \u0026#34;xrandr --output HDMI-1 --primary --right-of eDP-1 --auto\u0026#34;))) (exwm-randr-enable) (require \u0026#39;exwm-systemtray) (exwm-systemtray-enable) ;; edit-server的な. C-c \u0026#39;で編集できるのでよりbetter ;; 一度入力したものを再度開くと文字化けする. (require \u0026#39;exwm-edit) (setq exwm-edit-split t) (setf epg-pinentry-mode \u0026#39;loopback) (defun pinentry-emacs (desc prompt ok error) (let ((str (read-passwd (concat (replace-regexp-in-string \u0026#34;%22\u0026#34; \u0026#34;\\\u0026#34;\u0026#34; (replace-regexp-in-string \u0026#34;%0A\u0026#34; \u0026#34;\\n\u0026#34; desc)) prompt \u0026#34;: \u0026#34;)))) str)) ;; from https://github.com/ch11ng/exwm/wiki/Configuration-Example (menu-bar-mode -1) (tool-bar-mode -1) (scroll-bar-mode -1) (fringe-mode 1) ;; google-chromeを起動するとmouse on menu-barがpopupしてハングする対策 ;; https://stackoverflow.com/questions/17280845/emacs-disable-pop-up-menus-on-mouse-clicks (fset \u0026#39;menu-bar-open nil) (fset \u0026#39;x-menu-bar-open nil) ;; Turn on `display-time-mode\u0026#39; if you don\u0026#39;t use an external bar. (setq display-time-default-load-average nil) (display-time-mode t) (display-battery-mode 1) (setq exwm-workspace-number 2) (setq exwm-input-simulation-keys \u0026#39;(([?\\C-b] . [left]) ;; Chromeページ内検索のために空ける ;; ([?\\C-f] . [right]) ;; 2022.03.23 やっぱり解除. どうもC-fがスムーズな操作を阻害する. ;; ページ内検索はSurfingkeysというExtensionを利用(/). ([?\\C-f] . [right]) ([?\\C-p] . [up]) ([?\\C-n] . [down]) ([?\\C-a] . [home]) ([?\\C-e] . [end]) ([?\\M-v] . [prior]) ([?\\C-v] . [next]) ([?\\C-d] . [delete]) ([?\\C-m] . [return]) ([?\\C-h] . [backspace]) ([?\\C-k] . [S-end delete]))) (exwm-enable)) Org-mode    ご存知！\n  doom-emacs/README.org at develop · hlissner/doom-emacs · GitHub     dotfiles/50_org-mode.org at master · tsu-nera/dotfiles · GitHub  昔の設定. すこしずつ移植したい.     ;; Org mode ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;; スマホとの共有のため, github を clone したものを Dropbox に置いて$HOME に symlink している. (after! org (setq org-directory \u0026#34;~/keido\u0026#34;) (setq org-default-notes-file \u0026#34;gtd/gtd_projects.org\u0026#34;) (setq org-return-follows-link t) ;; Enter でリンク先へジャンプ (setq org-use-speed-commands t) ;; bullet にカーソルがあると高速移動 (setq org-hide-emphasis-markers t) ;; * を消して表示. (setq org-pretty-entities t) (setq org-footnote-section \u0026#34;Notes\u0026#34;) ;; defaultではFootnotesなので変える. (setq org-footnote-auto-adjust t) ;; M-RET の挙動の調整 ;; t だと subtree の最終行に heading を挿入, nil だと current point に挿入 ;; なお，C-RET だと subtree の最終行に挿入され, C-S-RET だと手前に挿入される. (setq org-insert-heading-respect-content nil) (setq org-startup-indented t) (setq org-indent-mode-turns-on-hiding-stars nil) (setq org-startup-folded \u0026#39;show2levels);; 見出しの階層指定 (setq org-startup-truncated nil) ;; 長い文は折り返す. ;; electric-indent は org-mode で誤作動の可能性があることのこと ;; たまにいきなり org-mode の tree 構造が壊れるから，とりあえず設定しておく. ;; この設定の効果が以下の記事で gif である. ;; https://www.philnewton.net/blog/electric-indent-with-org-mode/ (add-hook! org-mode (electric-indent-local-mode -1)) ;; org-agenda (setq org-refile-targets \u0026#39;((org-agenda-files :maxlevel . 3))) (setq org-agenda-time-leading-zero t) ;; 時間表示が 1 桁の時, 0 をつける (setq calendar-holidays nil) ;; 祝日を利用しない. (setq org-log-done \u0026#39;time);; 変更時の終了時刻記録. ;; スケジュールやデッドラインアイテムは DONE になっていれば表示する (setq org-agenda-skip-deadline-if-done nil) (setq org-agenda-skip-scheduled-if-done nil) (setq org-agenda-include-inactive-timestamps t) ;; default で logbook を表示 (setq org-agenda-start-with-log-mode t) ;; ;; default で 時間を表示 ;; org-agenda speedup tips ;; https://orgmode.org/worg/agenda-optimization.html ;; 何でもかんでも agenda すると思いので厳選. (setq org-agenda-files \u0026#39;(\u0026#34;~/Dropbox/keido/notes/gtd/gtd_projects.org\u0026#34; \u0026#34;~/Dropbox/keido/notes/journals/journal.org\u0026#34;)) ;; projectsディレクトリにある.orgをみる. ;; その配下のorgファイルは対象にはならない. ;; \u0026#34;~/Dropbox/keido/notes/gtd/projects\u0026#34;) ;; 期間を限定 (setq org-agenda-span 7) ; Inhibit the dimming of blocked tasks: (setq org-agenda-dim-blocked-tasks nil) ;; Inhibit agenda files startup options: (setq org-agenda-inhibit-startup nil) ;; Disable tag inheritance in agenda: (setq org-agenda-use-tag-inheritance nil) ) ;; org-mode で timestamp のみを挿入するカスタム関数(hh:mm) (after! org (defun my/insert-timestamp () \u0026#34;Insert time stamp.\u0026#34; (interactive) (insert (format-time-string \u0026#34;%H:%M\u0026#34;))) (map! :map org-mode-map \u0026#34;C-c C-.\u0026#34; #\u0026#39;my/insert-timestamp)) ;; +pretty(org-superstar-mode)関連 ;;; Titles and Sections ;; hide #+TITLE: ;; (setq org-hidden-keywords \u0026#39;(title)) ;; set basic title font ;; (set-face-attribute \u0026#39;org-level-8 nil :weight \u0026#39;bold :inherit \u0026#39;default) ;; Low levels are unimportant =\u0026gt; no scaling ;; (set-face-attribute \u0026#39;org-level-7 nil :inherit \u0026#39;org-level-8) ;; (set-face-attribute \u0026#39;org-level-6 nil :inherit \u0026#39;org-level-8) ;; (set-face-attribute \u0026#39;org-level-5 nil :inherit \u0026#39;org-level-8) ;; (set-face-attribute \u0026#39;org-level-4 nil :inherit \u0026#39;org-level-8) ;; Top ones get scaled the same as in LaTeX (\\large, \\Large, \\LARGE) ;; (set-face-attribute \u0026#39;org-level-3 nil :inherit \u0026#39;org-level-8 :height 1.2) ;\\large ;; (set-face-attribute \u0026#39;org-level-2 nil :inherit \u0026#39;org-level-8 :height 1.44) ;\\Large ;; (set-face-attribute \u0026#39;org-level-1 nil :inherit \u0026#39;org-level-8 :height 1.728) ;\\LARGE ;; Only use the first 4 styles and do not cycle. (setq org-cycle-level-faces nil) (setq org-n-level-faces 4) ;; Document Title, (\\huge) ;; (set-face-attribute \u0026#39;org-document-title nil ;; :height 2.074 ;; :foreground \u0026#39;unspecified ;; :inherit \u0026#39;org-level-8) ;; (with-eval-after-load \u0026#39;org-superstar ;; (set-face-attribute \u0026#39;org-superstar-item nil :height 1.2) ;; (set-face-attribute \u0026#39;org-superstar-header-bullet nil :height 1.2) ;; (set-face-attribute \u0026#39;org-superstar-leading nil :height 1.3)) ;; Set different bullets, with one getting a terminal fallback. (setq org-superstar-headline-bullets-list \u0026#39;(\u0026#34;■\u0026#34; \u0026#34;◆\u0026#34; \u0026#34;●\u0026#34; \u0026#34;▷\u0026#34;)) ;; (setq org-superstar-special-todo-items t) ;; Stop cycling bullets to emphasize hierarchy of headlines. (setq org-superstar-cycle-headline-bullets nil) ;; Hide away leading stars on terminal. ;; (setq org-superstar-leading-fallback ?\\s) (setq inhibit-compacting-font-caches t) ;; 読書のためのマーカー（仮） ;; あとでちゃんと検討と朝鮮しよう. ;; (setq org-emphasis-alist ;; \u0026#39;((\u0026#34;*\u0026#34; bold) ;; (\u0026#34;/\u0026#34; italic) ;; (\u0026#34;_\u0026#34; underline)) ;; (\u0026#34;=\u0026#34; (:background \u0026#34;red\u0026#34; :foreground \u0026#34;white\u0026#34;)) ;; 書き手の主張 ;; (\u0026#34;~\u0026#34; (:background \u0026#34;blue\u0026#34; :foreground \u0026#34;white\u0026#34;)) cddddd;; 根拠 ;; (\u0026#34;+\u0026#34; (:background \u0026#34;green\u0026#34; :foreground \u0026#34;black\u0026#34;)))) ;; 自分の考え org-capture    https://orgmode.org/manual/Capture-templates.html\n(after! org (defun my/create-timestamped-org-file (path) (expand-file-name (format \u0026#34;%s.org\u0026#34; (format-time-string \u0026#34;%Y%m%d%H%M%S\u0026#34;)) path)) (defun my/create-date-org-file (path) (expand-file-name (format \u0026#34;%s.org\u0026#34; (format-time-string \u0026#34;%Y-%m-%d\u0026#34;)) path)) (defconst my/captured-notes-file \u0026#34;~/keido/inbox/inbox.org\u0026#34;) (setq org-capture-templates \u0026#39;((\u0026#34;i\u0026#34; \u0026#34;📥 Inbox\u0026#34; entry (file \u0026#34;~/keido/inbox/inbox.org\u0026#34;) \u0026#34;* %?\\nCaptured On: %U\\n\u0026#34; :klll-buffer t) (\u0026#34;I\u0026#34; \u0026#34;📥+🌐 Inbox+Browser\u0026#34; entry (file \u0026#34;~/keido/inbox/inbox.org\u0026#34;) \u0026#34;* %?\\nSource: [[%:link][%:description]]\\nCaptured On: %U\\n\u0026#34; :klll-buffer t) (\u0026#34;q\u0026#34; \u0026#34;📥+🌐 Inbox+Browser(quote)\u0026#34; entry (file \u0026#34;~/keido/inbox/inbox.org\u0026#34;) \u0026#34;* %?\\nSource: [[%:link][%:description]]\\nCaptured On: %U\\n%i\\n\u0026#34; :klll-buffer t) (\u0026#34;c\u0026#34; \u0026#34;☑ Planning\u0026#34; plain (file+headline (lambda () (my/create-date-org-file \u0026#34;~/keido/notes/journals/daily\u0026#34;)) \u0026#34;Planning\u0026#34;) \u0026#34;%?\u0026#34; :unnarrowed t :kill-buffer t) (\u0026#34;t\u0026#34; \u0026#34;🤔 Thought\u0026#34; entry (file+headline (lambda () (my/create-date-org-file \u0026#34;~/keido/notes/journals/daily\u0026#34;)) \u0026#34;Thoughts\u0026#34;) \u0026#34;* 🤔 %?\\n%T\u0026#34; :empty-lines 1 :unnarrowed t :kill-buffer t) (\u0026#34;T\u0026#34; \u0026#34;🤔+📃 Thought+Ref\u0026#34; entry (file+headline (lambda () (my/create-date-org-file \u0026#34;~/keido/notes/journals/daily\u0026#34;)) \u0026#34;Thoughts\u0026#34;) \u0026#34;* 🤔 %?\\n%T from %a\\n\u0026#34; :empty-lines 1 :unnarrowed t :kill-buffer t) (\u0026#34;l\u0026#34; \u0026#34;🤔+🌐 Thought+Browser\u0026#34; entry (file+headline (lambda () (my/create-date-org-file \u0026#34;~/keido/notes/journals/daily\u0026#34;)) \u0026#34;Thoughts\u0026#34;) \u0026#34;* 🤔 %?\\n%T from [[%:link][%:description]]\\n\u0026#34; :empty-lines 1 :unnarrowed t :kill-buffer t) (\u0026#34;p\u0026#34; \u0026#34;🍅 Pomodoro\u0026#34; entry (file+headline (lambda () (my/create-date-org-file \u0026#34;~/keido/notes/journals/daily\u0026#34;)) \u0026#34;DeepWork\u0026#34;) \u0026#34;* 🍅 %?\\n%T\u0026#34; :empty-lines 1 :unnarrowed t :kill-buffer t) (\u0026#34;j\u0026#34; \u0026#34;🖊 Journal\u0026#34; plain (file (lambda () (my/create-date-org-file \u0026#34;~/keido/notes/journals/daily\u0026#34;))) \u0026#34;%?\u0026#34; :empty-lines 1 :unnarrowed t :kill-buffer t) (\u0026#34;J\u0026#34; \u0026#34;🖊+📃 Journal+Ref\u0026#34; plain (file (lambda () (my/create-date-org-file \u0026#34;~/keido/notes/journals/daily\u0026#34;))) \u0026#34;%?\\n%a\u0026#34; :empty-lines 1 :unnarrowed t :kill-buffer t) (\u0026#34;L\u0026#34; \u0026#34;🖊+🌐 Journal+Browser\u0026#34; plain (file (lambda () (my/create-date-org-file \u0026#34;~/keido/notes/journals/daily\u0026#34;))) \u0026#34;%?\\nSource: [[%:link][%:description]]\\nCaptured On: %U\\n\u0026#34; :empty-lines 1 :unnrrowed t :kill-buffer t))) ) Google Chrome Extention: Org Capture    Google Chromeにを入れることでWeb Pageがorg-captureと連携(link).\nChromeでCtrl + Shift + Lで起動.\norg-babel    Org-modeのなかでLiterature Programming.\n基本操作:\n C-c C-, コードブロックの挿入テンプレート呼び出し(org-insert-structure-tempate) C-c C-c コード実行(org-babel-execute-src-block) C-c C-o コード実行結果を開く(org-babel-open-src-block-result) C-c \u0026rsquo; ソースコード編集(org-edit-src-code)  どうもEoom Emacsだと keybindingが外れいてる. C-c l \u0026lsquo;(org-edit-special)で開く.     (after! org ;; https://stackoverflow.com/questions/53469017/org-mode-source-editing-indents-code-after-exiting-source-code-block-editor ;; インデント. default 2になっているとへんな隙間が先頭に入る. (setq org-edit-src-content-indentation 0) (setq org-src-preserve-indentation t) ;; TABの挙動 (setq org-src-tab-acts-natively t) ;; org-babel のソースをキレイに表示. (setq org-src-fontify-natively t) (setq org-fontify-whole-heading-line t) ;; 評価でいちいち質問されないように. (setq org-confirm-babel-evaluate nil) ;; org-babel で 実行した言語を書く. デフォルトでは emacs-lisp だけ. (org-babel-do-load-languages \u0026#39;org-babel-load-languages \u0026#39;((lisp . t) (shell . t) (clojure . t))) (org-defkey org-mode-map \u0026#34;\\C-u\\C-x\\C-e\u0026#34; \u0026#39;cider-eval-last-sexp) ) refs:\n org-babel Key bindings and Useful Functions (The Org Manual) org-modeのコードブロック(Babel)の使い方 | Misohena Blog  org-export    Org-modeのファイルをエクスポートする機能.\nサブパッケージが数多くあるが, ここでは共通情報まとめ.\norg-export-with-xxxという設定項目でいろいろ制御できる.\nExport Settings (The Org Manual)\nしかし, 以下が自動的に変換されてしまう\u0026hellip;この文字に対する制御方法が見つからない\u0026hellip;\n   \u0026gt;\n  \u0026lt; \u0026lt; \u0026amp; \u0026amp;  どうもHTML tagとかHTML Entitiesと呼ばれている(ref. The Org Manual).\n The HTML export back-end transforms ‘\u0026lt;’ and ‘\u0026gt;’ to ‘\u0026lt;’ and ‘\u0026gt;’.\n ただox-html.elにはこういう設定がdefaultでされている. 他のexportへの移植が必要.\n(setq org-export-html-protect-char-alist \u0026#39;((\u0026#34;\u0026amp;\u0026#34; . \u0026#34;\u0026amp;amp;\u0026#34;) (\u0026#34;\u0026lt;\u0026#34; . \u0026#34;\u0026amp;lt;\u0026#34;) (\u0026#34;\u0026gt;\u0026#34; . \u0026#34;\u0026amp;gt;\u0026#34;)) Advanced Export Configuration (The Org Manual)\nおそらく, exportをかけたあとにhook関数によって文字列変換が必要.\n(defun my-hugo-filter-html-amp (text backend info) (when (org-export-derived-backend-p backend \u0026#39;hugo) (replace-regexp-in-string \u0026#34;\u0026amp;amp;\u0026#34; \u0026#34;\u0026amp;\u0026#34; text))) (defun my-hugo-filter-html-gt (text backend info) (when (org-export-derived-backend-p backend \u0026#39;hugo) (replace-regexp-in-string \u0026#34;\u0026amp;gt;\u0026#34; \u0026#34;\u0026gt;\u0026#34; text))) (defun my-hugo-filter-html-lt (text backend info) (when (org-export-derived-backend-p backend \u0026#39;hugo) (replace-regexp-in-string \u0026#34;\u0026amp;lt;\u0026#34; \u0026#34;\u0026lt;\u0026#34; text))) (add-to-list \u0026#39;org-export-filter-plain-text-functions \u0026#39;my-hugo-filter-html-amp) (add-to-list \u0026#39;org-export-filter-plain-text-functions \u0026#39;my-hugo-filter-html-gt) (add-to-list \u0026#39;org-export-filter-plain-text-functions \u0026#39;my-hugo-filter-html-lt) ox-hugo    Org-modeで書いたブログ記事をHugoにあったMarkdown形式に変換する.\nブログFuturismoはOrg-modeで執筆してこれを利用してMarkdownに変換している.\n(use-package! ox-hugo :after \u0026#39;ox :config ;; なんか.dir-locals.elに書いても反映してくれないな. ココに書いとく. (setq org-export-with-author nil)) このox-hugoで出力されるMarkdownはどうもリスト表示でスペースが4つ入ってしまう. GitHub Favorite Markdownのようにリストでのスペース２であって欲しいものの解決方法が見つからない.\nox-rst    Org-modeで書いたWiki用のページをSphinxで公開するためにreST形式に変換する.\nリンク形式がうまく変換できないのでけっこう強引に変換している(もう少しうまく改善したい).\n(use-package! ox-rst :after \u0026#39;ox) (after! ox (defun my/rst-to-sphinx-link-format (text backend info) (when (and (org-export-derived-backend-p backend \u0026#39;rst) (not (search \u0026#34;\u0026lt;http\u0026#34; text))) (replace-regexp-in-string \u0026#34;\\\\(\\\\.org\u0026gt;`_\\\\)\u0026#34; \u0026#34;\u0026gt;`\u0026#34; (concat \u0026#34;:doc:\u0026#34; text) nil nil 1))) (add-to-list \u0026#39;org-export-filter-link-functions \u0026#39;my/rst-to-sphinx-link-format)) ob-html    org-modeのコードブロックでHTMLを「実行」する | Misohena Blog\n(use-package! ob-html :after org :config ;; C-c C-o でブラウザで開く. (org-babel-html-enable-open-src-block-result-temporary)) org-toggl    org-modeをTogglと連携させる. https://github.com/mbork/org-toggl\n(use-package! org-toggl :after org :config (setq org-toggl-inherit-toggl-properties t) (toggl-get-projects) (setq toggl-default-project \u0026#34;GTD\u0026#34;) (org-toggl-integration-mode)) org-journal    https://github.com/bastibe/org-journal\n(use-package! org-journal :after org :bind (\u0026#34;C-c r d n\u0026#34; . org-journal-new-entry) (\u0026#34;C-c r d d\u0026#34; . org-journal-open-current-journal-file) :custom (org-journal-date-prefix \u0026#34;#+TITLE: ✍\u0026#34;) (org-journal-file-format \u0026#34;%Y-%m-%d.org\u0026#34;) (org-journal-dir (file-truename \u0026#34;~/keido/notes/journals/daily\u0026#34;)) (org-journal-date-format \u0026#34;%Y-%m-%d\u0026#34;) :config (setq org-journal-enable-agenda-integration t) (defun org-journal-file-header-func (time) \u0026#34;Custom function to create journal header.\u0026#34; (concat (pcase org-journal-file-type (`daily \u0026#34;#+STARTUP: showeverything\u0026#34;)))) ;; ;; (`weekly \u0026#34;#+TITLE: Weekly Journal\\n#+STARTUP: folded\u0026#34;) ;; ;;(`monthly \u0026#34;#+TITLE: Monthly Journal\\n#+STARTUP: folded\u0026#34;) ;; ;; (`yearly \u0026#34;#+TITLE: Yearly Journal\\n#+STARTUP: folded\u0026#34;)))) (setq org-journal-file-header \u0026#39;org-journal-file-header-func) ;; org-roamに対応させるためにorg-idを生成 (defun org-create-new-id-journal () (goto-char (point-min)) (org-id-get-create) (goto-char (point-max))) (add-hook \u0026#39;org-journal-after-header-create-hook \u0026#39;org-create-new-id-journal) ) org-roam    Zettelkasten MethodのOrg-roam実装.\norg-roam-dialiesよりもorg-journalを利用する(org-agendaの都合).\n;; org-roam (setq org-roam-directory (file-truename \u0026#34;~/keido/notes\u0026#34;)) (setq org-roam-db-location (file-truename \u0026#34;~/keido/db/org-roam.db\u0026#34;)) (use-package! org-roam :after org :init (setq org-roam-v2-ack t) (map! :leader :prefix (\u0026#34;r\u0026#34; . \u0026#34;org-roam\u0026#34;) \u0026#34;f\u0026#34; #\u0026#39;org-roam-node-find \u0026#34;i\u0026#34; #\u0026#39;org-roam-node-insert \u0026#34;l\u0026#34; #\u0026#39;org-roam-buffer-toggle \u0026#34;t\u0026#34; #\u0026#39;org-roam-tag-add \u0026#34;T\u0026#34; #\u0026#39;org-roam-tag-remove \u0026#34;a\u0026#34; #\u0026#39;org-roam-alias-add \u0026#34;A\u0026#34; #\u0026#39;org-roam-alias-remove \u0026#34;r\u0026#34; #\u0026#39;org-roam-ref-add \u0026#34;R\u0026#34; #\u0026#39;org-roam-ref-remove \u0026#34;o\u0026#34; #\u0026#39;org-id-get-create \u0026#34;u\u0026#34; #\u0026#39;my/org-roam-update ) :custom ;;ファイル名を ID にする. (org-roam-capture-templates \u0026#39;((\u0026#34;z\u0026#34; \u0026#34;🎓 Zettelkasten\u0026#34; plain \u0026#34;%?\u0026#34; :target (file+head \u0026#34;zk/%\u0026lt;%Y%m%d%H%M%S\u0026gt;.org\u0026#34; \u0026#34;#+title:🎓${title}\\n#+filetags: :CONCEPT:\\n\u0026#34;) :unnarrowed t) (\u0026#34;w\u0026#34; \u0026#34;📝 Wiki\u0026#34; plain \u0026#34;%?\u0026#34; :target (file+head \u0026#34;zk/%\u0026lt;%Y%m%d%H%M%S\u0026gt;.org\u0026#34; \u0026#34;#+title:📝${title}\\n#+filetags: :WIKI:\\n\u0026#34;) :unnarrowed t) (\u0026#34;t\u0026#34; \u0026#34;🏷 Tag\u0026#34; plain \u0026#34;%?\u0026#34; :target (file+head \u0026#34;zk/%\u0026lt;%Y%m%d%H%M%S\u0026gt;.org\u0026#34; \u0026#34;#+title:List of ${title} (alias 🏷${title}) \\n#+filetags: :TAG:\\n\u0026#34;) :unnarrowed t) (\u0026#34;i\u0026#34; \u0026#34;📂 TOC\u0026#34; plain \u0026#34;%?\u0026#34; :target (file+head \u0026#34;zk/%\u0026lt;%Y%m%d%H%M%S\u0026gt;.org\u0026#34; \u0026#34;#+title:Index of {title} (alias 📂${title})\\n#+filetags: :TOC:\\n\u0026#34;) :unnarrowed t) (\u0026#34;m\u0026#34; \u0026#34;🏛 MOC\u0026#34; plain \u0026#34;%?\u0026#34; :target (file+head \u0026#34;zk/%\u0026lt;%Y%m%d%H%M%S\u0026gt;.org\u0026#34; \u0026#34;#+title:🏛${title} \\n#+filetags: :MOC:\\n\u0026#34;) :unnarrowed t) (\u0026#34;i\u0026#34; \u0026#34;💡 Issue\u0026#34; plain \u0026#34;%?\u0026#34; :target (file+head \u0026#34;zk/%\u0026lt;%Y%m%d%H%M%S\u0026gt;.org\u0026#34; \u0026#34;#+title:💡${title} \\n#+filetags: :ISSUE:\\n\u0026#34;) :unnarrowed t) (\u0026#34;d\u0026#34; \u0026#34;🗒 DOC\u0026#34; plain \u0026#34;%?\u0026#34; :target (file+head \u0026#34;zk/%\u0026lt;%Y%m%d%H%M%S\u0026gt;.org\u0026#34; \u0026#34;#+title:🗒${title}\\n#+filetags: :DOC:\\n\u0026#34;) :unnarrowrd t) (\u0026#34;f\u0026#34; \u0026#34;🦊 Darkfox\u0026#34; plain \u0026#34;%?\u0026#34; :target (file+head \u0026#34;darkfox/%\u0026lt;%Y%m%d%H%M%S\u0026gt;.org\u0026#34; \u0026#34;#+title:🦊${title}\\n#+filetags: :DARKFOX:\\n\u0026#34;) :unnarrowed t) (\u0026#34;b\u0026#34; \u0026#34;📚 Book\u0026#34; plain \u0026#34;%? - title: %^{title} - authors: %^{author} - date: %^{date} - publisher: %^{publisher} - url: http://www.amazon.co.jp/dp/%^{isbn} \u0026#34; :target (file+head \u0026#34;zk/%\u0026lt;%Y%m%d%H%M%S\u0026gt;.org\u0026#34; \u0026#34;#+title:📚${title} - ${author}(${date})\\n#+filetags: :BOOK:SOURCE:\\n\u0026#34;) :unnarrowed t) (\u0026#34;s\u0026#34; \u0026#34;🎙‍ Talk\u0026#34; plain \u0026#34;%? - title: %^{title} - editor: %^{editor} - date: %^{date} - url: %^{url} \u0026#34; :target (file+head \u0026#34;zk/%\u0026lt;%Y%m%d%H%M%S\u0026gt;.org\u0026#34; \u0026#34;#+title:🎙 ${title} - ${editor}(${date})\\n#+filetags: :TALK:SOURCE:\\n\u0026#34;) :unnarrowed t) (\u0026#34;o\u0026#34; \u0026#34;💻 Online\u0026#34; plain \u0026#34;%? - title: %^{title} - authors: %^{author} - url: %^{url} \u0026#34; :target (file+head \u0026#34;zk/%\u0026lt;%Y%m%d%H%M%S\u0026gt;.org\u0026#34; \u0026#34;#+title:💻${title}\\n#+filetags: :ONLINE:SOURCE:\\n\u0026#34;) :unnarrowed t))) (org-roam-extract-new-file-path \u0026#34;%\u0026lt;%Y%m%d%H%M%S\u0026gt;.org\u0026#34;) ;; :map org-mode-map ;; (\u0026#34;C-M-i\u0026#34; . completion-at-point) :config (defun my/org-roam-update () (interactive) (org-roam-update-org-id-locations) (org-roam-db-sync)) (setq +org-roam-open-buffer-on-find-file nil) (org-roam-db-autosync-mode)) (use-package! websocket :after org-roam) (use-package! org-roam-ui :after org-roam ;; or :after org ;; normally we\u0026#39;d recommend hooking orui after org-roam, but since org-roam does not have ;; a hookable mode anymore, you\u0026#39;re advised to pick something yourself ;; if you don\u0026#39;t care about startup time, use ;; :hook (after-init . org-roam-ui-mode) :config (setq org-roam-ui-sync-theme t org-roam-ui-follow t org-roam-ui-update-on-save t org-roam-ui-open-on-start t)) (use-package! org-roam-timestamps :after org-roam :config (org-roam-timestamps-mode) (setq org-roam-timestamps-remember-timestamps nil) (setq org-roam-timestamps-remember-timestamps nil)) ;; 今どきのアウトライナー的な線を出す. ;; Terminal Mode ではつかえないので一旦無効化する. ;; (require \u0026#39;org-bars) ;; (add-hook! \u0026#39;org-mode-hook #\u0026#39;org-bars-mode) ;; 空白が保存時に削除されると bullet 表示がおかしくなる. ;; なお wl-bulter は doom emacs のデフォルトで組み込まれている. (add-hook! \u0026#39;org-mode-hook (ws-butler-mode -1)) Org-roam管理下のノートの全文検索    Using consult-ripgrep with org-roam for searching notes - How To - Org-roam\nconsult-ripgrepを deft の代わりに使う. より高速.\n(defun my/org-roam-rg-search () \u0026#34;Search org-roam directory using consult-ripgrep. With live-preview.\u0026#34; (interactive) (counsel-rg nil org-roam-directory)) (global-set-key (kbd \u0026#34;C-c r s\u0026#34;) \u0026#39;my/org-roam-rg-search) org-publish(Org-roamのノートをサイトへ公開)    (setq org-publish-project-alist (list (list \u0026#34;keido\u0026#34; :recursive t :base-directory (file-truename \u0026#34;~/keido/notes/wiki\u0026#34;) :publishing-directory \u0026#34;~/repo/keido-hugo/content/notes\u0026#34; :publishing-function \u0026#39;org-hugo-export-wim-to-md))) bibtex関連(Org-ref)    文献管理. Zoteroと連携して，論文というよりは書籍やYoutube動画やWeb記事のメモに利用.\n org-ref ivy-bibtex  ivyのactionは ivy-bibtexでC-SPCで選択-\u0026gt; C-M-oでaction選択候補を出し，pとかeとか押す.   org-roam-bibtex   (use-package! org-ref :config (setq bibtex-completion-bibliography (list (file-truename \u0026#34;~/keido/references/zotLib.bib\u0026#34;))) (setq bibtex-completion-additional-search-fields \u0026#39;(keywords)) (setq bibtex-completion-display-formats \u0026#39;((online . \u0026#34;${=has-pdf=:1}${=has-note=:1} ${=type=:6} ${year:4} ${author:24} ${title:*}\u0026#34;) (book . \u0026#34;${=has-pdf=:1}${=has-note=:1} ${=type=:6} ${year:4} ${author:24} ${title:*}\u0026#34;) (video . \u0026#34;${=has-pdf=:1}${=has-note=:1} ${=type=:6} ${year:4} ${editor:24} ${title:*}\u0026#34;) (paper . \u0026#34;${=has-pdf=:1}${=has-note=:1} ${=type=:6} ${year:4} ${author:24} ${title:*}\u0026#34;) (t . \u0026#34;${=has-pdf=:1}${=has-note=:1} ${=type=:6} ${year:4} ${author:24} ${title:*}\u0026#34;))) (setq bibtex-completion-pdf-symbol \u0026#34;📓\u0026#34;) (setq bibtex-completion-notes-symbol \u0026#34;📝\u0026#34;) (setq bibtex-completion-pdf-field \u0026#34;file\u0026#34;) ;; (setq bibtex-completion-pdf-open-function ;;\t(lambda (fpath) ;;\t(call-process \u0026#34;open\u0026#34; nil 0 nil fpath))) ;; Create fields for Film type (add-to-list \u0026#39;bibtex-biblatex-field-alist \u0026#39;((\u0026#34;video\u0026#34; \u0026#34;Video or Audio(like YouTube)\u0026#34;))) (add-to-list \u0026#39;bibtex-biblatex-entry-alist \u0026#39;(\u0026#34;video\u0026#34; \u0026#34;A Video\u0026#34; (\u0026#34;video\u0026#34;, \u0026#34;title\u0026#34; \u0026#34;editor\u0026#34; \u0026#34;date\u0026#34; \u0026#34;url\u0026#34; \u0026#34;urldate\u0026#34; \u0026#34;abstract\u0026#34; \u0026#34;editortype\u0026#34;) nil \u0026#34;keywords\u0026#34;)) (bibtex-set-dialect \u0026#39;biblatex)) (use-package! ivy-bibtex :after org-ref :init (map! :leader :prefix (\u0026#34;b\u0026#34; . \u0026#34;org-ref\u0026#34;) \u0026#34;b\u0026#34; #\u0026#39;org-ref-bibtex-hydra/body \u0026#34;v\u0026#34; #\u0026#39;ivy-bibtex \u0026#34;c\u0026#34; #\u0026#39;org-ref-insert-cite-link \u0026#34;a\u0026#34; #\u0026#39;orb-note-actions \u0026#34;i\u0026#34; #\u0026#39;orb-insert-link) :config (setq ivy-re-builders-alist \u0026#39;((ivy-bibtex . ivy--regex-ignore-order) (t . ivy--regex-plus))) (setq ivy-bibtex-default-action #\u0026#39;ivy-bibtex-open-url-or-doi) (ivy-set-actions \u0026#39;ivy-bibtex \u0026#39;((\u0026#34;p\u0026#34; ivy-bibtex-open-any \u0026#34;Open PDF, URL, or DOI\u0026#34; ivy-bibtex-open-any) (\u0026#34;e\u0026#34; ivy-bibtex-edit-notes \u0026#34;Edit notes\u0026#34; ivy-bibtex-edit-notes))) ) (use-package! org-roam-protocol :after org-protocol) (use-package! org-roam-bibtex :after org-roam ivy-bibtex :hook (org-mode . org-roam-bibtex-mode) :custom (orb-insert-interface \u0026#39;ivy-bibtex) :config (setq orb-preformat-keywords \u0026#39;(\u0026#34;author\u0026#34; \u0026#34;date\u0026#34; \u0026#34;url\u0026#34; \u0026#34;title\u0026#34; \u0026#34;isbn\u0026#34; \u0026#34;publisher\u0026#34; \u0026#34;urldate\u0026#34; \u0026#34;editor\u0026#34; \u0026#34;file\u0026#34;)) (setq orb-process-file-keyword t) (setq orb-attached-file-extensions \u0026#39;(\u0026#34;pdf\u0026#34;))) Org-noter    PDFの注釈を管理する. :link:weirdNox/org-noter\nはじめの起動がどうやればいいのかワカラなかった. 特定のファイルに記録を残したい場合はPDFのBufferではなく, 適当なheading作成してM-x org-noterを起動するとPDFを選択できる.\nM-x org-noter-create-skeltonという関数がヤばい. 🔗Youtube動画(1:08) PDFからOutlineを抜き出してOrg fileに生成して，あとはそのOrg-fileのBulletのカーソルを移動するとPDFのほうもシンクロして移動できる.\n凄すぎて笑った😂\n(use-package! org-noter :after (:any org pdf-view) :config (setq ;; I want to see the whole file org-noter-hide-other nil ;; Everything is relative to the main notes file org-noter-notes-search-path (list (file-truename \u0026#34;~/keido/notes/wiki\u0026#34;)) )) org-anki    Org-modeとAnkiをつなぐ． https://github.com/eyeinsky/org-anki\n今までanki-editorを利用していたものの，その記法とwikiの相性が悪かった（冗長）. これならorg-modeのheadlineがそのままつかえるのでよさそう.\n(use-package! org-anki :after org :custom ;; one big deckの原則に従う. ;; ref: http://augmentingcognition.com/ltm.html (org-anki-default-deck \u0026#34;Default\u0026#34;) :config (define-key org-mode-map (kbd \u0026#34;C-c n A s\u0026#34;) #\u0026#39;org-anki-sync-entry) (define-key org-mode-map (kbd \u0026#34;C-c n A u\u0026#34;) #\u0026#39;org-anki-update-all) (define-key org-mode-map (kbd \u0026#34;C-c n A d\u0026#34;) #\u0026#39;org-anki-delete-entry)) org-modern    GitHub - minad/org-modern: Modern Org Style\n開発途中なのかいまいち, コードブロックの線もでない\u0026hellip;様子見かな\u0026hellip;\n(after! org-modern (setq ;; Agenda styling org-agenda-block-separator ?─ org-agenda-time-grid \u0026#39;((daily today require-timed) (800 1000 1200 1400 1600 1800 2000) \u0026#34; ┄┄┄┄┄ \u0026#34; \u0026#34;┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄\u0026#34;) org-agenda-current-time-string \u0026#34;⭠ now ─────────────────────────────────────────────────\u0026#34;)) (add-hook \u0026#39;org-mode-hook #\u0026#39;org-modern-mode) (add-hook \u0026#39;org-agenda-finalize-hook #\u0026#39;org-modern-agenda) Term    ;; Term ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Tools    ;; Tools ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; forge    magit拡張, EmacsとGitHubを連携.\ndoom emacsだと (magit +forge) のオプションでインストールできる.\nref: Forge User and Developer Manual\n(after! magit (setq auth-sources \u0026#39;(\u0026#34;~/.authinfo\u0026#34;)) (setq magit-revision-show-gravatars \u0026#39;(\u0026#34;^Author: \u0026#34; . \u0026#34;^Commit: \u0026#34;)) ;; (setq magit-diff-refine-hunk \u0026#39;all) ) リポジトリ名を変更した場合はissueやPRの作成が失敗する. これは .git/configの問題なのでローカルのファイルを修正する.\ngit-link    現在のバッファの位置のGitHubのurlを取得.\nsshaw/git-link\n(global-set-key (kbd \u0026#34;C-c g l\u0026#34;) \u0026#39;git-link) (use-package! git-link :config ;; urlにbranchではなくcommit番号をつかう. ;; org-journalへの貼り付けを想定しているのでこの設定にしておく. (setq git-link-use-commit t)) UI    みため周りの設定.\nDoom    ;; UI ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;; どうもフォントが奇数だと org-table の表示が崩れる. ;; Source Han Code JP だとそもそも org-table の表示が崩れる. ;; terminal だと大丈夫な模様.そもそも Terminal はこの設定ではなくて ;; Terminal Emulator の設定がきく. ;; (setq doom-font (font-spec :family \u0026#34;Source Han Code JP\u0026#34; :size 12 )) (setq doom-font (font-spec :family \u0026#34;Ricty Diminished\u0026#34; :size 15)) ;; doom-molokaiやdoom-monokai-classicだとewwの表示がいまいち. (setq doom-theme \u0026#39;doom-molokai) (doom-themes-org-config) ;; counselとdoom-modelineが相性悪いようなので ;; workspace name表示のためには追加で設定. ;; https://github.com/hlissner/doom-emacs/issues/314 (after! doom-modeline (setq doom-modeline-icon (display-graphic-p)) (setq doom-modeline-major-mode-icon t)) https://github.com/seagle0128/doom-modeline\nemojify    Emacsで絵文字をつかう.\nどうもemojifyの絵文字辞書は，emojione-v2.2.6-22というものでやや古い. Twitterが好きなのでTwitterのオープンソース辞書のtwemojiに変更.\nhttps://github.com/iqbalansari/emacs-emojify/blob/master/data/emoji-sets.json\n(after! emojify (setq emojify-emoji-set \u0026#34;twemoji-v2-22\u0026#34;)) ただ，2022現在twemojiはv13なのでv2は古いな..というかでないやつもおおい.\nEmacsの機能でemoji-searchがあるのでこれも設定しておこう. こっちの辞書のほうが扱える文字か多い.\n;; doomだと C-c i eでemojify-insert-emoji (global-set-key (kbd \u0026#34;C-c i E\u0026#34;) \u0026#39;emoji-search) svg-tag-mode    TODOほかラベルを美しく.\nGitHub - rougier/svg-tag-mode\n(use-package! svg-tag-mode :config (setq svg-tag-tags \u0026#39;( ;; :XXX: (\u0026#34;\\\\(:[A-Z]+:\\\\)\u0026#34; . ((lambda (tag) (svg-tag-make tag :beg 1 :end -1)))) ;; :XXX|YYY: (\u0026#34;\\\\(:[A-Z]+\\\\)\\|[a-zA-Z#0-9]+:\u0026#34; . ((lambda (tag) (svg-tag-make tag :beg 1 :inverse t :margin 0 :crop-right t)))) (\u0026#34;:[A-Z]+\\\\(\\|[a-zA-Z#0-9]+:\\\\)\u0026#34; . ((lambda (tag) (svg-tag-make tag :beg 1 :end -1 :margin 0 :crop-left t)))) ;; :#TAG1:#TAG2:…:$ (\u0026#34;\\\\(:#[A-Za-z0-9]+\\\\)\u0026#34; . ((lambda (tag) (svg-tag-make tag :beg 2)))) (\u0026#34;\\\\(:#[A-Za-z0-9]+:\\\\)$\u0026#34; . ((lambda (tag) (svg-tag-make tag :beg 2 :end -1)))) ))) Others    (setq display-line-numbers-type t) ; 行番号表示 ;; less でのファイル閲覧に操作性を似せる mode. ;; view-mode は emacs 内蔵. C-x C-r で read-only-mode でファイルオープン ;; doom emacs だと C-c t r で read-only-mode が起動する. (add-hook! view-mode (setq view-read-only t) (define-key ctl-x-map \u0026#34;\\C-q\u0026#34; \u0026#39;view-mode) ;; assinged C-x C-q. ;; less っぼく. (define-key view-mode-map (kbd \u0026#34;p\u0026#34;) \u0026#39;view-scroll-line-backward) (define-key view-mode-map (kbd \u0026#34;n\u0026#34;) \u0026#39;view-scroll-line-forward) ;; default の e でもいいけど，mule 時代に v に bind されてたので, ;; emacs でも v に bind しておく. (define-key view-mode-map (kbd \u0026#34;v\u0026#34;) \u0026#39;read-only-mode)) ;; EXWMの場合suspend-frameでハングするのはたちが悪いので封印. (use-package! frame :bind (\u0026#34;C-z\u0026#34; . nil)) ;; 実験, どうもマウス操作でEmacsの制御が効かなくなることがあるので. (setq make-pointer-invisible nil) "},{"id":3,"href":"/notes/20220128180456/","title":"🎓DarkHorseとは芸術家のような生き方","parent":"🎓Keido HOME","content":"DarkHorseは，標準化時代の定める成功の価値を追い求めない.\nお金，地位，名声\u0026hellip;\nそうではなく，自らの充足感と達成感を追求する. お金ももちろん大事だが，二の次である.\nこれは芸術家の生き方に似ているかもしれない.\n理想の追求のためには社会の求めるものではなく，自分の表現をしなければならない.\n岡本太郎の思想にも近い.\nup: 🏛DarkHorse\n"},{"id":4,"href":"/notes/20220102143826/","title":"🎓GTDで管理するものはタスクではなく気になることである","parent":"🎓Keido HOME","content":"GTDにおけるタスクという言葉を，もっと心を表す言葉で言い換えて読むことはできないか?\nなぜならば，GTDはストレスを処理する方法であり，タスクから生じる気になることを扱う.\n気になること. 不安，懸念，心配, 興味, 関心(concern, interested, care, wonder).\nマインドワンダリングという言葉があるので，ワンダー(woner)という表現がよい.\n🏛生産性\n"},{"id":5,"href":"/notes/20220101130657/","title":"🎓GTDにおいてタスクの優先度は私で決めるのではなくてシステムが決めるもの","parent":"🎓Keido HOME","content":"GTDにおいてタスクの優先度は私で決めるのではなくてシステムが決めるもの.\n事前に与えたパラメーターと今の状況から自動でGTDシステムが判断してこれをやれ！と言うのが理想. そのためにコンテキストをレビューで設定しておく. 私が決めるのはソートのアルゴリズムで優先度ではなかった.\n極論、SQL クエリを投げて先頭のいくつかを取り出してあとはルーレットで決めればいい. そしてOK Googleのような音声アシスタントでそれを実現できれば理想. もしくはシンプルなスマホアプリ.\nよく陥る課題は，とりあえず頭に思い浮かんだことをInbox経由でSomedayに入れたり後で読もうとReferenceに集積していく結果，リストが膨大になりその整理が辛くなり, なぜかストレスフルによってレビューを諦めてしまうところ.\n事前に期限やエネルギー，難易度などのサンクコストをレビューによって明らかにしたらあとは自動で優先度をつけて提示して欲しい. 次はなに? ときけば勝手に次の一手を教えてくれる秘書が理想.もしくは数個の候補からランダムに選択してもいい. GTDシステムというくらいだから，それがアルゴリズムに従って処理するシステムの役目では? もう人間はなにも考えたくないんだ.\n難しい判断はすべてバックエンドのシステムに任せてフロントエンドではみたくないし, それこそがストレスフリーな仕事術はずだった.\n🏛生産性\n"},{"id":6,"href":"/notes/20220102144508/","title":"🎓GTDのキモはマインドフルネス状態を目指してマインドワンダリングを制御すること","parent":"🎓Keido HOME","content":"ストレスフリーとはすなわちマインドフルな状態であり，気になることというのはマインドワンダリングである. そうすると，GTDのキモとはマインドフルネスである.\nGTDの文脈でマインドフルネスを直接言及することはデビッド・アレンさんはしていないが，とても共通点が多い. 文脈ではストレス管理という言葉はよく現れる. GTDはもともとMind Like Waterに強く影響を受けている. これはマインドフルネス状態にとても近い.もう一つ言えば，マインドフルネスというのもサマタ瞑想の状態とヴィパッサナー瞑想の状態があるが，この状態はヴィパッサナーに近い.\nすべてを把握していることで思考にとらわれることがなく，その場で対処せずにInboxに入れて週次レビューを計画することで受け流すことにより，心の平穏を保つ.\nただ，マインドフルネスと少し違うところは，マインドフルネスは受け入れて手放すことが重要視されているが，GTD はすべての気になることをかき集めてそれを判断保留するか明らかにするという点である. 手放すという観点がGTDにはなく，保留にしてはいるものの，明らかにしてすべてを把握するという意気込みがある.\n"},{"id":7,"href":"/notes/","title":"🎓Keido HOME","parent":"Keido","content":"Wiki \u0026amp; Zettelkastenによるtsu-neraの知的生産基盤\naka. Futurismo 別館.\n📝知識まとめ(Wiki)    他者の知識をトピックごとにまとめ.\n 📂計算機科学(Computer Science) 📁ソフトウェア工学(Software Engineering) 📂スタートアップ 📁音楽 📁文学 📁心理学 📂生産性  📝勉強法 📝Zettelkasten Method 📝Sphinx 📝GTD 📝Zotero   📝Z世代 📝Youtube 🏷Twitter 🏷アニメ  🎓知恵まとめ(Zettelkasten)    自己の知恵をまとめ. ツェッテルカステンにおける永久保存版メモ.\n🏛知恵まとめ\n💡仮説まとめ(Issue)     🔬自分を変えるアイデア(aka.ライフハック) 🔬Startup Ideas  📚勉強ノート(Literature Notes)    ツェッテルカステンにおける文献メモ.\nおそらく忠実に書籍の内容をまとめただけだと著作権としてNGなので私見も交えつつ.\n📁勉強記録\n🦊虚無との戦い(DarkFox)    大学生のころ，生きる意味を探求するためのHPをYahoo geocitiesに構築していた. geocities終了とともに閉鎖してしまったHPをここに復活させる.\n🦊虚無との戦い\n🗒このサイトについて    最近の更新履歴はこちら?\nsee also 🏷ブログ構築\n"},{"id":8,"href":"/notes/20220128183215/","title":"🎓UberEats配達員は麻薬密売人","parent":"🎓Keido HOME","content":"UberEats配達員と麻薬密売人の違いがわからない.\nUberEatsの商品は美味しそうであり，美味しそうであるからこそ不健康で，はっきり言ってまえば毒なんだ. 砂糖，塩，そしてトランス脂肪酸，つまり揚げ物.美味しいからみんな買うわけで，不健康なものでなければ儲からないという矛盾.\nこれは依存症ビジネスである. 恐ろしいことだ，ボタンひとつで甘い物や揚げ物が届くなんて. 自分が制御できる人ならいい，依存状態に陥ってしまった人にとっては驚異でしかない. ポルノと何が違うんだ？超常刺激はキケンである.\n生活のためとはいえ, 悪の依存症ビジネスに加担するつもりなのか? 六本木で覚醒剤を売るアフリカ人とマックのポテトを運ぶわたしに違いはあるのか？フードデリバリーは本来社会悪でこの世から消滅するべきなんだ.\nUberEats配達の収入がメイン収入なのにやればやるほど自己肯定感が下がるのは，こういう認知がひねくれているからだと思う.\nref: 💡ウーバーイーツをゲーミフィケーションの報酬として自動注文できるシステム\n"},{"id":9,"href":"/notes/20220128184817/","title":"🎓Web Private APIのハッキングは人間のツボを探求することだ","parent":"🎓Keido HOME","content":"Webサービスには隠された非公開APIがあり，それらは公開されてないからこそハッカーの技法によって解析するしかない.\nしかしそのような秘密のトビラの解析は，人間の体に偏在するツボを探り当てる行為に似ている.\n直感的にはみえないんだ，しかしハッキングすることによってとんでもないボタンが見つかる. ハッキングはハリーポッターでいうところの闇の魔術かもしれない.\nentered from: 📝Twitter Private API\n"},{"id":10,"href":"/notes/20220112100409/","title":"🎓Wikiの整理はソースコードのリファクタリングをするときの心構えでやる","parent":"🎓Keido HOME","content":"良い着眼点，深堀する.\n結局zettelkastenやwikiを含むメモというものはトピックやコンセプト単位ごとにファイルで管理するので，大量のソースコードのマネジメントを操るためのフォルダ構造ったり，情報のまとめ方だったりの，パターンがアルはずであり，それはドキュメントを管理するにしてもコードを管理するにしても，共通点もあるはず.\nref: 🎓知恵をノートで管理してアウトラインとしてコンパイル\n"},{"id":11,"href":"/notes/20220222191656/","title":"🎓コードに働かせるというキャッシュフロークワドラントの第5象限ハッカーになりたい","parent":"🎓Keido HOME","content":"ロバートキヨサキのキャッシュフロクワドラントには投資家, ビジネスオーナー, 自営業, 従業員という4象限がある.\nしかし私は存在しない第5象限, ハッカーという普通の奴らの上を行く象限を目指す.\nビジネスオーナーは人に働かせる, 投資家はお金に働かせる. そしてハッカーはコードに働かせる.\nいや，正直に言うと投資家にもビジネスオーナーにもなりたい. しかし私はお金もないし人と関わるのも苦手だ. そしてコードを書くのは得意だ. なのでプログラムを働かせてお金を稼ぎたい.\nソフトウェアならばいくらでもコピー可能である. 奴隷のように24時間酷使してもよい. そして自分でメンテナンスできる. ハードウェアを交えてロボット開発もよい.\n私はFIREした結果よりもFIREを目指して数学を駆使して開発することにワクワクする. 広義の意味でのAIを所有, ロボットを所有することは資産になる. もう少し具体的には, 今の技術でならBotを所有することかもしれない.\n未来はそのようなAIを所有することが冨になり力になる時代がくるかもしれない. いや，こないかもしれない.\nしかしその不確かなこと, 未踏の世界, 人真似でないことにワクワクするならばその道を進みたい. それはプログラミングができる人にしか進めないHacker Wayなのだから.\nDr.スランプアラレちゃんを開発したい, んちゃ！\nref: 🏛お金 🏛プログラミング\n"},{"id":12,"href":"/notes/20220214080612/","title":"🎓これからおじさんになる私の勉強は抽象度と知恵を意識する","parent":"🎓Keido HOME","content":"概念の基礎的な部分やキモを理解する. そのためには抽象度による整理が必要. 同じ抽象度をグループ化するか具体と抽象で階層にする, やることはSimpleに２つだ, 難しいことはない.\n概念そのものの理解は単なる知識にすぎない. 新しい情報とわたしがすでに知っている知識を結びつける. 具体的には比較と構造を加えることによって自分の味付けをすると知識は知恵になる.\nこれからの勉強は抽象度の整理, 知識から知恵を意識する. そしてその知恵は3分で説明できるかたちで長期記憶に記憶する.\n最近，ここ10年の間に学んだことを結構忘れていることに気づいた. これはこれからもドンドン忘れていくだろう. 今までは新しい情報を得ることが成長につながると思い，深堀をせずにただインプットしていた. もう歳だし，今までの方法でうまく言っていないと思うからこそ，このタイミングで新しい方法を試すことで成長したい.\n大丈夫，IT業界の人はけっこう最新のトレンドを追うことに熱心で, 私と同じトラップにハマっている人はたくさんいるようにみえる. そして若い人は学習意欲はおじさんよりも高いので, どうしたって最新技術を同じ方法で学んでも勝てる保証はない.\nだからこそ，1つずつの知識を磨き込むような他人と違う方法を強化していくことは強みになるはず. おじさんは過去の知識と今の知識を結びつけることを武器にする.\n今はいまいちだけど, コレをこれから強みに育てていく.\nref: 🎓覚悟をもってゆっくり勉強する up: 🏛勉強\n"},{"id":13,"href":"/notes/20220307104708/","title":"🎓タテとヨコからプログラミング言語を学ぶ","parent":"🎓Keido HOME","content":"私は大学受験のセンター試験で世界史を選択したが, そのとき大いに影響を受け, かつワクワク書籍が以下の２つ.\n タテから見る世界史 ヨコから見る世界史  この意味するところは, タテから各国の歴史を通史で捉え, ヨコから各国間の影響や同時代の文化が同歴史を変えていったのかを捉えることによって, 知識を縦横無尽に組み合わせて知的興奮を促す.\nプログラミング言語を学ぶときも, この考えでいきたい.\nすなわち, タテが各言語でありヨコがプログラムにおけるコンセプトやパラダイムである.\nC言語とJavaとRubyとClojure, それぞれの言語ごとの書籍はある. しかしそれぞれの言語に共通するコンセプトを能動的につなげることが大事. その努力がより一層知識を深堀して理解を促し, 記憶に定着する.\nパターンやフレームワークにも転用できるかもしれない.\nそして, このWikiではそのようなヨコの繋がりをタグ🏷 をつかって重要視する.\n🏛プログラミング 🏛勉強\n"},{"id":14,"href":"/notes/20220310220807/","title":"🎓フルベンオタクなのでシンプルなものは美しい","parent":"🎓Keido HOME","content":"たいへんこの言葉に惹かれる. 最近ではClojureに惹かれる.\nSimple made Easy\nしかし原体験としては, 浪人生のときにフルトヴェングラーの奏でる音楽に魅了されたことが間違いなく大きい.\n偉大なものはシンプルである (フルトヴェングラー 音と言葉)\nまさにこれ\nup: 🏛美と芸術\n"},{"id":15,"href":"/notes/20220314085623/","title":"🎓プログラミングスクールというのが壮大なムーンショット実験","parent":"🎓Keido HOME","content":"プログラミングスクールというのはアメリカから輸入したものだ.\nアメリカでは理系の院を卒業した人がソフトウェアエンジニアになる. アメリカの大学はそもそも高額だし, 勉強も難しい.\nしかしそのキャリアパスを崩すイノベーションがプログラミングブートキャンプ.\nなんと理系大学でコンピュータ・サイエンスを学ばずとも, 一気集中で学んでエンジニアになるというキャリアパスが開けた. プログラミングスクールは非常に高額だがCS大学院卒業に比べれば圧倒的に安い. こんな私だって理系大学で情報数学をみっちり学んだ.\nそしてそれを中途半端に輸入して中途半端な教育をするのが日本.\nもともと日本には文系でもなぜかエンジニアになれちゃうという不思議な国. それは会社にはいったら教育機関がありしっかり教えてくれるから. 私の入った新卒の会社だと3年でようやく１つの機能実装を任されるような教育体制だった. 最近のトレンドが3ヶ月でプログラミングを身に着けて実務というのがそもそも月面着陸なみのムーンショットなのだ.\n3ヶ月で一人前にするなんて教育部のおばさんたち(お姉さま方)はびっくりするかもしれない. しかしそれを実際にやってしまうのがプログラミングスクールであり, しかも10人に1人くらいはその教育で普通のぼんくら社員が3年でのんびり育つところを一気に駆け抜けることも事実.\nプログラミングスクールの批判して値段が高いし実務で使えないというのは, そもそも大学や専門学校に比べれば圧倒的に安いのでそれでエンジニアになれれば儲けものだし, 普通は3年で1人前になるところを3ヶ月で目指すところ自体が難しいということを理解すると温かい目で見ることができる.\n🏛プログラミング\n"},{"id":16,"href":"/notes/20220314083804/","title":"🎓プログラミングの初級者から中級者への上達はコードリーディング","parent":"🎓Keido HOME","content":"プログラミングの勉強は初級レベルならば書籍を読んでチュートリアルを読めばよい. 問題はそこから. 実際に仕事でコードを書こうとすると, 本で学んだ知識で対応出来ないことが多い.\nこの課題感はプログラミングスクール後から仕事で使えるレベルのギャップという点で色んな人が課題に感じているはず. 駆け出しエンジニアが実務で使えない問題.\nこの溝を埋めるには, 他人の書いたコードを読んで学ぶしかない. 特に情報が少なくて検索でも見つからない場合は, ひたすらGitHubを漁って他人のコードを読み, これはなにをしているのかを精読するのがよい.\nこの考え方は今にはじまったことではない. 昔UNIXの時代はそもそも検索できなかった. C言語で書かれたOSコードリーディングで力を身に着けた.\nCode Reading ~オープンソースから学ぶソフトウェア開発技法 | Diomidis Spinellis, まつもと ゆきひろAmazon\n🏛プログラミング\n"},{"id":17,"href":"/notes/20211228134532/","title":"🎓わたしには生産性よりも創造性のほうがより重要な価値観","parent":"🎓Keido HOME","content":"集中力を高めたりライフハックをして生産性を追求することも，ワクワクして好奇心のままにいろいろ試したりすることもどちらも好きだし大事な価値観.\nしかし，生産性と創造性は矛盾する概念であり同時に求めることは難しい.\nどちらがわたしにとって重要かというと，創造性だ. なせならば，その元には焦りではなくワクワク感を行動のモチベーションにしたいという欲がある.\n目標を定めてそれに向かって不安と焦りで努力して達成の喜びを追い求めるよりも，今この瞬間にワクワクしていろいろ寄り道しながら目標に向かっていくことのほうが好きだ.\nup: 🏛生産性\n"},{"id":18,"href":"/notes/20220128185436/","title":"🎓作曲家が楽譜を書くのとハッカーがコードを書くことに違いはない","parent":"🎓Keido HOME","content":"entered from: 💻What I Worked On - Paul Graham(2022)\nポール・グレアムの最近の活動に感動.\nハッカーと画家の思想を，エッセイを書いてから数十年たっても実践している. ポール・グレアムがプログラミング言語を創る行為と，マーラーが交響曲を作曲すること，これらに違いはない.\nもっと言ってしまえば，ハッカーの創造行為は芸術家のそれである.\nわたしは学生のときはベートーヴェンに憧れて交響曲作曲家になりたかった. それに比べれば芸術活動としてのプログラミングに憧れ, たとえそれで食えなくても交響曲作曲家よりは圧倒的にましだろう.\n  refs:  🏛プログラミング 🏷Paul Graham 📚Hackers and Painters 💡ベートーヴェンは音楽家を職人から芸術家にした    "},{"id":19,"href":"/notes/20220226185535/","title":"🎓憧れの職業としてのエンジニアが気持ち悪い","parent":"🎓Keido HOME","content":"元ネタは Paul Graham のHacker and Painterから.\nどうも昔からクラシック音楽が好きで作曲家の生き方に憧れを描いているからなのか, 楽器も弾けないくせに芸術家に憧れを抱いていた. しかし私が表現者として熱中したのは落語であり, 芸人としての生き方にも憧れを抱いた. そういう青春時代への憧れがあったものの, 結局的にコードを書くことを生業にすることになった.\nしかしある時, 気づいた.\n 画家は筆と絵の具で自分の表現したいものを表現する. 小説家は文章で自分の表現したいものを表現する. 作曲家は音楽で自分の表現したいものを表現する.  彼らは芸術家という.\n王侯貴族のためのミサ曲が時には必要かもしれない. 資本家のために絵画を書く必要もあるかもしれない. しかしそれは処世を生きるための対処にすぎない. 音楽家や小説家は他人に雇われることをはじめから目指すのか？いや, 憧れの画家や作曲家に自分もなりたいと思ってその道を目指すのだろう. その結果現実の厳しさに心が折れてしまっても, はじめはそうであってほしい.\nプログラミングを学んだ人はどうだろう？もはやプログラミングを学んだらエンジニアになることが当たり前の風潮がある.エンジニアになれれば成功だと. これはコードを書く芸術家という視点から見るなんとも偏りきったものの見方ではないか？\nどちらかというとエンジニアになることは悲しむべきことだ. プログラミングを通じて芸術家を目指すならば, ビジネスオーナーやプロダクトマネージャーの欲しい物を作っている限り芸術家にはなれない.\n最近, このエンジニアバンザイという風潮にとても違和感を感じるのだ. Youtubeのエンジニアに関する動画のサムネイルをみると, 気持ち悪さを感じる. エンジニアになるというということは悔しいことであり無念であること, これはわたしだけの感覚なのだろうか？同意する人はいるのだろうか？\nコードは表現の道具に過ぎず, それを使って何を表現するかだ.\nということを考えながら, プッチーニのラ・ボエームをきいているよ.\nPuccini: La Bohème (Carlos Kleiber, Tokyo, 1981) - YouTube\nref: 🎓作曲家が楽譜を書くのとハッカーがコードを書くことに違いはない\n"},{"id":20,"href":"/notes/20220217165650/","title":"🎓火縄銃のリバースエンジニアリングは歴史的なジパングハッキング","parent":"🎓Keido HOME","content":"戦国時代のゲームチェンジャーである火縄銃.\n種子島に鉄砲伝来といわれているものの実際はバラバラに解体して改良して大量生産した. そしてそのテクノジーでもって武田騎馬軍を織田鉄砲隊が長篠の戦いで駆逐した.\nこれはリバースエンジニアリングによってゲームチェンジャーな技術力を作り上げて力に変えた日本の歴史の好例だ.\n日本のスタートアップは海外のビジネスモデルをパクるだけではなくて, バラバラに解体した上でキモをもとにつくりあげればいいのに(D前館).\n"},{"id":21,"href":"/notes/20211223164613/","title":"🎓焦りではなくワクワク感を行動のモチベーションにしたい","parent":"🎓Keido HOME","content":"焦りではなくワクワク感を行動のモチベーションにしたい\nこれは脳内ホルモンでいうとノルアドレナリンではなくドーパミンをモチベーションにするということであり，一種のゲーミフィケーションでもある.\nハッカーになりたいならば, 恐怖ではなく好奇心で行動を選択する. 恐怖心と好奇心のどちらを優先するかは優劣はない.\nこの価値観に従う！という強い決意でワクワク感を基盤にする.\n🏛生産性\n"},{"id":22,"href":"/notes/20211228133959/","title":"🎓生産性と創造性は矛盾する概念であり同時に求めることは難しい","parent":"🎓Keido HOME","content":"集中力を高めて生産性を追い求めることと，好奇心を元に創造性を発揮することは真逆のことである.\n生産性は時間を短縮する行為であり，目標を達成することが大事な価値観であり，方向性は未来にある.\n一方，創造性は好奇心のままにワクワクして楽しむことであり，今この瞬間の充実が大事な価値観であり，方向性は現在にある.\n生産性を追求すると時間を短縮できるが，好奇心のままにいろいろと寄り道をすると楽しいものの結果的に時間がかかる.\nup: 🏛生産性\n"},{"id":23,"href":"/notes/20211225205649/","title":"🎓生産性を高めるためにはまず環境と体調を整えることが最優先","parent":"🎓Keido HOME","content":"集中力を発揮するためには，まず心を整える必要がある.\n心を整えるためには，身体の調子を整える必要がある.\n身体の調子を整えるには，睡眠，食事，運動の３つが不可欠である.\nさらに，部屋が乱れは心の乱れの鏡であるので，部屋の整理整頓が不可欠である.\nup: 🏛生産性\n"},{"id":24,"href":"/notes/20220112102424/","title":"🎓知恵をノートで管理してコンパイルすることによりアウトラインを生成する","parent":"🎓Keido HOME","content":"アウトプットはコンパイルという着眼点.\ncaptured from: 『アイデアを形にする』アイデア - YouTube ref: コンパイラ周りの技術を元に知的生産技術のためのツールを開発\n"},{"id":25,"href":"/notes/20220209051354/","title":"🎓経道とはThreadである","parent":"🎓Keido HOME","content":"Clojure Threading Macros より.\nThreadというのは, 糸だったり筋道という意味がある.\nこれはわたしではないか？\nup: 🏛経道とは\n"},{"id":26,"href":"/notes/20220209195705/","title":"🎓経道とは仏教を統べる者","parent":"🎓Keido HOME","content":"Googleで自分の名前を検索すると，仏道という意味がでてくる.\n経道滅尽とは何？ Weblio辞書\nつまりいろんな仏教の上位互換ということか？メタクラス？\n父親に名前のことを質問したら，お前はゴーダマシッダールタを超える男だと言っていた.\nしかし実際はあみだくじで決定したことを知っている.\nup: 🏛経道とは\n"},{"id":27,"href":"/notes/20211224073040/","title":"🎓経道とは道を経る者","parent":"🎓Keido HOME","content":"つねみちとは，道を経る者である.すなわち，わたしは自分の道を経る.\n社会や他人の道を歩まない，自分の道を進むのだ.\n名にし負はば，この信念を拭い去ることはできない.\nup: 🏛経道とは\n"},{"id":28,"href":"/notes/20220320064524/","title":"🎓自分の脳と第2の脳のWikiと第3の脳のGoogleの順で知識を検索する","parent":"🎓Keido HOME","content":"知識を検索するとき順番.\nまずは目をつぶって自分の知っている範囲で推論のみで知識を引っ張り出す. それで検索できなければこのKeido(Wiki \u0026amp; Zettelkasten)を検索する. それでも見つからなければ Googleで検索する.\nこのような第2の脳=Second BrainというのはEvernoteで有名になった気がする.\nこれに取り組む意義というのは, 結局のところ知識, つまりシナプスの結合の強さは想起することによってのみ強化される.\nもちろん速く答えにたどり着くという点においてはすぐにGoogleで調べればいい. しかし, 脳を鍛えるという観点において, この習慣を身につけることはボケ防止で悪くない.\n🏛知的生産技術\n"},{"id":29,"href":"/notes/20220306180547/","title":"🎓覚悟をもってゆっくり勉強する","parent":"🎓Keido HOME","content":"🎓これからおじさんになる私の勉強は抽象度と知恵を意識する\nこれをいざ実践しようとすると, けっこう進捗がでない.\nそんなときは, 過去に自分が忘れてきた知識を思い出そう.\n学生のとき一夜漬けで覚えた知識の中で今覚えていることはなんだろうか？もちろん, それで100点の成績を取って先生に褒められたとしても, それから数年経って忘れてしまったら, 自分は自分を褒められるだろうか？\n大学受験のとき, 物理も化学も生物も地学も学んだ. 古文も漢文も, 世界史も地理も日本史も学んだ. それらは今覚えているだろうか？\nたくさんの忘れてしまう知識よりも, 知識と知識を網の目につなぎ合わせた守りの学習のほうが, 残るものが大きい.\n焦ることはない, 慎重に.\n created: \u0026lt;2022-03-06 日 18:06\u0026gt;\n"},{"id":30,"href":"/notes/20211225205954/","title":"🎓部屋が乱れは心の乱れの鏡である","parent":"🎓Keido HOME","content":"心が乱れると部屋の片付けがおろそかになる.\nしたがって，部屋か散らかっているということは心が安定していない.\n逆に言えば，心を整えたかったら部屋の整理整頓をするのがよい.\n🏛マインドフルネス\n"},{"id":31,"href":"/notes/20220128163732/","title":"🎓隼たれということわざにフィットという解釈を加える","parent":"🎓Keido HOME","content":"隼たれ.\n中学の時の理科の先生が言っていて今でも覚えている言葉. 隼は止まると死んでしまう，だから常に努力しなければいけない, というもの.\nしかし20年が経ち新解釈を考えついた. 個性学におけるフィットという概念.\nハヤブサにフィットする生息地は多様に存在する. そしてハヤブサは最も快適に生きられる場所, 獲物を独占できる場所を縄張りとする.高層ビルの立ち並ぶニューヨークのマンハッタン島だって，その都市環境がフィットすれば住み着くのだ.\nすなわち，ハヤブサは常に努力して自分にあった場所を探して飛び回っているのだ. 自分の能力が活かせる場所を探し，選択する能力を持つのだ.\nup: 🏛DarkHorse\n"},{"id":32,"href":"/notes/20220204072630/","title":"🎓集中力のランナーズハイは存在するか","parent":"🎓Keido HOME","content":"集中力は科学的にはこまめに休憩を取ったほうがよいとされているが, 最近どうも疲労感を超えたところに第２の没頭ゾーンがある気がしてた.\nそして科学的研究は作業を開始してから疲労するまでを扱っているように思う.\nマラソンでランナーズハイのようなもので，疲労のピークを一旦超えてしまうとあとは脳が熱を帯び，ワクワクの好奇心をもとに没頭できることがある.\nそして科学的事実は平均的な結論であり，私個人の事実と当てはまるとは限らない.\n"},{"id":33,"href":"/notes/20220314084820/","title":"🎓駆け出しエンジニアが実務で使えないのはWeb業界の問題","parent":"🎓Keido HOME","content":"プログラミングスクールを卒業しても実務で使えないとよくきく.\nこれはそもそも特殊な状況と考える.\nわたしのいたSE業界(組込み業界だが)は数年かけて1人前にするのだ. その代わりになかなかはじめは大きな仕事を任せてくれなく先輩の手伝いをしながら学んでいく. プログラミングスクールというのが壮大なムーンショット実験.\nSE会社だとそもそも教育機関がありちゃんと教育する体制がある. SEといっても自前でシステム開発するのと受託開発や業務委託に分けられる. 業務委託の客先常駐なんてへんなやつを派遣したらそもそも客先に怒られるので使えるレベルに教育するか先輩とセットで売られる.\n駆け出しエンジニアを欲しがるのはスタートアップだろう. なぜなら教育機関なんてスタートアップには用意する余裕がないんだから.\nSE業界とWeb業界に文化の差がある気がする.\n🏛プログラミング\n"},{"id":34,"href":"/notes/20220104155431/","title":"🎤【Z世代】世界を激変させるニュージェネレーション！Z世代の価値観を徹底解説 - 中田敦彦(2021-12-11)","parent":"🎓Keido HOME","content":" title: 【Z世代①】世界を激変させるニュージェネレーション！Z世代の価値観を徹底解説 editor: 中田敦彦のYOUTUBE大学 date: 2021-12-11 url  https://www.youtube.com/watch?v=uIYR83OF7A4 https://www.youtube.com/watch?v=wnoj2XpLwIY   book: Z世代マーケティング 世界を激変させるニューノーマル | ジェイソン・ドーシー アンド デニス・ヴィラ tags: 📝Z世代  highlights    t.1:10 本はアメリカのZ世代について書いてある.    Z世代は世界的なワードなのか.\nX世代, Y世代もある.     X世代: 1965-1976 Y世代: 1997-1995 Z世代: 1996-2012  Z世代は購買力がある     Z世代はもう２５歳になっている.  ! ということはこれからお金を稼ぐにはこの世代をターゲットにする必要がありそうだな.   日本はすくない.  Z世代の特徴     スマホ一択  Eメール知らない. 他をさわったことがない. パソコンですらつかわない   プラットフォーム使い分け  テレビなんてつかわない. Googleではなくて，AmazonやYoutubeに時価でいく.  ! 勉強カフェで井口さんも，基本的にもはもうLINEとInstagramといっていた. ! Instagramという点にとても驚いた.     パーソナライゼーション  ? ようは広告にズブズブに洗脳されている世代ってことでは? ! ある意味すごく危険    キャッシュレスシームレス  お金なんてそもそも古いし，嫌がる.   社会正義  社会に対する価値観を明確に表明した企業にひかれる.  NIKE  X世代とY世代で炎上し，Z世代に強烈に突き刺さった.   エアリー（ブラジャーの会社） ! 実際にマーケティング戦略として成功しているのはすごい.   ! 売上No.1は響かない, なるほど. 個性に響くものが響く.  ? その個性すら広告で洗脳せれて出来上がったものでは     品質・価格に厳しい  安いものは買わない   スマホファーストUI  もう電車や駅の広告なんてみてない.    自動車: シェアビジネス     SNSインフルエンサー を信じる  TikTok, YouTube, Instagram   ! なんかZ世代はIT業界にいると普通のことだな.まあ，Z世代の人たちが使うものを作っている側なので.  ! 次はEmacsですべてを管理するので，E世代かな?    ! ようは，これからアフィリエイトをしようとしたときに，Z世代にターゲットをしぼるのがよい策ということが.  "},{"id":35,"href":"/notes/20220103135419/","title":"🎤【ショート動画時代】YouTubeShorts vs TikTok vs Reels…メディアの次の覇権を担うのは一体どれだ？ - 中田敦彦(2022-01-01)","parent":"🎓Keido HOME","content":" title: 【ショート動画時代】YouTubeShorts vs TikTok vs Reels…メディアの次の覇権を担うのは一体どれだ？ editor: 中田敦彦のYouTube大学 date: 2022-01-01,2022-01-02 url  https://www.youtube.com/watch?v=M0NN3VPmqcg https://www.youtube.com/watch?v=xM1Rsi8fAMk   tags: 📝Z世代  highlights     ショート動画のブームが来ている. Tiktokの月間平均視聴時間がYouTubeを超えた. このブームに着目して各SNSのテック企業も続々と参入している.  YouTube(Google) -\u0026gt; YouTubeShort Instagram(Facebook) -\u0026gt; Instagram Reels(リールズと読む) まさにショート動画の戦国時代に突入している!!   ショート動画が人気な理由.  Z世代はスマホしかもっていない.  スマホは縦型動画が見やすい. みたくない動画は指で弾いて拒否できるIF.   Tiktokはリコメンドによって次の動画が自動的に流れる仕組みがあるから. YouTubeは基本的に検索で次の動画を選択する. バズればアルゴリズムによって一気にたくさんのユーザに自動的にレコメンドする仕組み.  既存の仕組みにはない恐ろしい拡散力.     ショート動画は広告が流せない.  なぜならコンテンツそのものが短いので.   ショート動画そのもので収益化するのではなくこれをCMとして利用する.  つまりメインの収益コンテンツへの誘導として利用する.   これからはショート動画からメインコンテンツへ誘導して収益を上げる流れが確実にくる.  すると，ショート動画を攻略することが次の時代の覇者となるだろう.    notes     Tiktokは優れたレコメンドエンジンの開発に全力を注いだという過去があるということをどこかできいた. CMの役割を担うとということは，当然企業も積極的に進出してくるだろうが，タレントを起用してもその人がショート動画に適用できるかわからないので，TikTockerに企業がアプローチして宣伝してもらうのだろうか?  "},{"id":36,"href":"/notes/20220112143404/","title":"🎤A History of Clojure by Rich Hickey(2021)","parent":"🎓Keido HOME","content":" title: A History of Clojure by Rich Hickey with Q\\\u0026amp;A date: 2021-07-11 url: https://www.youtube.com/watch?v=nD-QHbRWcoM tags: 🏷Clojure 🏷Rich Hickey refs:  🔗Clojure - History  PDFにもなっていて公開されてる.   https://twitter.com/lagenorhynque/status/1270587892780331008  quote: A History of Clojureにも出てくるClojureとScalaのコードベースの変遷が対照的で面白い.     note:  最近(2021)投稿されたリッチー・ヒッキー本人によるClojureの概要とその開発の歴史を解説.    "},{"id":37,"href":"/notes/20220323104545/","title":"👨Dmitri Sotnikov(@yogthos)","parent":"🎓Keido HOME","content":" ClojureのWeb FrameworkであるLumninusの開発者. 書籍Web Development with Clojureの著者.  🏷Clojurians\n"},{"id":38,"href":"/notes/20220406180436/","title":"👨Elon Musk","parent":"🎓Keido HOME","content":" tags: 🏷Founder news:  2022/04/06 イーロン・マスクがTwitter社の筆頭株主 \u0026amp; 取締役へ 2022/04/11イーロン、Twitterの取締役就任を当日朝になって辞退 | ギズモード・ジャパン    "},{"id":39,"href":"/notes/20220324214106/","title":"👨Eric Normand","parent":"🎓Keido HOME","content":" tags: 🏷Clojurians info:  blog: Eric Normand - Functional Programming and Clojure  💡clojure.specは Schemaではない   book: Grokking Simplicity| Amazon    "},{"id":40,"href":"/notes/20220124100401/","title":"👨Jack Dorsey","parent":"🎓Keido HOME","content":"Founder of Twitter. 🏷Twitter 🏷Founder\n2021-11-30: Jack Dorsey TwitterCEO引退.    https://twitter.com/jack/status/1465347002426867720\n"},{"id":41,"href":"/notes/20220320183317/","title":"👨James Reeves(@weavejester)","parent":"🎓Keido HOME","content":"ピエロみたいな人. https://github.com/weavejester\n🏷Clojurians\n"},{"id":42,"href":"/notes/20211215145929/","title":"👨Paul Graham","parent":"🎓Keido HOME","content":" Wizard Programmer of 📝Common Lisp Founder of 📝Y Combinator tags: 🏷Founder refs:  📚ハッカーと画家 あなたはハッカーですか？ハッカーと画家から学ぶハッカー気質について。 | Futurismo My Visit with THE LORD OF THE STARTUPS: Y Combinator\u0026rsquo;s Paul Graham - YouTube ポールグレアム（Paul Graham）の日本語訳エッセー｜Jack｜note    "},{"id":43,"href":"/notes/20211215150109/","title":"👨Peter Thiel","parent":"🎓Keido HOME","content":"反逆の起業家. Zero to Oneの人.\n tags: 🏷Founder  "},{"id":44,"href":"/notes/20220324181935/","title":"👨Stuart Halloway(@stuarthalloway)","parent":"🎓Keido HOME","content":" 📚Programming Clojure の著者. @stuarthalloway - Twitter  Twitterのアイコンと背景画像がチベット仏教僧は危険性を示す.   Datomic 開発メンバ.  🏷Clojurians 🏷Cognitect\n"},{"id":45,"href":"/notes/20211215150641/","title":"👨立川志らく","parent":"🎓Keido HOME","content":" 🏷落語家 🏷落語 談志師匠の弟子  "},{"id":46,"href":"/notes/20211211072826/","title":"👨立川談志","parent":"🎓Keido HOME","content":"tags: 🏷落語 🏷落語家\n"},{"id":47,"href":"/notes/20220114204639/","title":"💡Software-Defined Cooking Machine","parent":"🎓Keido HOME","content":"レシピファイルをもちいたソフトウェアデファインドな全自動夕食調理器.\nコーヒーマシンでも.\nオープンソースなレシピでも.\n"},{"id":48,"href":"/notes/20220128183851/","title":"💡ウーバーイーツをゲーミフィケーションの報酬として自動注文できるシステム","parent":"🎓Keido HOME","content":"ref: 🎓UberEats配達員は麻薬密売人\n超常刺激は社会悪であるが，これをテクノロジーを愛するものとしては否定してはいけない.\nテクノロジーが生み出したものはそれ自体は素晴らしく，それに対して人間の心理が追いついていないならば，それすらもテクノロジーで克服するのが科学者だろう.\n車は素晴らしいがそれによって交通事故で人が死にまくった. しかし社会から車を追放するのではなく，シートベルトを発明した. これと同じことだ.\nウーバーイーツは依存を加速させるという点で個人的には悪であり毒だと思うが，そういう魅力的なものを制御でき，それによってヤル気をブーストできればこんなに素晴らしいものはない！ものは使いようなんだ.\nup: 🔬スタートアップ起業アイデア\n"},{"id":49,"href":"/notes/20220310112920/","title":"💡ソーシャルZettelkasten","parent":"🎓Keido HOME","content":"Roam Researchはzettelkastenではないと思ってる. WikiとZettelkastenは違う.\nTwitterがイメージに近い. Twitter Cloneとしてのzettelkasten.\n仮にソーシャル要素がなくてもよい.\n最近のSNSの悪いところは無限に時間を失うところだ.\nレコメンドシステムが優れすぎていて, またアプリのUIがサクサク動いたりすると, いくらでも次のページをめくりたくなる. あれがWebブラウザなら中毒にはならない, 手のひらというスマホサイズだからこそ中毒になる.\nしかし, こと思考する行為や勉強する行為ならば, それに中毒になることは問題ないんだ. ページをめくるゲーミフィケーション的なを知恵の習熟に応用できれば最高だ.\n隠された部分があると知りたくなるというのは, ゲーミフィケーションでいうところの謎という概念.\n"},{"id":50,"href":"/notes/20220114203614/","title":"💡一人暮らしワンルームのベランダにおける自給自足マシンが欲しい","parent":"🎓Keido HOME","content":"洗濯機みたいな.\n全自動で勝手に野菜をベランダ栽培してほしい. 値段が高くても１年の運用で元が取れれば.\n"},{"id":51,"href":"/notes/20220309205902/","title":"💡初音ミクと暮らす","parent":"🎓Keido HOME","content":"このアイデアを加速させたい.\n🖊iRemoconでミクミクにしてやんよ。 | Futurismo\nGoogle HomeもAmazon Alexaもなかった時代なので先見の明は合ったはずなんだけどな.\n時代の先を行き過ぎた.\n refs: 🔬Startup Ideas 🏷初音ミク\n"},{"id":52,"href":"/notes/20220114205018/","title":"💡哲学を学ぶ学生のための思考ツールを提供するサービス","parent":"🎓Keido HOME","content":" 哲学者のためのツールとしてのアウトライナーを開発  ? 哲学というよくわからない分野を市場にする人はいるのか. ? 誰も狙わないからこそよいのでは.   少し広義にすれば，思考のためのツール = アウトライナーなんだけど市場を狭める. 哲学 x IT という謎の市場. Twitter Cloneとしてのzettelkasten.  Roam Researchはzettelkastenではないと思ってる. WikiとZettelkastenは違う.    "},{"id":53,"href":"/notes/20220114204846/","title":"💡紙の本の電子化の自動化サービス","parent":"🎓Keido HOME","content":"Amazonで紙の本をポチったら自動で本が送られてきて，それを裁断してPDFにしてメール送信するまでを自動化.\n 法律の穴のような気がする. そもそも需要がニッチかな. 私はほしい  なぜならば，Emacsで閲覧しようとしたときにKindleはDRMがかかっていて使えない.  DRM解除はいちおうできるが違法か しかし，このサービスを使いたいひとはDRM解除は自分でやるか？      "},{"id":54,"href":"/notes/20220303195740/","title":"💻【超絶IQ列伝】苫米地メソッド EX 「抽象度とは何か？」苫米地英人","parent":"🎓Keido HOME","content":" title: 【超絶IQ列伝】苫米地メソッド EX 「抽象度とは何か？」苫米地英人 2019年8月1日収録 authors: 🏷苫米地英人 url: https://www.youtube.com/watch?v=pjUzD3I6u-Q tags:  🏷オブジェクト指向プログラミング 🏷Common Lisp 🏷Java 🏷Paul Graham    正直苫米地さんについては今まで気功と引き寄せの法則界隈のスピリチュアルの人という認識しかなかったのだが, このヤバイ動画をみて印象が180度変わってしまった.\nとくにPaul Grahamに密かな憧れを抱いているのでとまべちのともだちがPaulというギャグな関係に興奮.\nここで言っていることが本当なのかわからない, なぜなら(脱)洗脳の専門家でもあるので. しかし内容がとてもおもしろいので，特にコンピュータ・サイエンスの歴史に関わる部分をいくつか箇条書きしておく.\n  t1. カーネギーメロン大学でコンピュータ・サイエンスと分析哲学を同時に専攻.  Computational Linguistics, 日本語だと 計算言語学(ref: Wikipedia).  ref: Carnegie Mellon University - Language Technologies Institute   カーボネル教授, 富田勝さんが助教授というときの大学院生.  ref: ハイミーカーボネル -Jaime Carbonell - Wikipedia ref: 冨田勝 - Wikipedia t.11ではスコット・ファールマンも指導教授だったと言及.  ref: スコットファールマン - Scott Boerma - Wikipedia   memo  世界初音声翻訳システムを開発したとか. 理論は教授が考えたけど実際に下っ端としてLispで実装したのは私と言っている😕.       t5. カーネギーメロン大学では第２次AIブームのとき, 分析哲学を元に人工知能を組み上げることに取り組んでいたのでまさかのCSと分析哲学の二刀流の勉強になったとか.  コンピュータ・サイエンティストは哲学なんてやりたくないんだ！  チョムスキー哲学までやらされた.   知識をコンピュータで表現するためには哲学が必須と考えられていた.  まずは知識表現を形式化して, つまり数式化して人工知能に教え込んでいこうという考え. 哲学の分野ではオントロジー, 存在論. Class Systemとは存在論からきた. そこからオブジェクト指向が派生して中途半端にさらに派生したものがJava.  Javaを開発したジェームズ・ゴスリンに, これを日本で流行らせろと言われたが, Javaの中途半端な抽象に満足できなかったので, 無理！と断ったとか😕.  ref: ジェームズ・ゴスリン - Wikipedia ゴスリンとは指導教授が同じファールマンで先輩と後輩の仲とか😕.         t16.  On LISPを書いたハーバード大の友達, Paul Graham.  カリフォルニアのLispグループの思い出. この動画の世界!  Dynamic Languages Wizards Series - Panel on Language Design - YouTube   いつもはTシャツ短パンのPaulがLisp User会議にいきなりスーツで現れた！  YAHOO!にViawebが50 million(50億円www)で売れたのでスーツを着たとか. この動画ではそのお金をY Combinator立ち上げに当てたとか.  https://youtu.be/6h8o_GEEEtw?t=245 僕はプログラマーなんだ！とビーチサンダルを履いた汚い足を写しているセンスがよい.     苫米地さんがViawebで億万長者になって画家として暮らしているけどプログラムしたくてしょうがないPaul Grahamに, ちょっとプログラム手伝ってとお願いしたら, 「わかった, やってやる. ただし金は払うな!」といったとか😕. もう20年くらい連絡は取ってない.     t21.  初期のLISP User Groupの人たちは30人くらいでみんな顔なじみ. 俺達は季節労働者, LISPで設計開発ができる人なんて本当に人材が限られてたので, あるプロジェクトがはじまればれ期間限定でそれに参加して大金を稼いでいたとか😕. 人工知能は理論としては当時完成していたけどマシンパワーの問題で使い物にならずに金も稼げなかった. 1億倍コンピュータは遅かったので学習が収束しなかった.   t30.  Eric Nyberg - Wikipedia が同級生で社員.  この前会ったら教授になってたとか😕. おれの会社の社員はPaul Grahamと Eric Nybergだ！😕.     t37.  80年代の人工知能研究, 知識表現システムは２つの流れ.  いわゆるニューラルネット研究(PDP, partial dependence plot?).  この流れがディープラーニングになった.   Class System   どちらもカーネギーメロン大が手動.  その背景は, SDI計画, 別名スターウォーズ計画.  ref: 戦略防衛構想 - Wikipedia 研究拠点の中心がカーネギーメロン大に選ばれたので軍事費が注ぎ込まれた.   ソ連の教授級の天才たちもカーネギーメロン大に逃げてきていた.     t70.抽象度という言葉は私が分析哲学を学んで日本に輸入したのだ！  放送という言葉はおじいちゃんがつくったとか.😕    "},{"id":55,"href":"/notes/20220110033325/","title":"💻A Road to Common Lisp - Steve Losh(2018)","parent":"🎓Keido HOME","content":" title: A Road to Common Lisp authors: Steve Losh url: https://stevelosh.com/blog/2018/08/a-road-to-common-lisp/ refs  原文: A Road to Common Lisp / Steve Losh 日本語訳: A Road to Common Lisp 翻訳 · GitHub  \u0026ldquo;A Road to Common Lisp\u0026rdquo; を翻訳してみた - y2q_actionman’s ゴミクズチラ裏      Common Lispを学ぶための一つのロードマップ. 参考になるドキュメント.\n"},{"id":56,"href":"/notes/20220115161831/","title":"💻Augmenting Long-term Memory - Michael Nilsen(2018)","parent":"🎓Keido HOME","content":" title: Augmenting Long-term Memory authors: Nielsen, M. url: http://augmentingcognition.com/ltm.html summary:  NielsenさんのAnkiの使い方. Ankify Everythingという考え方.  日常の些末なことも含めて覚えたいものはなんでもAnkiに登録する.   one big decという考え方の紹介.  AnkiのDeckは１つに全てを打ち込む.  すると管理が楽だしインターリービング学習にもなる.        "},{"id":57,"href":"/notes/20211231160618/","title":"💻GTDを噛み砕く - 吉良野すた(2020)","parent":"🎓Keido HOME","content":" authors: 吉良野すた url: https://stakiran.github.io/gtd%5Fkamikudaku/ date: 2020 tags  📝GTD    highlights    GTD とは秘書である    GTDストレスフリーとは，すっきり，はっきり，ゆっくり     すっきり: 頭のすべてを吐き出す はっきり: 次の行動を指し示す ゆっくり: 割り込みを制御  "},{"id":58,"href":"/notes/20220104010102/","title":"💻How I note - AlexeyShmalko(2020)","parent":"🎓Keido HOME","content":" title: How I note authors: Alexey, Shmalko url: https://www.alexeyshmalko.com/how-i-note/ tags  📝Org-roam 📝Zettelkasten Method    highlights    私はよく本や論文やトークをインプットする.Web記事は形骸なので読まない.     I mostly read books, research papers, and I watch talks. I read less and less articles online—I find most to be too shallow (compared to books), too narrow (dealing with specific technical issues rather than long-living ideas), and not worth taking notes on. (Though there are great ones!)\n 読みながら手でモレスキンノートを取るよ.本に線は引かないけど.     While reading, I take notes on paper (small Moleskine notebook). I don’t highlight.\n モレスキンからの文献メモもOrgzlyからの走り書きのメモも，ウェブキャプチャした記事も全部Inboxにいれる.     Once a day I process my inbox: literature notes from notebook, fleeting notes, tasks, and articles from org file.\n 記事は(book/article/paper/talk)に分類している. org-ref, ivy-bibtex, org-roam-bibtexを使ってorg-fileで管理している.     I maintain a file per resource (book/article/paper/talk).\n  I manage my bibliography with org-ref, ivy-bibtex, and org-roam-bibtex.\n https://www.alexeyshmalko.com/biblio/\nPermanent Noteは再利用可能な形で記述するのがミソ.かんたんに他の文脈に埋め込めるので.     a note describes one idea only. This makes notes reusable—focused ideas are easy to apply in different context.\n Structure notesは Table of Contents(TOC)で，いわゆるMap of Contents(MOC)だ. Topicごとにノートをまとめることが目的.     Structure notes are kind of a table of contents for Zettelkasten (some call them Map of Contents notes)—they help me group notes on a topic.\n Structure Notesには，$をprefixでつけている.グループが小さければ相互リンクさせればいい.ただグループか大きくなってきたら$をprefixとするトピックを作成すればいい.臨機応変に.     When the number of notes in a group is small, you don’t need structure notes—you can just cross-link all relevant notes. But when the number of notes grows, it stops being practical—it is useful to have an overview note.\n  My structure notes usually start with the § prefix.\n Tag Noteというのを作成した.これは\u0026quot;List of xxxx\u0026quot;というタイトルで, #xxxというエイリアスで表現する.このTag Noteに$ではじまるTopicをリンクさせることで，バックリンクをスッキリまとめることができた.     I created “List of something” pages and aliased them to “#something.” Then I could tag programming languages with #programming-language and ideas about programming languages with § Programming Language.This helps to keep the list of backlinks clean.\n Roam Researchの慣習でPlaceholder notesというものがある.これは単語をタイトルにして中身が空白なノートでバックリンクを集めることが目的のモノ.しかしわたしはこれをつかわない.こんなものは役に立たないし，リンクが必要なら直接はれ(とまでは言ってない).     I don’t do that. I find placeholders quite useless. I rarely filled them, and most of them just kept living with a single link. So I deleted all placeholders I had.\n Roam Resarchの別の慣習のように単語を全部リンクするようなWikiの使い方はしない.思慮深くリンクを結ぶんだ.programmingという単語があったからってやたらめったらprogrammingという単語でリンクしまくらない.これを題してMindful Linkingという.     Another practice common in Roam Research is linking every word that you happen to have a note on.\n  I try to be more deliberate with linking\n ノートの種類は絵文字をプレフィックスにつけてディレクトリごと区別してるよ.     /: permanent “knowledge” notes (📝) /biblio: bibliographic (literature) notes (📖) /posts: posts intended for others (🖋) /life: random notes about myself and my small side projects. Not published /life/journal: a place for journaling and my daily notes /: work-related notes. To be deleted when I quit the job. Not published\n Literature NoteとPermanent Noteは区別する，混ぜたら危険.なぜならLiterature NoteはわたしのIdeaでない.    projectごとにディレクトリをわければまとめてアーカイブできる.そしてlifelongなわたしのメモはLifeにランダムに突っ込んでるよ.     In general, it makes sense to create a slip box for every project you have (test: are these notes useful after the project is done?). Job is an example of such a project, and I treat my life as an ultimate project.\n Spaced Repetitionで記憶を養うためにメモに対する質問をorg-fcをつかって作成している.もちろんノート公開のときは削ぎ落としてるけど. 定義系(terminology)とhowto系の質問が多いかな.     In general, it makes sense to create a slip box for every project you have (test: are these notes useful after the project is done?). Job is an example of such a project, and I treat my life as an ultimate project.\n わたしは過去のブログも全部Slipboxにぶち込んだ.大変だったが満足している.なぜならかつては3つもサイトがあったんだよ！めんどくさすぎる.動物園かよ!    link: https://www.alexeyshmalko.com/merging-my-websites/\n It’s taxing to maintain a zoo of websites using different technologies, and it is even harder to build an audience for each separately (especially given they are just side projects).\n 過去の記事はすべてリダイレクトしているから問題ない.数年後に削除する.    All of the websites now redirect to this one I’ve managed to merge all paths, so all existing links redirect to the same posts on this website. I’ll shut down other websites in a year or two.\nファイル名はすべてタイムスタンプにしている.なぜならタイトルはしょっちゅう変更するから.そしてそれをそのままURLの記事IDにもつかっている.     Now I use timestamp-based filenames (e.g., 20210613055225.org), and that’s what you can see in URLs.\n "},{"id":59,"href":"/notes/20220105062820/","title":"💻Learning How to Learn - Barbara Oakley(coursera)","parent":"🎓Keido HOME","content":" title: Learning How to Learn: Powerful mental tools to help you master tough subjects authors: Barbara Oakley, Terrence Sejnowski url: https://www.coursera.org/learn/learning-how-to-learn tags  🏷Coursera 📝勉強法    Keywords     ポモドーロテクニック チャンク マジックナンバー4 間隔学習  Teachers    Barbara Oakley    Terrence Sejnowski     テレンス・J・セイノフスキー. 脳科学とニューラルネットワークのパイオニア. ディープラーニング革命という書籍を書いている.  Notes: week1    highlights: week1    Focused vs Diffuse Thinking     Focused Modeは既知の情報で活性化する. 問題解決. Diffuse Modeは未知の情報で活性化する. 記憶と想像力.  Procrastination, Memory, and Sleep     procrastination  先延ばしのこと.   ポモドーロテクニック.  25分と5分の集中と休憩を繰り返す. ここでのポイントは，5分の休憩でちょっとした報酬を用意すること 1. これによってやりたくないという気持ちを乗り越えることができる.   脳の記憶領域はWorking MemoryとLong term Memoryに分かれる.  Working Memoery  黒板のようなもの，一時領域. 前頭葉のあたりにある. 4つのスロットがある.   Long Term Memory  長期に保存される. 脳全体にある.     チャンク  記憶は情報を塊にしておくと記憶しやすい. とくに４つの情報をまとめておくと長期記憶に残りやすい.   Spaced Repetition(間隔学習)  情報はなんども間をあけて触れると記憶に残りやすい.   睡眠には記憶において2つの役割がある.  一つは脳から代謝における 毒素 を排除する.  このことによって頭の働きがよくなる. 実際に睡眠を取ると脳は縮む!! 毒素を排除するは運動もよい.   一つは学習や問題解決を助ける.  睡眠中に脳は情報を整理したり新しい問題解決方法を探す. 脳全体のニューロンが活性化して情報交換をしあう(difuss mode) 夢はその結果現れる.   Terrence Sejnowskiのインタビュー.      ポモドーロテクニックは知っていたけれども休憩に小さな報酬というのは新しい発想.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   "},{"id":60,"href":"/notes/20220304073206/","title":"💻Sun Developer News","parent":"🎓Keido HOME","content":" title: Sun Developer News authors: atm09td, url: https://atm09td.tumblr.com/post/1044423981/sun-developer-news  だれかのtumblrから. 消えそうなので魚拓をとっておく.\n 21世紀に相応しい仕事をしよういまこそ新しいOS、新しい言語をイメージするコグニティブリサーチラボ株式会社代表取締役　苫米地　英人氏\n2002年新年号の談話室時也葉に登場するのはコグニティブ リサーチ ラボ株式会社の代表取締役であり、コンピュータサイエンテストである苫米地英人氏をお迎えしての新春放談。\n苫米地氏は、Javaコンソーシアムの立ち上げに尽力されたり、ジャストシステムで多くのプロダクト開発に関わった実績に加え、大学における活動や、国家プロジェクトでの活躍など多彩な方面で活躍されていますし、コグニティブリサーチ社においては独自のWebサーバをLISPを使って開発するなど、LISPのエキスパートとしても有名。\n今回はコンピューターサイエンテストとしての立場から、今求められているコンピューティングのあり方についてお話を伺った。JavaやSolarisの世界に留まらず、真の次世代コンピューティングについてとてもエキサイティングな話しを伺うことが出来た。そのすべてを紹介することはできないが、その片鱗でも感じてもらいたいと思う。\n文中敬称略\n■コグニティブリサーチラボ今昔物語コグニティブリサーチラボ社（CRL）のユニークなところといえば、なんといってもLISPで開発されたWebServerシステム「Lispache」だろう。これはコグニティブリサーチラボ社のWebを始め、音楽配信サイト www.aoyama.com やiアプリの配信を行っている eapli.net といったサイトで運用されている Web Server です。高いセキュリティとパフォーマンスに加え、無停止でメンテナンス作業ができるなど運用性の高いユニークな特徴を持つ Web Server である。\n甲斐：おもしろいですよね。世間ではapacheかIISかというところに、LISPで組んでいる。\n苫米地氏：JavaでなくLISPというのが面白いんですかね。甲斐：なぜそういうアプローチをするのか、多くのデベロッパの方は興味があると思いますが。そのあたりはJavaOneでもお話されましたよね。\n苫米地氏：しましたね。ただベーステクノロジーでなく製品の話をしました。デベロッパというよりはお客様対象ということで。会社を作った経緯なんですが、85年にフルブライトからお金を貰ってエール大学の人工知能研究所というところに行きまして、それからカーネギーメロンに移りました。そのときの我々はプログラムを作るのが仕事だったんです。その後アメリカに居たときにいろいろな大学の先生から来ないかと誘われていたもので、最終的に九州と徳島に絞った後徳島に決まったんです。たまたまそこにはジャストシステムがあって、そこで浮川さんが毎週のように遊びに来るようになって。研究所作るからと、東京の研究所と徳島と両方見てくれといわれて、ちょうど東京に戻ろうと思っていた頃なので受けたんです。その後自分でやりたいことがあって独立しました。それでソフトウエア業界では辞めたら同業他社で2年間は働かないという暗黙のルールがあったもので、ジャスト的にはマイクロソフトに行くなということだと思うんですけど、僕は間に受けて2年間は民間は一切やらなかったんです。通産省関係のIPAが多いですけれど。当時メールをどれくらいの人が使っていたかという時代ですよ。その頃の私は、日本中の家庭が、もちろん企業もそうだけれど、かなり高速な常時接続がされるようになって、各家庭にまでサーバが入ってくるだろうと。そんな電子的なインフラストラクチャが重要になった時代に、一番重要なのはセキュリティだと。そこで、徹底的にセキュリティを政府プロジェクトでやらせてくれと話をしたんですが、なにしろ電子メールを使ってない人たちだから、そんな時代が来るわけない、っていわれました。でもそのときに2つのグループが分かってくれた。1つは通産省の課長補佐、もう1つはね、なんとSunだったんですよ。本田会長のところへ行って、Ultra2を2台借りたんですよ。アンドSS10かな。そして政府に対してセキュリティのプロジェクトを3つのステップでやらせてくれって言ったんです。開発のステップはそのための一番コアとなる基礎技術を開発するところ。セカンドステップはそれを利用して、盗まれてよいもので実験させてくれと。3番目は盗まれちゃ困るデータね。ファーストステップで作ったのが、まさにSolaris上で作ったLISPのサーバなんですよ。\n■なぜLISPでサーバを？苫米地氏：何でLISPなのか。理由は2つあって、１つはもともと動的オブジェクト指向をやるしかないっていう開発側の論理。もう1つはセキュリティ論理としてエンジンが完全に動的バージョンアップが可能であること。残念ながら未だにJavaはそうじゃない。というのはJavaは完全な動的オブジェクト指向ではないと認識しているんです。例えばタイピングが静的だったりとか。我々は単純に、開発者の論理と運用上の論理だけで選んだんです。開発者の論理として究極の動的なオブジェクト指向を突き詰めたから、ほんのちょっとでもタイピングの静的性向があっちゃったら困る。今になって言えるのは、そこまでピュアに、動的性向にこだわる必要はあったかどうかはなんともいえませんけどね。でも最初だし、足かせをはめたくないと、やっぱり完全に動的じゃないと、こういうことができない、ああいうことができないといった、いろいろな理由があったけれども、それは後からのいいわけであって、本音は純粋に理論的に動的オブジェクト指向を徹底的に突き詰めたいと。それで我々は何をしたかというと、まずWebServerを作った。http1.1準拠の、マルチスレッドにしたけど、外部からみると当時のapacheにできるだけみえるようにして、apacheのセキュリティのバグがあるといえばそのバグも一生懸命真似して、セキュリティホールがあるといえば一生懸命真似して、apacheのふりをして、apacheのつもりでアタックしてくると後で馬鹿を見るようにね（笑）。そこまで真似をして、それでLispacheという名前なんですけど。できあがったLispacheは、とにかく動的オブジェクト指向のWebServerに仕上がったんです。すると、物理空間と論理空間を完全に切り離したシステムができるんです。例えばLispacheで動かしているCRLのサイトは、www.crl.co.jpの後に/company/index.htmlって表示されるじゃないですか。実はindex.htmlってファイル最初から無いんですよ。company/というディレクトリさえないんです。全部リアルタイム生成なんですよ。全部あるかのように生成しているし、ファイルもあるかのように生成しているんです。どこにあるかというと全部抽象的な論理空間に存在しているだけなんです。それは全部オンメモリなんです。これのいいところは、物理空間から切り離しちゃっているでしょ。あとはメモリ空間がどこまでアタック可能かということで、ANSI CommonLISPの場合は、湾岸戦争での採用以来、特に、動的メモリ空間、ヒープというのですが、ここの耐アタック性が徹底的に考慮されていて、セキュリティを高めているんです。セキュリティのために本来やるべきことは抽象空間と物理空間の切り離しなんですよ。だから僕は絶対にディレクトリシステムにあわせてファイルを置いておく、昔からのapache的なやり方ね、あれは止めたほうがいいと思う。例えば、普通のWebサイトではURLを通じてUnixファイルシステムの中身のデータ構造、ヒエラルキーを丸丸他人に見せているでしょ。これはクラッカーに「私のこのindexファイルは、このディスクのこのディレクトリにあるから見に来てください。」と言っているようなもの。それって最大のセキュリティリスクじゃないですか。だから僕は見せるべきじゃないと思っている。\n甲斐：セキュリティのことを考えると。\n苫米地氏：Lispacheの強さは一義的にはそこにあるんですよ。その他の特徴と言えば、推論をかけるときは、ほかのありとあらゆるデータもオブジェクトに入っているから、推論エンジンがオブジェクト生成したい目的にあわせて生成する。それがもう1つのLispacheの特徴で、今で言うとCRMなんかに使えるんですけれど。相手に合わせた生成ができるんですよ。\n甲斐：クッキーじゃなくて。\n苫米地氏：そうです。クッキーレベルじゃなくて、うちでデジタルパスポートと呼んでいる本人の特徴情報を持つデータ構造です。ユーザがあるショッピングモールサイトに行った時に、そのパスポートデータを使って「私はこういう人」というプロファイルが提示できる。政府プロジェクトのときには4段階しか設けなかったんだけれども、完全情報開示、部分情報開示、統計的な情報開示、それとブラインド。身分は明かさないけれど認証だけしてくださいよとか。どこまで自分のプライバシーを明かすかはあくまでもユーザが選ぶ。我々の考えたデジタルパスポートは、「あなたの会社はAだから全部見ていいですよ。あなたの会社はCだから私の統計的データしか見ちゃいけないですよ。」という具合にユーザがお店に自分で指示できるんですよ。それをベースに推論エンジンをかけてHTMLをリアルタイムに生成する。\n苫米地氏：セキュリティの点でもうひとつ大切なことがシステムの堅牢性です。その点うちのLispacheはapacheと違って誰もソースコードを知らないし、LISPなんか書ける人はめったにいないから、セキュリティホールを見つけてもそう簡単にワームを作れない。万が一作られたときに、または自分たちでセキュリティホールを見つけたときにパッチを当てたとするとパッチコードが動的に当たるから、要するにサイトが止らないんですよ。よく絶対止らないと言うのは、物理的な話しじゃないですか。リダンダンシーをどうとかと。そうじゃなくてバージョンアップ中も止まらない。その機能は今のところANSI CommonLISPのLispacheしかないんですよ。\n■本気でエンタープライズ市場に戦いを挑むなら苫米地氏：アメリカのLISPのシェアを取っているフランツという会社があるんですけど、今回JavaOneのBOFの中でそこのエンジニアを一人呼んで、そこで話題になったのがマクロなんです。なんでJavaにはマクロがないの?って。LISPの場合マクロがあって、何がいいかって言うと、例えばコードの使いまわしができるような開発の効率性ですね。開発の効率性の点では、IDEでも同じような効果があるんですが、どこが違うかというとメンテナンス性なんですよ。例えばビジュアルIDE環境で、自由自在にカット\u0026amp;ペーストでコードを大量に貼り付けてプログラムを作ったとします。でも出来上がったときには、ただベターっと貼り付けられている巨大なソースコードになっていて、どこから何を持ってきたのかわからないでしょ。少なくとも今のいわゆるビジュアル環境っていうのは、開発するときにはものすごく効率性がいいんだけれども、一度ビジュアルエディターがソースを生成すると、後は巨大なソースコードが出るだけなんですよ。マクロ環境の場合には開発が終わってもマクロの状態でソースコードがありますから、コンパイラがコンパイルして初めてベターっと長くなる。つまり抽象化された塊ででてくるんですよ。メインテナンスが圧倒的に楽なんですよ。だから他人が作ったプログラムは、他人がプログラムを作ったときのIDE環境がついてくるわけじゃないですから、ということは、ベターっとこんな長いソースコードを渡されちゃったら、ここはどこから来たのというと、あのへんのあれから来たのかもしれないし、これとこれはこの人が書いたプログラムかもしれないし、わからない。メンテナンスしようがないじゃないですか。ところが、マクロの場合には他人のソースコードでも、マクロはまさに固まりできますからね、その抽象度の高いレベルでやれるから、それでマクロがない言語では大規模開発は無理だと思っています。\nセキュリティの視点ではランタイムエンジンが動的にアップデートできる、これが重要なんです。例えばJavaのVMをバージョンアップするときはどうなります?VMを一度落とすでしょ。それじゃあ駄目なんですよ。例えばサーバ上に何かのセキュリティホールがあったとき、それに対するパッチを当てることは簡単です。しかし、当てるときにどういうビジネスリスクがあるかというと、サーバを一瞬止めなきゃいけないんですよ。Solarisだったらパッチ当てるときに、apacheは止めてもサーバは止らないですよね。でもWindows2000の場合はこれはやばいですよ。IISのパッチ当てるとき、だいたいはWindows2000サーバは再立ち上げですから。それはまずい。例えば1000台のサーバを持っていたときに、新しいサーバアタックがでてきたとします。この場合Solaris上でもWindows上でもリスクは同じですよね。そのときサーバ管理者は悩むわけです。どうしよう、パッチを当てるために1台ずつ止めてパッチを当てるのか、Windows2000だと再立ち上げするのかと。この作業の人件費だけで相当な金額になるでしょう。それに、サイトを止めることによる多大な機会損失がある。アメリカのeコマースサイトを1分止めると、1minute 1million dollerといわれているように1分1億円の損失があると。それって大変でしょ。1000台だったら何分止めるかわからないじゃないですか。さすがにWindows2000サーバ再立ち上げが大げさでapacheだけだったとしても、それはサーバそのものを再立ち上げしないといけないんですよ。Javaの問題点というのは、場合によってはVMそのものの問題で有る可能性もあるんですよ。VMの上のレイヤじゃなくて、VMレイヤの可能性も十分ありうるわけ。じゃ、万が一VMにパッチを当てたいときにどうします。それってJavaを一度落とすしかないんですよ。それは我々の発想では受け入れられない。ANSI CommonLISPの昔からの設計の場合、自分自身のバージョンアップをマシンが動いたままできるんですよ。それはできなきゃいけないんです。絶対に自分自身のバージョンアップ中も止まってはいけない。そういうニーズがあるんですよ。昔は誰も電子メールをやっていない時代だから、ウイルスもわからなくて、あまり理解されなかったんですけれど、今だったら理解されると思うんですけれど。特にこの1,2ヶ月ウイルスも多いし。サーバにあるワームが入ってきたときに、サーバを管理している人がパッチを当てるというのは結構なコストだと思うんですよ。実際IISの被害状況を見てみると、インストールしてからまったくパッチを当ててないところが多いんですよね。\n甲斐：だからひっかかるんですけどね。\n苫米地氏：そうです。でも責められない。怠慢といわれるとその管理者たちはかわいそう。それはビジネスディシジョンかもしれないんです。1000台のマシンを動かしているときに、パッチを当てるために20分ずつ止めるわけにはいかないよと。そういうビジネスディシジョンで放っておいたら入られちゃったのかもしれない。要するに完璧なセキュリティシステムなんてないんだから、バージョンアップ、パッチは絶対しなきゃいけない。そのときに止めるということのリスクは避けなければいけない。\n甲斐：LispacheWebServerにしろデジタルパスポートにしろ、セキュリティがすごく重要なわけですよね。Javaはかなり魅力的な言語ではあるが、セキュリティの点では苫米地さんが納得できるものではないので、LISPを使って極力抽象化を行い、URLすらも仮想的なものにして物理的空間と情報空間を分離することにしている。これは言い方を変えると、これまで以上にエンタープライズ市場を狙うJavaに必要なコンセプトと言えます。マクロを取り入れるとか、VMにこだわるとか。そのあたりどう思われますか。\n苫米地氏：パスポートという呼び方については、Microsoftよりも先に我々が使いはじめたということは言っておきたいですが。（笑）それはともかくとして、20年30年使い続けることのできる世界がエンタープライズ市場なんですね。そうなったときに、VCでシステムを作るでしょうか？VCで作る一番の問題点はメンテナンス性の悪さです。それと同じようなことがJavaにも感じるんです。我々にも他人のコードを読むくらいなら自分で作るほうがマシだと思う瞬間があります。しかし、エンタープライズの市場では長い年月の間多くの人が入れ代わり立ち代わりメンテナンスに関わらなければいけないんです。そうなると大切なことはメンテナンス性であり、プログラミングとメンテナンスにおける生産性を向上させることです。今のままのJavaではメンテナンス性や生産性がエンタープライズにはまだ十分では無い。エンタープライズを狙うのであれば、そのあたりを改善するか、極端な話し、全然違う言語をつくり出すくらいあってもいいと思います。考えてみれば、これもまた今更マクロ？という見方もありますし。それがJava3なのか、まったく新しい言語なのか。そう言う議論があってもいいですよね。Javaがエンタープライズを狙うなら、開発環境の中でも特に、メインテナンス環境を改善する必要があるというわけです。これって、IDEがどうのこうのじゃないですよ、大切なことはIDEを使うなら、そのIDEで作ったソースを20年後でもメンテナンスできるかどうかということです。20年たったら開発したときのIDEが無くてメンテナンスできない、これでは話しにならない。そういうことなんです。メンテナンス性というのは。\n甲斐：エンタープライズ市場が求めるメンテナンス性を身に付けることが必須条件ということですね。\n苫米地氏：そうなると圧倒的に強くなると思いますよ。ついこないだまで製造業の設計サイクルなんかは3年から5年だったんですが、いまや週単位になっている。そういうニーズにJavaは効果的なツールになると思います。そのうえでメンテナンス性が向上すれば、今後動的オブジェクト指向が期待される市場では、Javaはまだまだ普及するはずです。\n■ここがヘンだよ今のIT ここまでインタビューは「JavaかLISPか。」というテーマが中心で進んで来たが、実は苫米地氏はそういったテーマは本質的なテーマではないと考えているようだ。つまり、我々も含めてITに関わる多くの人間は、何かと言うとオブジェクト指向なのかそうでないのかとか、Javaなのか.NETなのかとか、オープン系のソリューションなのかレガシーソリューションなのか、そういったことばかり気になって物事を捕らえてしまう傾向がある。これから成功するビジネスモデルはとか。それはそれで簡単に片付けられる問題ではないのだが、苫米地氏は、コンピュータサイエンテストとしての立場から、まさにマクロ的な視野から見た問題点を提示してくれた。\n苫米地氏：ANSI CommonLISPなのかJavaなのか、僕にとってはどちらでもいいんですね。プログラマーのニーズでしかないんですね。我々にとって言語はツールだからね、そのときの必要に応じて選ぶだけで。実際のところ、世の中にはJavaは書けるけどLISPは書けない人の方が多いわけで。ウチだってそうだし。でもね、先に言語ありきじゃいけないんですよ。あくまでもタスク（：task）が先にあっての話し。タスクによっては20万、30万、場合によっては100万とか200万かもしれないサーバのライセンスを使って、そしてSMPの上でバリバリにSolarisを動かさなければいけないことがある。そんなときになんでも「LinuxとJavaで。」と言う人はかえっておかしいと思う。それはLinuxを信じ過ぎだし、Javaを信じ過ぎ。実際にタスクがどういう仕様で、どのくらいのコストでどのくらいの開発期間でやっていくかということで選べばいいことで。僕はあんまりこだわっていないんです。ただ、自分のプログラマとしての経験から言うとマクロによる生産性の高さが重要だと思っています。今だとANSI CommonLISPが圧倒的に生産性が高い。要するにJavaは動的オブジェクトにしたけれども、開発環境的な意味合いで言うとVisual Cと同じくらいの生産性なんですよ。我々はVCの生産性では喰っていけないと思っています。IDEによって単純にエントリーポイントは下がったかも知れないけど、逆にスキルのあるプログラマにとっての生産性は下がることはあっても絶対に上がっていないと思うんですよ。ただ、開発環境の中で、なんかね、MicrosoftのPCカルチャーに引きづられ過ぎという感じがしているんですよ。\n苫米地氏は今のITの在り方に大きな問題点があると語った。例えばオープン系のコミュニテイの在り方ひとつ取っても、苫米地氏はイエローフラグを出してみせる。苫米地氏に言わせると、何かともてはやされているLinuxではあるが、そのビジネスモデルは優秀な企業内プログラマーの才能を横取りしているものだとして怒りすら憶えていると言う。苫米地氏はapacheを例にあげ、apacheが1.3のメンテナンスこそ続いているけれど、2.0のリリースについてはどうなるか見えてこない理由を、多くのソフトウエア企業がプログラマーの成果を横取りして収益に結び付けているからだとしている。そのため多くのプログラマーが自分の才能を無償で提供することに嫌気がさしてきているからだという。そこへ持って来て、「Linuxでエンタープライズビジネスを。」と発言するのは、どこか間違っていないか？というわけだ。ブロードバンドブームもしかりで、電話会社や電力会社が莫大な費用と時間を使って作って来たインフラの一部を間借していたのに、既成事実を作って如何にも先進企業のような顔をして歩いている企業がいることにうんざりしているようだ。これらはどれもが「来年の業績アップだけを考えて行動している。」結果の現れだと言うことが納得できる。全部が全部、来年の業績向上だけを考えているようでは、この先真っ暗やみだということだ。だからこそ、Sunをはじめ「心ある」プログラマーや研究者には未来を意識してほしいということだろう。苫米地氏は、プログラマーや研究者、科学者に対して未来を考えてモノ作りをして欲しいと語ったが、我々の周りが消費社会である限りユーザは無関係というわけにはいかない。むしろ良い企業やプログラマーを育てるには、ユーザ側が未来を意識する必要があると感じた。\nさらに、未来をつくり出す可能性も持ったツールとしてJavaを評価しながら、現在のJavaとJavaを取り巻く環境がそれを台なしにしてしまうと語る。その最大の理由はバイトコードコンパチが失われかけていることだと指摘した。そしてバイトコードコンパチがJavaの生き残る道だと強調する。\n苫米地氏：最近Javaが単純にバイトコードで動かせなくなってきた。僕はJavaはバイトコードを捨てちゃいけないと思っています。バイトコードだけは保証せよ！と言いたいですね。バイトコードによるポータビリティは最大のメッセージだったと思うんです。でも最近そういうことあまり言わないでしょ。ここはまさに50年後に通用するメッセージだから絶対に守るべきだったと思うんです。これが最近ないがしろにされている気がするんです。バイトコードで走らせて遅くて困るアプリケーションっていくつあるんですか？って。本当に困るんであれば、そういうときだけコンパイルしたものを使えばいいじゃない。それにもうひとつ、バイナリにした瞬間にセキュリティリスクが出てくるんですよ。元々最初の頃のJavaの最大の利点はセキュリティだったんです。それはバイトコードという抽象度で切り離すことでイリーガルなインストラクションは吐き出させない。例えばこのメモリはいじらせない、このCPUインストラクションはたたかせない。そういったことをコントロールする。だからバイトコードを使うことで圧倒的にセキュリティが出せる自信があったわけです。ところがバイナリの状態でデリバリーされることで、受け取った側はどんなパッチがあてられているか、どんなコンパイラで作られたモノか見当がつかない。本来バイトコード以外は使っちゃいけなかったのに。いつのまにかそうじゃなくなった。これがバイトコードは遅いというだけで、使われなくなったとしたら、それはマズイんじゃないかと。でも、カルチャーとしてバイナリにコンパイルして使うという方法が通っている。これはなんか違うと思うんですよ。あくまでもJavaはバイトコードで扱ってVM上でしか動かさない。JITでコンパイルしない。バイナリにしない。これがセキュリティを守る方法だと。これがJavaの生き残る道。バイトコードで動かせれば、未来永劫どこでも動かせることを保証する。これがJavaの生き残る道で、これがなければOne of themですよ。\n■50年後の市民が文化を生み出すツールを作る苫米地氏：ちょっとSunへの批判ね。これね、2つあるんですよ。1つは21世紀になってUnixはないでしょって。これはね、SolarisがとうとかLinuxがどうとかというレベルじゃないですよ。もうひとつ上のレベル。OSという本質的な意味ね。IBMとかが「Linuxで！」なんて聞くと「え～っ！」て思うもん。「あなたたち、IBMでしょ。それはないんじゃないですか？」って。そりゃMulticsの時代にMulticsってヤバイからUnixねって、それって何10年も前の話でしょ。\n甲斐：1/4世紀前。\n苫米地氏：今21世紀ですよ、Linuxが良いSolarisが良いって言う時代じゃないですよ。今良いOSがもし必要であればOSを考え直しましょうよって思うでしょ。僕はそれでLinuxが良い、Solarisが良いっていうディスカッション自身が何か間違っていると思います。それは10年前、20年前の話しであって、今は、次世代の21世紀のOSはどうするかっていう、そんときにリアルタイム性を出すには、スレッドのプリエンプティブ性をどうしようとかいうレベルの話しじゃないでしょ。本質的に、スケジューラとはなんぞやというレベルから入って、OSそのものの話し。それをどうするかっていう話し。SunもSolarisを続けていくのは良いけれど、同時に似ても似つかない本物の次世代のOSをやっていて欲しいですね。2つめにMicrosoft、パソコンカルチャーに引きづられ過ぎというところですね。それはMicrosoftの批判じゃなくてね。ビジネスデシジョンの問題なんですけどね。SunのやっていることもそういうPCのカルチャーに引きずられているところが多いんじゃないのって。こんなことやっていたのでは21世紀暗いよって。PCというのはエンドユーザのカルチャーでありホビーのカルチャーで、JobsとWozとか尊敬するけどコンピュータサイエンテストではない。街の発明家であり街のエンジニアである。決して科学者じゃないからね。そこから出て来たものは未来はデカくなるのではなくむしろ小さくなると考えているんです。そういうところから離れて、Sunには次のOSをどうしようかと議論してほしいですね。僕の中ではSolarisも含めてUnixの時代は終わっているんですよ。単純に言うと立ち上げられるスレッドの数が少なすぎ。僕の希望としては10万スレッドくらいが立ち上がるようなOSの出現を望みますね。今のUnixとは根本的に違うOSを。そういうディスカッションをしてほしいですね。こういうことは先進的なコンピュータメーカでないとできませんからね。50年前であればIBMだったんでしょうけど、今Linuxなんて言い出す所を見ると全然期待できませんから。Javaも同じで、過去にありとあらゆる言語を見て来て30年間プログラムをやってきた僕としては、今のままのJavaではOne of themでしかないです。ニーズによって選ぶ言語。僕が今でもANSI CommonLISPを使うのはOne of themではないからですね。JavaがOne of themで無くなるには、セキュリティとポータビリティの観点からJavaはバイトコードであるべきだし、VMによって物理世界と情報世界を完全に切り離すことを絶対やるべきだと思うんですよ。そしてプログラマーに対してはPCカルチャーじゃダメなんじゃないの？ってことを言いたいですね。\n僕はおとといね、元東大の生産技術研の所長をされていた原島先生（現東京都立科学技術大学長）から「この言葉を世界中に広めよ。」と言われて来た言葉があるんですよ。それはね、「我々の仕事は科学者と技術者の集団として、あるときはサイエンテストとして、あるときはエンジニアとして、50年後の世界の市民が文化を生み出すようなツールを作ることだ。」と原島先生はおっしゃったんです。まったくそのとおりなんです。20年後じゃダメなんです。50年後じゃないといけない。我々は文化を生み出せないけど、文化を生み出すツールは作ることができる。それを今頃からコツコツと作っていかなければいけない。実際計算機が作られてから50年くらい経っているんですよ。エニアックの時代の人たちが今のMacintoshのようなものを考えていたのかどうかわからないけれど、計算機は形を整えてから50年くらいで一般の科学者でない人たちが音楽とか芸術とかを生み出すツールになっているわけです。今の私達は次を始めなければならないので、次の50年後くらいに音楽や芸術を生み出すようなツールをこれから作りはじめなきゃならないと思っています。では誰がやるのか。それは我々だし、会社で言えばSunやIBMしかないでしょう。もちろん来年の収益をあげなければいけないのは当然です。しかしそれは誰でもできることで、あまり重要な問題ではない。それよりもどこまで価値のある仕事をできるかということだと思うんです。じゅうぶんJavaはそういうメッセージを持っていると思うんですよ。\n取材 Sun Developer News 編集部\n"},{"id":61,"href":"/notes/20220127183208/","title":"💻自己分析で考えるべき3項目とは？始める前に見ないと時間の無駄 - 八木仁平","parent":"🎓Keido HOME","content":"up: 八木仁平の自己理解チャンネル\n source: 自己分析で考えるべき3項目とは？始める前に見ないと時間の無駄 - YouTube summary  自己分析の用語を整理    "},{"id":62,"href":"/notes/20220104045818/","title":"💻講義の動画を倍速で視聴しても内容はちゃんと頭に入るのか？問題 - パレオな男(2022)","parent":"🎓Keido HOME","content":" title: 講義の動画を倍速で視聴しても内容はちゃんと頭に入るのか？問題 authors: 鈴木, 佑. url: https://yuchrszk.blogspot.com/2022/01/blog-post%5F04.html summary: 2倍速くらいならノーマル速度と変わらない or 学習効率はよい. ただし2倍以上だと落ちるので速すぎると悪い.  notes     これはすごい.  1.5倍速,2倍速とノーマル速度では2倍速のほうが学習効率が高かった.    External Links     🔗Learning in double time: The effect of lecture video speed on immediate and delayed comprehension - Murphy - - Applied Cognitive Psychology - Wiley Online Library  "},{"id":63,"href":"/notes/20220311194105/","title":"📁ソフトウェア工学(Software Engineering)","parent":"🎓Keido HOME","content":"ソフトウェア工学, エンジニアリング全般.\nコンピュータサイエンスに関わるものは 計算機科学 を参照.\n 📂ソフトウェア設計 📂ソフトウェア開発 📂ソフトウェアドメイン  up: 🎓Keido HOME\n"},{"id":64,"href":"/notes/20220116193313/","title":"📁プログラミングパラダイム","parent":"🎓Keido HOME","content":"up: 📂Computer Science\nプログラミングパラダイムについて.\n具体的には CTMCP で扱うような分野のまとめ.\n 📝宣言型プログラミング(Declarative Programming) 📝命令形プログラミング 📝手続き型プログラミング 📝関数型プログラミング 📝オブジェクト指向プログラミング 📝イベント駆動プログラミング 📝フロー駆動型プログラミング 📝データ指向プログラミング 📝並行プログラミング Deterministic Dataflow Programming Multi-agent Dataflow Programmming 📝契約プログラミング(Contract Programming) 📚コンピュータプログラミングの概念・技法・モデル  References     https://github.com/tsu-nera/futurismo/tree/main/wiki/src/programming/paradiums プログラミングパラダイム - Wikipedia Classification of the principal programming paradigms 🖊プログラミングの世界観を変える衝撃！Paradigms of Computer Programmingで震えるほどの知的感動を体験した | Futurismo  "},{"id":65,"href":"/notes/20211231162342/","title":"📁勉強記録","parent":"🎓Keido HOME","content":"Articles     💻What I Worked On - Paul Graham(2022) 💻講義の動画を倍速で視聴しても内容はちゃんと頭に入るのか？問題 - パレオな男(2022) 💻How I note - AlexeyShmalko(2020) 💻GTDを噛み砕く - 吉良野すた(2020)  Books     📂Clojure Books 📚Software design for flexibility - Hanson, C., \u0026amp; Sussman, G. J.(2021) 📚実践Common Lisp - Peter Seibel(2008) 📚Land of Lisp - Conrad Barski(2013) 📚ブチ抜く力 - 与沢翼(2019) 📝ストレスフリーの仕事術 - デビッド・アレン(2006) 📝ひとつ上のGTD ストレスフリーの整理術 実践編 - デビッド・アレン(2010)  Talks     🎤【ショート動画時代】YouTubeShorts vs TikTok vs Reels…メディアの次の覇権を担うのは一体どれだ？ - 中田敦彦(2022-01-01) 🎤【Z世代】世界を激変させるニュージェネレーション！Z世代の価値観を徹底解説 - 中田敦彦(2021-12-11) 🎤A History of Clojure by Rich Hickey with Q\u0026amp;A - V. Meilas(2021-07-11) 📂八木仁平の自己理解チャンネル 💻【超絶IQ列伝】苫米地メソッド EX 「抽象度とは何か？」苫米地英人  MOOCs     💻Learning How to Learn: Powerful mental tools to help you master tough subjects(coursera)  Papers    "},{"id":66,"href":"/notes/20220112142936/","title":"📂Clojure Core Languages","parent":"🎓Keido HOME","content":"Clojureの言語仕様まとめ. clojure.coreとその他.\n 📝Clojure Syntax 📝Clojure Collections and Sequences 📝Clojure Namespaces 📝Clojure Logics 📝Clojure Flows 📝Clojure Functional Programming 📝Clojure State and Concurrency 📝Clojure Java Interop 📝Clojure Async 📝Clojure Expression Problem 📝Clojure Macros 📝Clojure Idioms 📝Clojure File I/O 📝Clojure Date/Time/Timestamp 📝Clojure Spec  up: 📂Clojure tags: 🏷Clojure\n"},{"id":67,"href":"/notes/20220211141917/","title":"📂Clojure開発","parent":"🎓Keido HOME","content":"Clojure開発のあれこれまとめ.\n 📝Clojure Product Development  📝Clojure Development Tips 📝Clojure Style Rules \u0026amp; Conventions   📝Clojure Web Development  📝Clojure API Server Development 📝Clojure API Client Development 📝Twitter App Development with Clojure   📝Clojure DX(Developer Experience)  📝Clojure REPL Driven Development 📝Clojure 開発環境 with Emacs 📝Clojure デバッグ   📝Clojure Architecture  up: 📂Clojure tags: 🏷Clojure\n"},{"id":68,"href":"/notes/20220301073957/","title":"📂Startup","parent":"🎓Keido HOME","content":"refs: 🏛Startup 🔬Startup Ideas\n 📝Startup Online Courses 🖊Steve Blank来日記念セミナー2019感想 | Futurismo 🏷Founder  "},{"id":69,"href":"/notes/20220220102258/","title":"📂ソフトウェア設計(Software Design)","parent":"🎓Keido HOME","content":" 📝デザインパターン 📝ソフトウェアアーキテクチャ概論  📝クリーンアーキテクチャ 📝Dependency Ingection 📝Declarative Domain Modeling   📝組み込みシステムパターン 📝システム制御パターン Architecture Pattern Concurrent Pattern Design Prinsiple  ref: https://github.com/tsu-nera/futurismo/tree/main/wiki/src/programming/design\nup: 📂プロダクト開発\n"},{"id":70,"href":"/notes/20220215162439/","title":"📂ソフトウェア開発","parent":"🎓Keido HOME","content":"ref: 📂プログラミング up: 📁ソフトウェア工学\n 🏷ソフトウェア開発手法 🏷Web Development 🏷個人開発 📝ソフトウェア開発環境(IDE) 📝コーディング規約概論 📝命名規約概論 📝Date/Time/Timestamp概論 🏷Emacs 📝git 📝adb 📂Twitter Development 📝DMM Development  "},{"id":71,"href":"/notes/20220220102738/","title":"📂ソフトウェア開発ドメイン","parent":"🎓Keido HOME","content":" 📝Web開発概論 📝組込みソフト開発 📝Google Cloud 📝Google APIs 📝Docker データベース  🏷RDB 🏷NoSQL 🏷Firebase   📝通信プロトコル(Communication protocol)  up: 📂Software Development\nref: https://github.com/tsu-nera/futurismo/tree/main/wiki/src/programming/domains\n"},{"id":72,"href":"/notes/20220214050656/","title":"📂プログラミング","parent":"🎓Keido HOME","content":"refs: 📂ソフトウェア開発 📂Computer Science\n 📝プログラミングエッセイまとめ 🏷Emacs 🏷プログラマ 🏷プログラミングモチベ 🏷プログラミング言語  🏷Lisp 🏷JVM   🏷プログラミング言語設計思想  ref: https://github.com/tsu-nera/futurismo/tree/main/wiki/src/programming\n"},{"id":73,"href":"/notes/20220214050517/","title":"📂プログラミング言語処理系","parent":"🎓Keido HOME","content":"refs: 📂Programming 📂Computer Science\nSICPや nand2tetrisで扱う分野をまとめる.\n 📝プログラミング: 基礎概念 📝プログラミング: 型システム 📝プログラミング: データ構造 📝プログラミング: 意味論 📝プログラミング: ポリモーフィズム 📝プログラミング: コンパイラ 📝プログラミング: 用語集  References     ハードウェアの仕組みを学ぶ！coursera で From Nand To Tetris Part1 を受けた | Futurismo SICP 手続きによる抽象の構築を読んだ | Futurismo SICP 第 2 章 データによる抽象の構築を読んだ | Futurismo  "},{"id":74,"href":"/notes/20220217172324/","title":"📂先祖代々の歴史","parent":"🎓Keido HOME","content":" 📝宇土為光 📝菊池氏族原田家  📝原田孫七郎 📝原田喜右衛門 📝薩摩藩姶良郡蒲生町   📝西郷隆盛 📝東條英機  up: 📂虚無との戦い\n"},{"id":75,"href":"/notes/20211227043825/","title":"📂八木仁平の自己理解チャンネル","parent":"🎓Keido HOME","content":"videos    💻自己分析で考えるべき3項目とは？始める前に見ないと時間の無駄 - 八木仁平    "},{"id":76,"href":"/notes/20220307090518/","title":"📂計算機科学(Computer Science)","parent":"🎓Keido HOME","content":"計算機科学, 情報科学, コンピュータサイエンス, IT(Infomation Technology).\nソフトウェアエンジニアリングに関わるものは ソフトウェア工学 を参照.\n 📂プログラミング 📂プログラミング言語処理系 📂プログラミングパラダイム  up: 🎓KEIDO HOME\n"},{"id":77,"href":"/notes/20220309205225/","title":"📂音楽","parent":"🎓Keido HOME","content":" 📝初音ミク 📝ベートーヴェン 📝許光俊 🏷作曲家 🏷クラシック音楽  "},{"id":78,"href":"/notes/20220127180618/","title":"📚Dark Horse - Todd Rose, Ogi Ogas(2021)","parent":"🎓Keido HOME","content":" title: Dark Horse - 「好きなことだけで生きる人」が成功する時代 authors: Todd Rose, Ogi Ogas date: 2021-08-20 publisher: 三笠書房 url: http://www.amazon.co.jp/dp/B09D35FS3N ISBN: B09D35FS3N summary:  予想外の方向から非常識な成功を収める人々をダークホースと名付けた. ダークホース研究プロジェクトによってそういう人たちの共通した特徴を見出し，再現性を提示. 標準化と個別化の二元論. 個性学の観点からのこれからの生き方の提示.好きを追求する.    DarkHorse自体はこっちにまとめる -\u0026gt; 📝DarkHorse\nReferences     Todd Rose  個性学の研究者. http://www.toddrose.com/   DarkHorse Project  https://lsi.gse.harvard.edu/dark-horse 本の共著者であるオギオーガスさんが牽引するハーバード大学のプロジェクト. 書籍の中で紹介された人たちのリンクがあるのはよい.   Youtube  No such thing as an average student - YouTube  Tood Roseさんの個性学についての説明動画. 企業がお金かけて真面目に制作してるのでわかりやすい. Dark Horseはt2:40から.   Todd Rose: \u0026hellip;prioritizing personal fulfillment is the most reliable path to success and happiness - YouTube  ラジオ番組. 耳からきける.   #EIE19 Highlights – Keynote: Dr. Todd Rose - YouTube  なんかの基調講演. 本の内容を知れる.      "},{"id":79,"href":"/notes/20211113235959/","title":"📚Land of Lisp - Conrad Barski(2013)","parent":"🎓Keido HOME","content":" title: Land of Lisp author: Conrad Barski date: 2013 tags  📝Common Lisp    書籍情報(External Links)     public site: http://landoflisp.com/ music video: https://www.youtube.com/watch?v=HM1Zb3xmvMc amazon: Land of Lisp | M.D. ConradBarski, Barski,Conrad, 史朗, 川合 Lisp 脳に洗脳させられる狂気の秘本! Land Of Lisp を読んだ | Futurismo  "},{"id":80,"href":"/notes/20220113152023/","title":"📚Living Clojure - Carin Meier(2015)","parent":"🎓Keido HOME","content":" title: Living clojure: an introduction and training plan for developers authors: Carin, Meier  http://gigasquidsoftware.com/ 作者ブログ   date: 2015-05-05 publisher: O\u0026rsquo;Reilly Media url: http://www.amazon.co.jp/dp/978-1-4919-0904-1 refs:  🏷Clojure 🏷Clojure Book    参照     🖊Living Clojure を読んだ | Futurismo(2016) 🔗本の紹介: Carin Meier, Living Clojure, O\u0026rsquo;Reilly, 2015. - tnoda-clojure https://twitter.com/lagenorhynque/status/1022657477706305536 https://twitter.com/lagenorhynque/status/945893209200197632 https://twitter.com/hamukazu/status/616244450432389120  "},{"id":81,"href":"/notes/20220113180325/","title":"📚Software design for flexibility - Hanson, C., \u0026 Sussman, G. J.(2021)","parent":"🎓Keido HOME","content":" title: Software design for flexibility: how to avoid programming yourself into a corner authors: Hanson, C., \u0026amp; Sussman, G. J. date: 2021-03-09 publisher: The MIT Press url: http://www.amazon.co.jp/dp/978-0-262-04549-0 refs:  Software Design for Flexibility | The MIT Press Gerald Jay Sussman on Flexible Systems, The Power of Generic Operations - YouTube   note:  偶然AmazonでみつけたがこれはまさかSICPの続編?? 表示がSICPっぽい.  サンプルコードがSchemeらしい. 2021になっても聖典の続編がでるとは，まさかの胸アツな展開.   SDfFと略すらしい.  Hanson \u0026amp; SussmanのSoftware Design for Flexibilityを読み始めた - Arantium Maestum      "},{"id":82,"href":"/notes/20220405204228/","title":"📚The Joy of Clojure - (2nd:2016)","parent":"🎓Keido HOME","content":" title: The Joy of Clojure, Second Edition authors: Michael Fogus and Chris Houser date: publisher: MANNING url: https://www.manning.com/books/the-joy-of-clojure-second-edition tags  🏷Clojure Book   note: 購入済み.  "},{"id":83,"href":"/notes/20220305080947/","title":"📚コンピュータプログラミングの概念・技法・モデル","parent":"🎓Keido HOME","content":"up: 📁Programming Paradigms\n私に大きな影響を与えた書籍.\n🖊プログラミングの世界観を変える衝撃！Paradigms of Computer Programmingで震えるほどの知的感動を体験した | Futurismo\n若き日の感動体験. わたしのストレングスファインダーの収集性にどストライクした. いまだに鈍器を部屋においてチラチラみてる.\nコンピュータプログラミングの概念・技法・モデル    コンピュータプログラミングの概念・技法・モデル.\n原題は, Concepts, Techniques, and Models of Computer Programming\nCTMCP, ガウディ本と言われることが多い.\nコンピュータプログラミングの概念・技法・モデル | Peter Van-Roy, Seif Haridi Amazon\nAmazonの中古本の値段がとんでもないことになっている\u0026hellip;. 現在37743円!!(2022).\nedX: Paradigms of Computer Programming     Paradigms of Computer Programming – Fundamentals | edX Paradigms of Computer Programming – Abstraction and Concurrency | edX  著者のPeter Van RoyさんがYoutubeで2022になった今も毎年講義動画をアップロードしている.\nhttps://www.youtube.com/user/PeterVanRoy\n板書がそもそもみえないがありがたさがSICP動画のようだな.\nプログラミングパラダイムの分類    https://docs.google.com/viewer?url=http://www.info.ucl.ac.be/people/PVR/paradigmsDIAGRAMeng108.pdf\n   Paradigms Concepts Features     Functional Programming  Functions and recursion     Hihger-order programming     Single-assigned variables   Object-Oriented Programming + cell Data Abstraction     Polimorphism     Inheritance   Deterministic Dataflow Programming + thread No race conditions     Concurrent transparency     Streams and agents   Multiagent Dataflow Programming + port Deterministic dataflow     Nondeterminism where needed   Active Object Programming + local cell Object-oriented programming     Multi-agent dataflow    "},{"id":84,"href":"/notes/20220102124443/","title":"📚ストレスフリーの仕事術 - デビッド・アレン(2006)","parent":"🎓Keido HOME","content":" authors: David Allen date: 2006 title: ストレスフリーの仕事術 - 仕事と人生をコントロールする52の法則 tags  📝GTD    highlights     p20.  あなたの能力は，あなたがリラックスできる能力に比例する.   p31.  いいアイデアに限って，それを実行しているときでないときに現れる. リラックスしているときなど. なのでそれをメモするためにいつでもメモをとれる準備をしておく必要がある.   p68.  考えるべきことについてすぐに考えないということが大事なのだ. 週に1回レビューの時間を確保してそのときに考える. するとその他の時間では考えないという贅沢が味わえる.   p107.  わたしが教えているのは，いかにして生活から不必要なストレスを取り除くか，ということ.   p111.  どんなときでも，たった一つの目の前のことに完全に集中することが，成果を上げる秘訣.    "},{"id":85,"href":"/notes/20211228135040/","title":"📚ハッカーと画家","parent":"🎓Keido HOME","content":"🏷Paul Graham\n refs  ハッカーと画家 コンピュータ時代の創造者たち | ポール グレアム | Amazon Hackers and Painters - practical-scheme.net    ハッカーと画家は ものを創る という点において共通していると述べている.\n 昼間の仕事をもち、美しい創作の時間は別の時間にもつ。 自分で書く（描く）ことによって学ぶ。ハックしながら学ぶ。 技法を模倣することで上達する。 次第に詳細化しながらものを創っていく（細部から全体へ） 偉大な作品は到達すべきゴールのさらに上をいっていなければならない 美に対する熱狂的な没頭を要求する。見えない細部にもこだわる. 他の人と共同で作品をつくる。共感能力が必要。 絵画同様に、ハッキングもクールな時代がやってくる.  "},{"id":86,"href":"/notes/20220101141021/","title":"📚ひとつ上のGTD ストレスフリーの整理術 実践編 - デビッド・アレン(2010)","parent":"🎓Keido HOME","content":" title: ひとつ上のGTD ストレスフリーの整理術 実践編――仕事というゲームと人生というビジネスに勝利する方法 authors: David Allen date: 2010 tags  📝GTD   notes  読み直してみると，心についての言及がとても多いことに気づいた. タスクという言葉をすべて気になること，もっといえばwonderに置き換えてしまうとこの本が新鮮に見える. つまりGTDで扱うのはタスクでなく気になることであり，マインドワンダリングを処理してマインドフルネスにいたるための一つの解なのだ. ACT(Acceptance \u0026amp; Commitmemt Therapy) と似ている部分もある.    highlights    p11: GTDの理論はストレスを把握して軽減するための実践的なアプローチ    p18: 変化する不安な時代において，自分の下した判断に信頼をおく方法を提示した.    p28: 優先順位はコロコロ変わる. そして押しつぶされそうになる.    p29: GTDはストレスの管理を行う    既存の自己管理手法は時間管理や情報管理を行う. しかし問題は意味のわからないものが大量に押し寄せることだ. GTDはそこから生じるストレスの管理を扱う.\np43: GTDのキーワードは水のような心(Mind Like Water).    意識をいかに柔軟かつムダなく操作するかが生産性向上に必要.\np54: GTDはあなたの心を拡張する.    心を拡張して気になることの居場所をつくる.\np68: 仕事とプライベートを区別するという発想は間違い.    心は仕事とプライベートの区別をしてない. ポイントは集中力を削ぎ落とすあらゆる要因をなくすことであり，そこには仕事もプライベートもない.\np86. あなたの注意を妨げるということにおいては，すべてが同じように平等で重要.\np69: 自己管理の2つのキーワードは状況のコントロールと将来への見通し    p91: 気になることをすべて書き出すこと，これを心のお掃除と呼んでいる.    p234: トップダウンよりもボトムアップ    日常のこまごましたことが安定しない限り，より高次元のことに向きあっていくことができない.\np251. わたしが考えるのは週に1度だけ    p258. 注意を向けるべき分野を管理するのはチェックリストがいい    "},{"id":87,"href":"/notes/20220107143739/","title":"📚ブチ抜く力 - 与沢翼(2019)","parent":"🎓Keido HOME","content":" title: ブチ抜く力 authors: 与沢翼 date: 2019-03-02 publisher: 扶桑社 url: http://www.amazon.co.jp/dp/B07PBVBB4Q  "},{"id":88,"href":"/notes/20220307081341/","title":"📚プログラミングClojure - Alex Miller, Stuart Halloway(2nd:2013/3rd:2018)","parent":"🎓Keido HOME","content":" title: プログラミングclojure authors: Stuart Halloway and  🏷Stuart Halloway Aaron Bedra 🏷Alex Miller(3rd~)   translator: 川合史朗 date: 2013-04-26 publisher: オーム社 urls:  http://www.amazon.co.jp/dp/978-4-274-06913-0 https://pragprog.com/titles/shcloj3/programming-clojure-third-edition/   refs:  🏷Clojure 🏷Clojure Book 🖊プログラミング Clojure 第2版を読んだ | Futurismo   notes:  PDFで第2版を購入済み. 英語のみ第3版は出版されているがまだ日本語訳はされてない(2022).  3th editionでAlex Millerも加わる.      "},{"id":89,"href":"/notes/20220110030705/","title":"📚実践Common Lisp - Peter Seibel(2008)","parent":"🎓Keido HOME","content":" title: 実践Common Lisp authors: Peter Seibel date: 2008-07-26 publisher: オーム社 url: http://www.amazon.co.jp/dp/978-4-274-06721-1 notes:  2016年にAmazonで購入したがメルカリで売却. また読みたくなったので2022にAmazonで中古購入.  販売停止なので今後は入手困難か? 英語ならばオンラインで読めるので最悪それで.      "},{"id":90,"href":"/notes/20211229061513/","title":"📝adb","parent":"🎓Keido HOME","content":"adb（Android Debug Bridge）はAndroid端末をデバッグする為のツール.1 Android SDK Platform-Toolsのひとつなので，インストールはSDK Platform-Toolsをインストールする.2\nPCとAndroid端末をTCP通信で接続することでPCから様々な設定や操作が可能になる.USB経由で接続する方法とWiki経由で接続する方法がある.\nadbをAndroidで利用するには，開発者向けオプションが有効になっている必要がある.3 またAndroid v10以前ではUSB経由でadbに乗り込んでportを開ける手順が必要(adb tcpip 5555).v11以上ならAndroidからの設定だけでよい.\nExternal Links      Android Debug Bridge（adb） - Android Developers公式(ja)の説明.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://developer.android.com/studio/releases/platform-tools?hl=ja\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://developer.android.com/studio/command-line/adb?hl=ja#Enabling\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   "},{"id":91,"href":"/notes/20220320181411/","title":"📝Alex Miller","parent":"🎓Keido HOME","content":" Clojureの開発メンバ Clojure Updateお知らせ係  https://clojure.org/news/news   puredanger  https://twitter.com/puredanger 純粋危険氏と読む.    🏷Clojurians\n"},{"id":92,"href":"/notes/20220228062229/","title":"📝Clean Architecture","parent":"🎓Keido HOME","content":"Robert C.Martinさんの提唱したソフトウェアアーキテクチャ.\nソフトウェアのロジックを4つのレイヤに分けて依存関係を一方向にする.\ntag: 🏷ボブおじさん\nrefs\n クリーンアーキテクチャ(The Clean Architecture翻訳) | blog.tai2.net Clean Architecture 達人に学ぶソフトウェアの構造と設計 | Robert C.Martin, 角 征典, 高木 正弘 | Amazon  訳は角さんなのか！    4つのレイヤ     Enterprise Businsess Rules  Entities. ドメイン, 関心領域, 操作対象.   Application Business Rules  Use Cases. モジュールの呼び出し制御を担当.   Interface Adapters  Controllers, Gateways, Presenters   Framworks \u0026amp; Drivers  Driver, Framework, Client\u0026hellip;etc. 外部とのやり取りを担当.    Fitnesse    https://github.com/unclebob/fitnesse/\nBobおじさんのメンテナンスするオープンソースのAcceptance Testing Framework.\n当然思想がこめられているはず. もっとも書籍出版の前の活動だが.\n 🖊受け入れテスト用フレームワーク「Fitnesse」導入手順のまとめ | Futurismo 🖊これぞテストの最終形態！FitNesseとRubySlimで実現するエンドツーエンドテスト | Futurismo  Active Recalls    Clean Architectureとはなんですか？    Robert C.Martinさんが提唱したアーキテクチャ.\nソフトウェアのロジックを4つのレイヤに分けて依存関係を一方向にする.\nEntity, Use Cases, Interface, Infrastructure(呼び方は一例, 流派がある).\n"},{"id":93,"href":"/notes/20220209102028/","title":"📝Clojure API Client Development","parent":"🎓Keido HOME","content":"主にサービスのAPIを叩くクライアントプログラムのノウハウまとめ.\nref: 📝Clojure Web Development から分離.\nup: 📂Clojure tags: 🏷Clojure refs: 📝Clojure with Twitter Development\nClojure HTTP Client    主なクライアントライブラリにhttp-kitとclj-httpがある.\n https://github.com/http-kit/http-kit https://github.com/dakrone/clj-http  httpリクエストに関してはどちらも同じことができる. 非同期発行も.\nただしポイントはwebsocketがt統合されているかどうか.\nhttp-kitは2022年現在メンテナンス状況が怪しく見えた.\nclj-http    https://github.com/dakrone/clj-http\nRing の影響を受けているため Request Mapを入力としてResponse Mapを返す.\ntips: debug 出力    {:debug true} をRequest Mapに含めると, 標準出力にRequest Mapの内容が表示される.\ntips: clj-httpにおけるjsonの扱い    ClojureでJSONを扱うライブラリである darkrone/cheshire をインストールすると, json との連携が{:as :json} でできる. この指定がされると clj-httpはrepsonse dataをcheshire でjsonにパースする.\nなお 単純に {:headers {:accept \u0026ldquo;application/json\u0026rdquo;}}を設定したいだけなら {:accept :json}を指定する.\nref: 💡Accept と Content-Typeの違い\nhowto: clj-httpのリクエストをproxy経由にするには？    Request Mapに proxy-host, prox-port, proxy-user, proxy-passを含める.\nref: clj-http: Proxies\nhowto: clj-httpで WARN log: Invalid \u0026rsquo;expires\u0026rsquo; attribute    request mapのオプションに :cookie-policy :standard を追加.\nref: Invalid \u0026rsquo;expires\u0026rsquo; attribute? - GitHub\nReferences    勉強の参考に目を通したもののブックマーク.\n ClojureでQiita APIをたたく - Qiita  https://github.com/akthrms/qiita-client-sample Qiitaを叩くだけだけど余計なものがないのでよい.   Clojure tutorial - boot, basic functions and how to do REST requests  とくにClojureのREST requestsに着目したチュートリアルWeb記事. example of clj-http https://github.com/joninvski/clojure-tutorial    "},{"id":94,"href":"/notes/20220226220442/","title":"📝Clojure API Server Development","parent":"🎓Keido HOME","content":"📝Clojure Web Development から分離.\ntag: 🏷Clojure\nClojure: Pedestal    Yet another Ring, 情報収集中\u0026hellip;まだ試してない.\n http://pedestal.io/ Clojureサービス開発ライブラリPedestal入門 - Qiita  Lisp meetup#69 - YouTube Interceptors: Into the Core of Pedestal    ref: 📝Clojure: Ring 🏷Web Server Abstruction\nClojure: Routing Librareis    🏷HTTP Routing\n compojure bidi ataraxy reitit pedestal  🔗References     Clojure Web Routing Library Recommendations [2020]​  2020時点でのオススメ.   reititはいいぞ – valeblog  Reference     🔗Clojure x ClojureScript で深める Web 開発 - Qiita  https://github.com/MokkeMeguru/clj-web-dev-ja https://github.com/MokkeMeguru/portcard-api   ミニマリストのためのClojure REST API開発入門 - Qiita ミニマリストのためのClojure REST API開発入門2 〜リファクタリング編〜 - Qiita  "},{"id":95,"href":"/notes/20220314120812/","title":"📝Clojure Architecture","parent":"🎓Keido HOME","content":"Clojureのアプリケーション設計.\nref: 📝Clean Architecture 🏷Clojure Development 🏷Software Design\n プログラミング言語とシステムデザイン  Clojureの設計指針 by t_yano. namespaceをドメインにするればいい.  データを関心領域としてそこに対する操作が関数. ドメインに操作を関数定義すればいい.     システムの複雑さはどこから来るのか – Out of the tar pitを読む - Uzabase Tech  これもby t_yano.   ref: 📝Clojure Records  Clojure Recordを積極的につかう.   REPLライフをもっと快適に  Component 単位でシステムをつくるというアイデア, なるほど🤔   Clojure x ClojureScript で深める Web 開発 Duct x Clean Architecture  フォルダ構造が参考になる.    "},{"id":96,"href":"/notes/20220118091058/","title":"📝Clojure Async","parent":"🎓Keido HOME","content":"up: 📂Clojure Core\nClojure core.asyncについて. 非同期プログラミングをうまく行う.\nhttps://github.com/clojure/core.async\nわたしの拙い記憶だと, 非同期処理をJava やPythonでうまく処理するには，同期キューを用いたproducer-consumer patternをつかうのが鉄板だが，それをcore.asyncをつかうことによってかんたんに実装できる(素晴らしい).\n一応過去記事をみると，共有メモリ方式ではなく，決定性データフローモデル??(忘れた).\n refs  🖊Java で Producer-Consumer Pattern を実装してみた | Futurismo 🖊データフロー変数 (Oz) で実現する Producer-Consumer Pattern | Futurismo    Clojure: atom/delay/future/promiseの比較    いずれも同じ関数deref/@(reader macro)で読み出せるところがややこしい.\n atom: メモリ共有  スレッド内のメモリ共有の仕組みあり状態を扱う.   delay: 遅延評価  force or deref or @ をつかって評価してはじめて計算がはじまる.   future: バックグラウンド実行  評価はバックグラウンド(i.e.別スレッド)で始まるが, その結果は参照してはじめてわかる (or まだ計算が終わってないかもということもわかる).   promise: バックグラウンド実行 + 遅延評価.  promiseはfutureに似ている. どちらもバックグラウンド実行に対する参照を返す.  futureは宣言時にプロシージャも宣言して即時実行. promiseは宣言時は参照に過ぎずdeleverで処理をあとからbindingする.   promiseは値, futureは関数値のようなイメージ.  どちらもバックグラウンド実行のためderefで結果を参照できる.        refs  clojure future vs delay - Stack Overflow terminology - How do Clojure futures and promises differ? - Stack Overflow Cuddly, Octo-Palm Tree: The Clojure Promise    Refenreces     🔗Clojure + core.async による非同期＆並列プロセスの世界 - 紙箱  Active Recalls    clojure.coreの delayとfuture違いはなんですか？    delayは遅延評価, futureは別スレッドでのバックグラウンド評価.\nClojure core.asyncのチャネルの宣言のためのメソッドはなんですか？    async/chan\nex. (def tea-channel (async/chan 10))\nClojure core.asyncのchannelに同期的に値を取り出すときのシンタックスはなんですか?    /\u0026gt;!!\nClojure core.asyncのchannelに非同期にput(or get)するときの ! の数は?    1つ.\nClojure core.asyncにおいて値がチャネルに入ってくるのをボーリングするためのブロックの記法はなんですか？    async/go-loop と recur\nex.\n(def tea-channel (async/chan 10)) (async/go-loop [] (println \u0026ldquo;hi from \u0026quot; (async/\u0026lt;! tea-channel)) (recur))\n"},{"id":97,"href":"/notes/20220116080205/","title":"📝Clojure Collections and Sequences","parent":"🎓Keido HOME","content":"refs: 📂Clojure Core\nClojureのシーケンスや高階関数を巧みに扱うことができるとモテるとか. こういうのは知っているか知らないかなのでイディオムを覚えてモテよう.\n-\u0026gt; 📝Clojure Idioms\nClojure: Collections    ClojureのCollectionはimmutableでpersistent.\n  refs  📝immutable 📝persistent イミュータブル時代の言語としてのClojure - Qiita    Clojure Collection操作    よく使うものを列挙.\n conj: コレクションの結合. 他の言語ではpush, concat, appendとか.  Clojure Sequences(clojure.core.sequence)    refs: Clojure - Clojureを学ぼう - シーケンシャルなコレクション\nシーケンス型 には4種類の重要なデータ構造がある.\n list: () vector: [] map: {} set: #{}  Clojure: into    into は第一引数のコレクションに, 第二引数のシーケンスの要素全てを, 元のコレクションにとって自然な形で追加 (conj) してくれる関数.\n(into %1 %2) は,\n(reduce conj %1 %2) つまり %1 に %2 の要素を順に conj したものと同等.\n(conj (conj %1 %2の最初の要素) %2の二番目の要素)と同等.\nClojure Map(clojure.core.map)     assoc: (key, value)の追加 dissoc: (key, value)の削除 update: (key)の指す(value)に引数で与えられた関数を適用して置き換える. merge: (key, value)の集合の追加  assocは値を更新してMapを返す, updateは値に関数を適用してMapに束縛する. この関係は, atomでのreset! とswap!の違い に似ている.\nmapは遅延シーケンスを構築するため, doall などの評価は別途必要.\nしかしdoallを一連のmap/filter/reduce中に挟むと処理速度が落ちるため必要なときのみ利用する. または逐次処理であるdoseqを検討する.\n途中で中身が必要というのはそもそもmapを命令形のfor文のノリで使っている可能性が高い.\n cf. Clojureの繰り返し: map vs doseq ref. Clojure: 遅延評価/遅延シーケンス  ClojureにおけるSequenceとCollectionの違い    ClojureではCollectionとSequenceは異なる概念.\n collection: データ構造の抽象. sequence: collectionの中でデータを順次アクセス可能(シーカブル)なもの.  SequenceはCollectionの特殊な形態であり、Collectionを表現する方法の1つ.\n実装レベルでは coll?で真が変えればcollection, seq?で真が変えればsequence.\ncollectionはIPersistentCollectionというインタフェースを実装しているもの. IPersistentCollectionは5つのメソッド（count, cons, empty, equiv, seq）からなる.\nsequenceはISeqというインタフェースを実装しているもの. ISeqは(first, next, more, cons)からなる.\n  ref: Clojureにおけるデータ構造の抽象化を理解して独自のデータ構造を実装する  Part 1: Collectionとは何か - 本当は怖いHPC Part 2: Sequenceとは何か - 本当は怖いHPC    💡Clojureデータ構造の操作関数の分類    Clojureの関数は大きく分けて２つの種類に分けられる.\n データ構造の操作の関数(conj, disj, assoc, dissoc\u0026hellip;) シーケンス操作の関数(cons, map, filter, reduce..)  データ構造を操作する関数は関数の次にデータ構造を受ける. 一方シーケンス操作は関数評価式の最後にデータ構造を受ける.\nClojure: Threading Macros にも 2種類あるのもこれが関係している.\nref: Clojure - Frequently Asked Questions\nAssociative vs Sequencialという概念の対立    T.B.D.\n🔗References     Clojureのsequence関係のユーティリティ関数のまとめ · GitHub  ✅Active Recalls    ClojureのCollectionとSequenceの違いはなんですか？    Collectionはデータ集合. SequenceはCollectionに順次アクセスの操作がついたもの.\nClojure のlist, vector, map, setのシンタックスはなんですか?    それぞれ，(), [], {}, #{}\nClojureのmapにデータを追加と削除をする関数はなんですか？    assocとdissoc\n✅ anki: assoc, update の違いはなんですか？    assoc は key に対して新しい val をマッピングしたMapを返す.\nupdate は古いvalに対して関数を適用し得た新しいvalをマッピングしたMapを返す.\n"},{"id":98,"href":"/notes/20220324181510/","title":"📝Clojure Data Science","parent":"🎓Keido HOME","content":"Clojure Data Visualization Tools    Clojure 1.10より導入された tapを活用するツールが便利.\nrefs. clojure tap - clojure.org 📝clojure.core tap\n Cognitect REBL  Site Datomic開発元でおなじみCognitectが開発している. OSSではないものの Stuart HallowayとCognitectのサポートは強そう.   Reveal  GitHub Read Eval Visualize Loop for Clojure OSSであり REBLの対抗馬. REPLのように振る舞ういVM上のペインでDataを可視化.  つまり起動するとJavaアプリとして立ち上がる.     Portal  GitHub Web技術で開発されている. つまり起動するとChrome PWAアプリとして立ち上がる. revealより後発なので機能的にはrevealが先行している. UIがrevealよりもイケイケ感がある.  (revealはEclipse感があり若干のダサさがある).      Portal Example    以下は portal でintegrantの状態を表示.\ntapについてはだいたい他も同じ.\n(require \u0026#39;[portal.api :as p]) (require \u0026#39;[integrant.repl.state :refer [system]]) (def p (p/open)) ; Open a new inspector (add-tap #\u0026#39;p/submit) ; Add portal as a tap\u0026gt; targe (tap\u0026gt; system) (p/clear) ; Clear all values (remove-tap #\u0026#39;p/submit) ; Remove portal from tap\u0026gt; targetset (p/close) ; Close the inspector when done apiの結果を叩くごとに更新するにはこう.\n;; 初期化 (def d (p/open)) ;; tapの代わりにreset!でデータを挿入. ;; するとportal UIに反映される. (reset! d (get-product {:cid \u0026#34;ssis00335\u0026#34;})) ;; Portal UIではなく REPLで表示 @d ;; swap!で値の更新. (swap! d (constantly (get-product {:cid \u0026#34;ssis00333\u0026#34;}))) Scicloj    ClojureでData Scienceをする人たちのコミュニティ.\n https://scicloj.github.io/ https://github.com/scicloj https://twitter.com/scicloj  定期的にyoutubeで勉強会動画がアップロードされているよう.\n"},{"id":99,"href":"/notes/20220313061121/","title":"📝Clojure Date/Time/Timestamp","parent":"🎓Keido HOME","content":"Clojureにおける時間の扱いについてまとめ.\nup: 📂Clojure Core Languages tag: 🏷Date/Time/Timestamp\nclojure.instant    文字列を読み取る関数がいくつか定義されている.\nhttps://clojuredocs.org/clojure.instant\n parse-timestamp: RFC3339-likeフォーマットのparse. read-instant-xxx  clj-time    https://github.com/clj-time/clj-time\nおそらくデファクトスタンダードなClojure のライブラリ.\nバックエンドのJoda Time Javaライブラリのラッパー.\nしかし注意書きとして Java8以降はJava Timeをラップしている clojure.java-time を使ったほうがいいとのこと.\nJavaではJava8よりJava Timeというパッケージが標準で使えるようになり, それ以前に使われていた Joda Timeを置き換えるようになった.\nそのためclojureの方針としてもJoda TimeではなくJava Timeをつかうのがいい.\nclojure.java-time    A Clojure wrapper for Java 8 Date-Time API.\nhttps://github.com/dm3/clojure.java-time\nJava Libraries Interop    Javaの関数を呼び出してもいい.\nSimpleDataFormatを使う例.\n(import \u0026#39;[java.text SimpleDateFormat]) (def twitter-timestamp \u0026#34;Sat Mar 12 20:34:57 +0000 2022\u0026#34;) (def twitter-format \u0026#34;EEE MMM dd HH:mm:ss Z yyyy\u0026#34;) (def locale java.util.Locale/US) (def sdf (SimpleDateFormat. twitter-format locale)) (.setTimeZone sdf (java.util.TimeZone/getTimeZone \u0026#34;Asia/Tokyo\u0026#34;)) (.parse sdf twitter-timestamp) ref: 📝Clojure Java Interop\n"},{"id":100,"href":"/notes/20220307162746/","title":"📝Clojure Expression Problem","parent":"🎓Keido HOME","content":"主にデータと操作の抽象を扱う.\nClojureでは,\n データ抽象として deftype/defrecord, 操作の抽象としてdefprotocol/multimethod  という仕組みが用意されている.\n 言語で定義されたマクロはこっち =\u0026gt; Reader Macros 汎用マクロはこっち: 📝Clojure Macros  cf. Javaではデータ抽象としてクラス, 操作の抽象としてインタフェースがある.\nrefs. 📂Clojure Core Languages 🏷Expression Problem\nマルチメソッド(multimethod)    Javaの オーバーライドをClojureで実現する方法.\n同一名称のメソッドで異なる型によって処理を分けるようなことをしようとすると Clojureでは,\n defmulti で複数の処理を分岐させるための同一名称のメソッドを定義. defmethod で異なる処理を型ごとに記述.  defmultiで与えられた引数のどれをdispatchのための分岐条件にするかを定義する. いいかえれば, 引数をばらして分岐条件を決める. defmethodで分岐条件に基づいて与えられた引数を処理する.\n;; 引数 sに対するバラし方を定義 (defmulti my-print class) ;; 引数sがstring, つまり (class s) =\u0026gt; String ;; ならば(.write *out* s)を実行. (defmethod my-print String [s] (.write *out* s)) (defmethod my-print nil [s] (.write *out* \u0026#34;nil\u0026#34;)) (my-print \u0026#34;stu\u0026#34;) キーワードに応じてデータを処理する例.\n(defmulti -\u0026gt;foo (fn [x y] x)) (defmethod -\u0026gt;foo :type-a [x y] y) (-\u0026gt;foo :type-a {})   refs.  マルチメソッド(multimethod)と階層 - clojure.org(ja) defmulti - clojure.core | ClojureDocs    💡いつマルチメソッドを使うべきか?    ref.) 📚Programming Clojure より引用.\n筆者がどんとなころでマルチメソッドが使われているか調査したときの発見.\n マルチメソッドは めったに使われない. マルチメソッドはクラスによりDispatchしていることが多い.  筆者による提案.\n 関数が1つまたは複数の型によって分岐していたら, マルチメソッドを検討する.  型とはクラスやkeywordに限らない. あなたが分岐するものと感じるもの.   判断に迷ったら関数版とマルチメソッド版を両方書いてみて読みやすい方を選ぶ.  💡考察    Clojureは動的型付け言語なので，それを静的型付け言語のJavaとやりとりをしようとしたときの特殊な手法(Typed Clojureという，また別の派生はあるようだ).\nプロトコル(Protocols)    Clojureプロトコル. Javaインタフェースの代替.\n defprotocol でプロトコルとメソッドを定義する. extend-protocol で プロトコルのメソッドの具体的な処理を記述する.  refs:\n 🏷ポリモーフィズム Clojureのprotocol実践 - 紙箱  protocolsには数個のifのみ定義すればいいという考え方, なるほど.    Clojure: Data Types    Clojure データ型. Java クラスの代替.\nprotocolで規定された抽象化の実装を作るのに使う.\nref: Clojure - Datatypes: deftype, defrecord and reify\nClojureレコード(Records)    データの抽象を扱うbetterなマップ. (ref.clojuredocs)\ndefrecord を利用することで，独自の抽象データ型を定義することができ，さらにdefprotocolで定義したメソッドを組み込むことができる.\n内部の仕組みではクラスを生成しているのでJavaのクラスのようにOOが持つ特性が利用可能になるというわけだ(cf. defstruct ではクラスを生成しないのでこの特性は利用不可).\nref: 💡考察: データと操作は分けるを深ぼる\nUsages    defrecordで定義したFooというrecordには -\u0026gt;Foo, map-\u0026gt;Foo というコンストラクタが自動生成されるためこれをもちいることでRecordを引数付きで生成できる.\n -\u0026gt;Foo は 引数からrecord生成. map-\u0026gt;FooはMapからrecord生成.   (defrecord XYZ [foo bar]) (def xyz (-\u0026gt;XYZ \u0026#34;foo\u0026#34; \u0026#34;bar\u0026#34;)) (:foo xyz) (assoc xyz :boo \u0026#34;boo\u0026#34;) :keywordでRecordのフィールドを読むことができる. .-:keywordは古い.\nassocやupdate-inを利用することでRecordを更新することができる. この場合, 新たなRecordが返される(persistent なClojureの設計). ただし, dissocによってフィールドを取り除こうとするとマップが返される.\n^Fooのように ^ をつかって型ヒントに使える(ref:Clojure:型ヒント).\nrecord名は大文字から始まることが多い(Foo, Bar). これらは慣例で言語の制約ではないが, 従うほうがいい.\nThinking in Data    Thinking in Data\nおそらく一番わかりやすかった説明動画.\n以下のことを強烈に主張.\n Everything is a Map，全てはMapである. OOPから来た人たちはすぐにクラスみたいなデータ構造を定義しようとするんだ.  Record Are Not Schemes，Recordはスキーマではない. なぜClojureのMapをつかわないんだ！ 定義するものはよく考えればだいたい不要でしょう. Recordは必要になるまで導入しない. defrecordでtypoしたらどうする？   Recordは以下の場合のみにつかう.  単なる性能のための最適化. 汎用的な動作を追加する場合のみ利用する   ポリモーフィックでない操作はいらない!  つまりせっかくClojureのMapが素晴らしいのでなぜそれをつかわないんだ？ということ.\nシンプルでどんなケースにも対応できる数個のデータ構造は, クソみたいな100個のクラスよりも力がある.\n💡Joy of Clojureからのインサイト     実装レベルでは, mapはPersistentHashMap, つまりシーケンス. 一方RecordはコンストラクタをもつJavaクラスとして定義される.このことにより, メモリ効率ではClassのほうが優れている.\n 開発のドキュメント作成においてもRecordを作成して特定の要素を属性に持たせたほうがよい？\nref. 🏷The Joy of Clojure\n💡プログラミング Clojureからのインサイト     アプリケーションドメインの情報をクラスを使ってモデル化することには欠点がある. ドメインの知識が, クラス特有のsetterやgetterからなる小さな言語の影に隠れてしまうのだ.\n情報を一般化して扱うテクニックは使いづらく, 必要以上にドメインに特化したコードをちまちまと書かざるを得なくなり, 再利用しにくいコードを量産する羽目になる. このためClojureでは, ドメイン特有の情報はなるべくマップを使ってモデリングすることを強く推奨している. コレはデータ型にも当てはまる. そこでレコードの登場だ.\n ref. 📚Programming Clojure\n🤔なぜ MapではなくRecordなのか？     全体として、レコードは情報を持つあらゆる目的でstructmapよりも優れており、そのようなstructmapはdefrecordに移行するべきだ。プログラミングのための構造にstructmapを使用する可能性は低いだろうが、そのような場合にはdeftypeがはるかに向いている。\n ref: Clojure -データ型: データ型とプロトコルには強い主張がある\n ref: clojure.core map\nrecordはmapの機能を兼ねる. 大は小を兼ねてかつデータ保持としてbetterなのがRecordという論調だな.\nしかしわたしは, Thinking in Data の動画をみて, 必要になるまではRecordは使わなくていいやと思った.\n🤔スコープを制限する目的ならばRecordではなくMapをつかう    defrecordが内部の制御でクラスを生成するのならば, オブジェクト指向の目的の一つである再利用可能な型を定義して, その型に従ってオブジェクトを量産することを前提とするはず.\nnamespace + defによる定数宣言の代替として, スコープを絞る目的でdefrecordをつかおうとしていた(C言語のenumのような定数の宣言をしようとしていた)が, これは単なる定数としてのMapデータ構造でいいだろう. それらの型を利用してオブジェクトを量産するわけではないのだから.\n🤔なぜdeftypeとdefrecordの２つがあるのか？    結論, とりあえず必要になるまではdefrecordをつかいdeftypeは使わない.\n clojure - deftype vs. defrecord - Stack Overflow Clojure にはなぜ5つもクラス定義する方法があるのか - 日曜プログラミング  deftypeは低レベルのデータ構造向けのもので, deftypeを元にdefrecordが構築されている.\ndeftypeは関数値のみを扱うため，呼び出し時のオーバヘッドを節約できる. しかしほとんどの場合 defrecordがいい.\n以下のフローチャートもわかりやすい.\n Flowchart for choosing the right Clojure type definition form - Chas Emerick  ほとんどのオブジェクト指向言語は明確に以下の２つを分類して設計される.\n プログラミングのドメインのもの アプリケーションのドメインのもの  ref: なぜdeftypeとdefrecordの両方があるのか?\n 自分の解釈だと, Clojureそのものの機能でライブラリを開発するのではなくてClojureでアプリをつくる私のような開発者はだいたいdefrecordをつかってアプリのドメインを扱うべきだということかな？\nそしてガチ開発でなくさくっとClojureを書く程度ならばmapで十分. 複雑さを回避するための抽象化は動的言語でさくっと開発するには適さない.\nActive Recalls    ClojureのプロトコルはJavaにおけるなんの代替ですか？    Java インタフェース\nClojureのプロトコルを宣言するためのシンタックスはなんですか？    defprotocol\nClojureのRecordで定義したレコードのコンストラクタと属性へのgetterのSyntaxSuggerは？    コンストラクタが -\u0026gt;, 属性は(:keyword x)\n(def foo (-\u0026gt;Foo a b)) (:hello foo) Clojureのマルチメソッドとはなんですか？また宣言で用いる2つのシンタックスはなんですか？\n:ANKI_NOTE_ID: 1642413642883\nメソッドに与えられた引数の型によってその処理内容を変化させる方法. defmulti, defmethod.\nClojureのマルチメソッドとプロトコルの違いはなんですか？    マルチメソッドは，単一のメソッドに対する複数の挙動を実装する. プロトコルは，グループ化されたメソッドに対する挙動を実装する.\nClojureのマルチメソッドやプロトコルを利用しないことによる複雑さを一般的になんといいますか？    Expression Problem.\nif文のような条件分岐を多用することでコードが複雑になる. 抽象度をあげた記述ができることが利点のLispの特性が活かせない.\n"},{"id":101,"href":"/notes/20220116083656/","title":"📝Clojure Flows","parent":"🎓Keido HOME","content":" refs:  📝Clojure Logics 📂Clojure Language Spec Clojure - Clojureを学ぼう - フロー制御    Clojure Flow Basics    Clojureのフロー制御まとめ.\n if when  true判定.   if-let  letで定義したロジック判定のシンボルをifでテストする. これは，たとえば複雑な真偽判定のロジックにシンポルを割り当てることで可読性を上げるために利用できる. when-letもある.   cond  複数のifを書くときのわかりやすい記法. 条件に当てはまらない場合の処理をelseで実施することができる.   case  condにおいて判定する値が１つしかない場合.    🔎if-let は処理の結果による分岐でつかう    if-letはマクロでありC言語の邪悪な習慣をエレガントにしたとか😕\nなにかの処理をして戻り値がnilか否かで処理を分岐するときにエレガントな書き方ができる. 具体的にはlet とifで以下なものを,\n(let [result (proc)] (if result (do-something result) (do-else))) if-letだと以下のようにかける.\n(if-let [result (proc)] ((do-something result) (do-else))) Java的には関数を処理して異常の場合は戻り値に -1とかfalseとか戻さずに例外を上げるのがベストプラクティスだけど関数型でも同じなのだろうか？そしてこの 関数の呼び出し元に分岐を判断させるのがC言語の邪悪な習慣といっているのだろうか？いずれにしろこういう戻り値にnilをつかって呼び出し元を困らせる邪悪な関数につかう.\nref. 💡例外がないと戻り値チェックでウンコード\nClojure:副作用の繰り返し(dotimes/doseq/for)    Clojure - Clojureを学ぼう - フロー制御\n dotimes  式n回評価, nilを返す.   doseq  シーケンスに対して順列に繰り返す. 遅延シーケンスは評価を強制. nilを返す. 複数のシーケンスに対しはforEachのように振る舞う.   for  リスト内包表記. ジェネレータ関数.    Clojure Exception: 例外     Javaのようにtry/catch/finallyが利用できる. throwシンタックスで例外を引数にとり連外を発生させる.  例外はJavaのクラスで作成できる(Exception. ) Clojureの記法でex-infoはmessageとmapを受取リ例外を発生させる. Clojureの記法でex-dataはex-infoで入力したmapを展開する.     (try (throw (ex-info \u0026#34;bad\u0026#34; {:a 1 :b 2})) (catch clojure.lang.ExceptionInfo e (prn \u0026#34;caught\u0026#34; e))) ref. 例外 | Exceptions\nClojureの繰り返し: map vs doseq    どちらもシーケンスに対する処理を実施する.\n副作用があるときにdoseq(for)を利用する, そうでないときにmapを利用する.\nなるべく副作用がないようにプログラミングを構築するというClojureの考えとしては doseqよりもmapのほうが登場回数が多い.\nmapは関数をすぐには適用せずに遅延シーケンスを構築する. 実際に中の値の評価をするにはdoall, intoなどの方法が必要.\n(doall (map coll)) (into [] (map coll)) (into-array (map coll))  refs.  Clojure Map(clojure.core.map)    Active Recalls    Clojureにおけるif-letとはなんですか？またその目的はなんですか？    letで定義した真偽値をifで評価する.\n複雑なロジックにシンボルを割り当てることで可読性を上げるため.\nClojureで複数のifをするときのシンタックスシュガーはなんですか？    cond, case.\nClojureで副作用がある繰り返しの３つのシンタックスなんですか？また戻り値はなんですか？    dotimes, doseq, for.\n戻り値はnil.\n"},{"id":102,"href":"/notes/20220116094551/","title":"📝Clojure Functional Programming","parent":"🎓Keido HOME","content":"いわゆる関数型プログラミングのパラダイムで登場する用語のClojure実現方法.\nClojure - Clojureを学ぼう - 関数\nref: 📂Clojure Core 🏷Functional Programming\nClojure: Function    defn で定義.\nref: 🔗Clojure - Learn Clojure - Functions 🏷Function\nClojure: Multi-arity Functions    Multi-arity functionsをサポート.\narityはアリティと発音する, 関数の取りうる個数.\n(defn messenger ([] (messenger \u0026#34;Hello world!\u0026#34;)) ([msg] (println msg))) ref: アリティ | arity\nClojure: 可変長引数関数 | Variadic Functions    可変長引数 をサポートする関数, variadic = 可変長, aka. オプション引数.\nClojureでは \u0026amp; を用いて指定する.\n(defn hello [greeting \u0026amp; who] (println greeting who)) オプション引数が関数呼び出してで指定されない場合はnilがbindされる.\nClojure: 無名関数    Clojureでは無名関数は fn で定義する. リーダマクロ #() でも表現可能.\n 🏷無名関数 🏷クロージャ\nClojure: constantly    constantlyは 引数を受け取って無名関数を返す.\nAPIなど3rd party のライブラリを使おうと思ったとき引数に関数を指定しないと使えないときに引数を渡すためのテクニック.\nClojure: compliment    関数を受取り, 関数を評価した結果の反対の真偽を返す無名関数を返す.\nnotのわかりやすい名前をつけるときに使える. (つまり defによって良い名前で束縛されることを期待).\n(def not-empty? (complement empty?)) (not-empty? []) ;;=\u0026gt; false (not-empty? [1 2]) ;;=\u0026gt; true ref: complement - ClojureDocs\nClojure: 関数適用     apply: 関数適用 partial: 部分適用. comp: 関数合成.  Clojure: apply | 関数適用    無名関数fnを引数リストargsに適用する.\n以下の２つが同じことをしている.\n (apply str [\u0026ldquo;str1\u0026rdquo; \u0026ldquo;str2\u0026rdquo; \u0026ldquo;str3\u0026rdquo;]) (str \u0026ldquo;str1\u0026rdquo; \u0026ldquo;str2\u0026rdquo; \u0026ldquo;str3\u0026rdquo;)  ref: Clojure - Clojureを学ぼう - 関数\nClojure: partial | 部分適用    Clojureではpartialの表記を利用して部分適用する.\n複数の引数を取る関数の場合, partialで適用できるのははじめの引数のみであることに注意(left-apply).\n部分適用は一部の引数を固定した無名関数を返すことにすぎないため, ２つ目移行の任意の引数を固定するには自分で無名関数を書くことが必要.\n(defn foo [x y z] (+ x y z)) ;; partialだとxしか固定できない. (def foo1 (partial foo 1)) (def foo2 (fn [x z] (foo x 2 z))) (def foo3 (fn [x y] (foo x y 3))) ref: 部分適用\nClojure: comp | 関数合成    複数の部分関数を組み合わせるのはcompをつかう.\nThreading Macros は フォームを評価した結果であり, compは評価するための関数をまとめたものである.\n(def proc-comp (comp proc1 proc2 proc3)) (def proc-next (fn [x] (proc3 (proc2 (proc1 x)))) (proc-comp x) (proc-nest x) (-\u0026gt; x (proc1) (proc2) (proc3)) Clojure: juxt    複数の関数を受け取って新しく関数を返し、その関数は受け取った引数をそれぞれの関数に適用した結果をvectorで返す.\nex.) ((juxt a b c) x) =\u0026gt; [(a x) (b x) (c x)]\nref: filter と remove のふたつの結果を簡単に受け取る方法 - Qiita\nClojureではカリー化をpartialで実現する    Clojureではカリー化をサポートしておらず, 部分適用関数partialでうまく書き直せる.\n表現を正確にするならばHaskellのようなautomatic curryingをサポートしていないので無名関数を駆使して表現を書き換えるが, partial関数をつかうとその表現方法が簡単に書けるという意.\n💡カリー化と部分適用の違い については別ページでまとめたので要確認.\nカリー化というのは表現方法に過ぎないので書き方ではpartial を使おうが使わなかろうが書ける. partialが便利, という話.\nClojure Style Guide には カリー化には無名関数よりpartialが望ましい との記載あり.\n  refs.  🏷カリー化 Currying \u0026amp; Partial Functions · Practicalli Clojure    Clojure: 分配束縛(Destructuring)    Clojureでは分配束縛をサポートしている.\n vectorの中にvectorやmapを書いて表現する.  [[][]], [{}{}]   分配束縛したくない変数はvectorなら:as, mapなら:or で表現する. :keysをつかうと，mapをうけとったらその値をシンボルにバインドできる.  JavaScriptだと分割代入ともいう.\n Clojure Destructuring Tutorial and Cheat Sheet · GitHub Clojureの分配束縛まとめ - Qiita  関数の引数で分配束縛をつかう    通常は [[][]]や[{}{}]のように書いて右から左にparseするが, 関数の引数として[[][]]を省略して[[]]とかける.\n通常のbinding.\n(defn foo [a b] (println a b)) (defn foo [a b \u0026amp; {:keys [x y]}] (println a b x y)) (foo \u0026#34;A\u0026#34; \u0026#34;B\u0026#34; :x \u0026#34;X\u0026#34; :y \u0026#34;Y\u0026#34;) ;; =\u0026gt; A B X Y 余分なものはひとつにまとめるbinding.\n(defn foo [a b \u0026amp; args] (println a b args)) (foo :a :b :x :y :z) ;; =\u0026gt; :a :b (:x :y :z) (defn foo [\u0026amp; {:as m}] (println m)) (foo :x \u0026#34;X\u0026#34; :y \u0026#34;Y\u0026#34;) ;; =\u0026gt; {:y Y, :x X} keysで必要なものだけ取りつつ残りも取るよくばりパターン.\n(defn foo [a b \u0026amp; {:keys [x y] :as m}] (println a b x y m)) (foo \u0026#34;A\u0026#34; \u0026#34;B\u0026#34; :x \u0026#34;X\u0026#34; :y \u0026#34;Y\u0026#34;) ;; =\u0026gt; A B X Y {:y Y, :x X} この記法(keyword引数にmapを指定)はClojure 1.11からのサポートなのかな？\nClojure - Keyword argument functions now also accept maps\nこの書き方はつかえそう.\n(defn some-handler [{:keys [db,,,,] :as req}] ,,) 奥が深い\u0026hellip;\nsee also: 関数の引数にデフォルト値を指定するには？\nClojure: 遅延評価/遅延シーケンス(Laziness Evaluation/Laziness Sequence)     rangeで, 遅延シーケンスの数列を作成できる. repeatで, 遅延シーケンスのシンボルの繰り返しが作成できる. repeatedlyで, 指定回数だけ無名関数を適用したシーケンスを作成できる. iterateで, 関数適用のシーケンスを作成できる. 数学の漸化式.  遅延シーケンスの実現には doall, dorunを利用する.\nref. Clojureの繰り返し: map vs doseq\nClojure: 再帰(Recursion)     Clojureではloop/recurを利用することで再帰を実装する. recurを利用すれば末尾再帰がかける.  Clojure: データ操作     mapはシーケンスに関数を適用してシーケンスを返す. filterはシーケンスの要素のそれぞれにpredicateを適用してtrueの要素のみを取り出す. reduce はシーケンスをaccuumurateして単一の戻り値を返す. forはシーケンスを順番通りに通りに取り出す.  手続き的に処理したい場合に使う. pythonのforeach, zip的な.   flattenは入れ子構造の配列を単一シーケンスに変換する.  いろいろあるが手を動かして覚えたほうがいい. 基本的な機能は他の言語でもあるのでシンタックスを覚えるのみ.\nシーケンスにはユーティリティ関数もいろいろあるのでその都度覚えよう.\nref. シーケンスの分離と合流テクニック\nclojure: filter    与えられたコレクションから条件に合うもの抜き出す.\n(filter pred coll) remove は filterの逆で条件がtrueになるものを取り除く.\n🏷filter\nActive Recalls    Clojure部分適用のシンタックスはなんですか? 部分適用の限定的な性質はなんですか？    partial.\nClojureの部分適用では第一引数のみにしか適用することができない.\n第２引数以降を固定したい場合は無名関数で代用する.\nex.) (partial grow \u0026ldquo;Alice\u0026rdquo;)\nClojureで２つの関数から新たな関数を返すためのシンタックスはなんですか? スレッディングマクロとどう違いますか？    comp\nスレッディングマクロはフォームを返すがcompは関数を返すため引数をもらわない限りそれ自体では評価できない.\nex.) (defn surprise [direction] ((comp oh-my toggle-grow) direction))\n配列やマップのデータ構造の要素をそのままbindingする方法はなんですか？    分配束縛 - destructuring\nClojureのrange, repeat, repeatedlyが共通してもつ性質はなんですか？    遅延評価 - Lazy Evaluation\nClojureにおいて再帰を実現するためのシンタックスはなんですか?    loop/recur. 末尾再帰ならrecur.\nClojureで漸化式のような遅延シーケンスを構築する関数はなんですか？    iterate\nClojureのconstantly, complementはそれぞれどんな役割ですか？    constantlyは引数を受取り無名関数を返す.\ncomplementは関数を受取りその関数の評価結果の真偽をひっくり返した無名関数を返す.\nClojure: juxtはどんな役割がありますか？    複数の関数を受け取って新しく関数を返し、その関数は受け取った引数をそれぞれの関数に適用した結果をvectorで返す.\nex.) ((juxt a b c) x) =\u0026gt; [(a x) (b x) (c x)]\n"},{"id":103,"href":"/notes/20220302101805/","title":"📝Clojure Idioms","parent":"🎓Keido HOME","content":"refs: 📂Clojure Core 🏷Clojure\nIdiomsを駆使するとモテるとか.\nClojureの主にデータ操作に関する小技を書き溜めていく.\nAnkiに突っ込むことで記憶もしていく.\nandとorを条件分岐につかう     orに当たらえれた式で真になるものが見つかったら残りを評価せずに真を返す.  ex. yogthos/config   andに当たらえれた式で偽になるものが見つからない限り残りを評価する.  ref: 📚Land of Lisp p47に書いてあった.\nネストしたCollection操作にget-in/assoc-in/update-in    get-in/assoc-in/update-in をつかう.\nhttps://clojuredocs.org/clojure.core/assoc-in\n;; assoc-in into a nested map structure (def foo {:user {:bar \u0026#34;baz\u0026#34;}}) (assoc-in foo [:user :id] \u0026#34;some-id\u0026#34;) ;;=\u0026gt; {:user {:bar \u0026#34;baz\u0026#34;, :id \u0026#34;some-id\u0026#34;}} ref: 📝Clojure Map(clojure.core.map)\n条件付きMap操作 assoc-if/update-if    もしvalueがnilでなければMapを操作したい場合は以下のようにする.\n(defn assoc-if [m key value] (if value (assoc m key value) m)) (-\u0026gt; m (cond-\u0026gt; value (assoc key value))) 関数の引数にデフォルト値を指定するには？    いわゆるデフォルト引数というものだが, 位置引数に値を設定する方法は見当たらない(見つけられてないだけかも).\n代わりにオプション引数と キーワード引数 の文法の組み合わせでできる.\n分配束縛(Destructuring) の or を活用する.\n(defn myfunc [arg \u0026amp; {:keys [opt1 opt2] :or {opt1 \u0026#34;default1\u0026#34; opt2 \u0026#34;default2\u0026#34;}}] (format \u0026#34;arg=[%s] opt1=[%s] opt2=[%s]\u0026#34; arg opt1 opt2)) (myfunc \u0026#34;argument\u0026#34; {:opt1 \u0026#34;option1\u0026#34;}) ;; =\u0026gt; \u0026#34;arg=[argument] opt1=[option1] opt2=[default2]\u0026#34;  たんに変数がnilならば値を設定するならば or でいける.\n(or input-argument \u0026#34;default\u0026#34;) みやすさで使い分けてもいい.\nselect-keys: あるMapからkeywordを指定してSubMapを作成    https://clojuredocs.org/clojure.core/select-keys\n(select-keys {:a 1 :b 2} [:a]) ;;=\u0026gt; {:a 1} 特定のkeywordsを削除してSubMapをするようなときはdissocをつかう. dissocには複数のkeywordを指定可能.\n(dissoc {:a 1 :b 2 :c 3} :c :b) ;;=\u0026gt; {:a 1} fnil: nilを 初期値で置き換えて関数適用    https://clojuredocs.org/clojure.core/fnil\nデータ操作をしようとしたときに, 引数でもらったデータ構造がnilの場合は初期値のデータ構造で置き換える.\n(update request ::acc (fnil conj []) id) これのやろうとしていることは, request mapの ::accというフィールドにあるvectorにidを追加しようとするが, :acc がrequest mapにないときは空のvectorを用意してさらにidを加える.\n条件つきifでスレッディングマクロ    identityをつかうことでスカしっぺできる.\n(identity x) はxをうけとってそれをそのまま返す.\n(let [third-step (if pred do-something identity)] (-\u0026gt;\u0026gt; some-vec some-fn third-step further-processing)) ;;; (defn get [db \u0026amp; {:keys [queries] :or {queries identity}}] (-\u0026gt; db queries get)) 平坦な(flatten)シーケンスのテクニック    平坦なとはflatten という英語でよく登場する.\nClojureの関数もある =\u0026gt; flatten - clojure.core ClojureDocs\nネストした構造やassociateveな構造をシーケンシャルに処理したいときにつかう. といいつつ自力てうまいてを思いつくのもコツが必要なので結局idiomを覚えていくのがいい. ということでここにまとめる.\nMap =\u0026gt; flatten sequence =\u0026gt; Map    apply \u0026amp; concatでflattenなシーケンスに変換. flattenを直接つかうとネストした二階層目以降も全てフラットにしてしまう.\n(apply concat {:a \u0026#34;foo\u0026#34; :b \u0026#34;bar\u0026#34;}) ;;=\u0026gt; (:a \u0026#34;foo\u0026#34; :b \u0026#34;bar\u0026#34;) Mapに戻すのは into {} (map (juxt identity f)).\nシーケンスの分離と合流テクニック    map, filter, reduceはシーケンスに対して一つの関数を適用していく. しかし時には, シーケンスに対して別々の関数をそれぞれ適用することでシーケンスを分離したい, また最終的には分離したシーケンスをそれぞれ処理したあと合流させたい.\n非同期処理だと pipeline があるが, ここではそこまでは踏み込まない.\njuxt: 複数の関数を一つのシーケンスに適用    juxtが分離のためのよい関数として使える. juxtapositionの略, 日本語訳だと並列らしい.\n複数の関数を受取り, それらの関数を一つの値に適用したvectorを返す. まさに分離のための関数だ. ((juxt a b c) x) =\u0026gt; [(a x) (b x) (c x)].\njuxt - clojure.core | ClojureDocs\n(juxt f g z.. )のみだと単なる関数なので, この関数を他と組み合わせていくテクニックも学ぶ必要がある.\nたとえばmapとidentityを使えば元の値を保持しつつ別の変化も並列で保持できる. 変換前, 変換後みたいな.\n((juxt identity name) :keyword) ;;=\u0026gt; [:keyword \u0026#34;keyword\u0026#34;] さらにjuxtで処理した結果は関数ごとのリストになるならば分配束縛によってそれぞれにリストに名前を束縛できる.\n(let [[even-numbers odd-numbers :as result] ((juxt filter remove) even? numbers)] result) もしくはmapの途中でjuxtした次のステップで無名関数の引数で分配束縛を使ったり. 便利だ!\n(-\u0026gt;\u0026gt; colls (map (juxt #(-\u0026gt;a %) #(-\u0026gt;b %))) (map (fn [[a b]] (proc a b)))) into {} (map (juxt identity f)): flattern vectorをMapに変換    2つのシーケンスというよりは, 一つのシーケンスの中にkey valueが交互に現れるようなものをmapに変換する.\njuxtをつかうとkey valueの順で分離したシーケンスが生成されるのでそれらをMapに合流させるようにつかう.\n(juxt identity name) ;; 上は以下と同じ. (fn [x] [(identity x) (name x)]) ;; よってjuxtと組み合わせればMapにできる. (into {} (map (juxt identity name) [:a :b :c :d])) ;;=\u0026gt; {:a \u0026#34;a\u0026#34; :b \u0026#34;b\u0026#34; :c \u0026#34;c\u0026#34; :d \u0026#34;d\u0026#34;} (zipmap v1 v2) =\u0026gt;m : シーケンスからMap生成    ２つのシーケンスからMapを生成する.\n(zipmap [:a :b :c :d :e] [1 2 3 4 5]) ;;=\u0026gt; {:a 1, :b 2, :c 3, :d 4, :e 5} 似たような処理で２つのvectorからvector listを生成する方法も注意.\n(map vector [:a :b :c] [:x :y :z]) ;=\u0026gt; ([:a :x] [:b :y] [:c :z]) (reduce-kv f {} m) =\u0026gt;m : Mapのkey-valueに対してそれぞれ処理して合成    Mapをシーケンスとして扱うユーティリティだが, keyに対する処理, valueに対する処理, そしてkeyとvalueを合わせた処理など, いろいろできる.\n%1=map, %2=key, %3=valがbindされる.\n;; keyとvalueを入れ替え (reduce-kv #(assoc %1 %3 %2) {} {:a 1 :b 2 :c 3}) ;;=\u0026gt; {1 :a, 2 :b, 3 :c} ;; valueを2倍の数値に修正 (reduce-kv #(assoc %1 %2 (* 2 %3)) {} {:a 1 :b 2 :c 3}) ;;=\u0026gt; {:a 2, :b 4, :c 6} Mapの要素でgroupingする    統計処理のgrouping相当は group-by で可能.\n(group-by :tweet-id tweets) Mapのキー(バリュー)に対して変換をしたい(関数をmapしたい)    reduce-kv をつかう.\nref. (reduce-kv f {} m) =\u0026gt;m\n変換のための関数は (fn [m k v]\u0026hellip; )の引数にすること.\nたとえば 値を変換したいならば (fn [m _ v] (\u0026hellip; )) で関数を作成して変換したものをmにassocする.\nReferences     イディオム集 — Clojure の日本語ガイド 1ヶ月間仕事でClojureを書いている今時点でよく使う関数・コマンドまとめ - Qiita filter と remove のふたつの結果を簡単に受け取る方法 - Qiita Clojure Destructuring Tutorial and Cheat Sheet · GitHub Clojureのsequence関係のユーティリティ関数のまとめ · GitHub 【Clojure版】リスト操作のチートシート - Qiita  "},{"id":104,"href":"/notes/20220117172324/","title":"📝Clojure Java Interop","parent":"🎓Keido HOME","content":"up: 📂Clojure Core refs: 🏷Java\nClojureとJavaのやりとりをまとめ.\nClojureからJavaを呼び出し     メソッドを呼ぶには，メソッド名の前に.を書く. クラスを生成するには，クラス名のあとに.を書く.  Clojure-Java HashMap Interop    howto: Clojure - JavaのHashmapの変換    (def java-map (java.util.HashMap. test-data)) (def clj-map (into {} java-map)) howto: Clojureのkeywordを stringにするには？    clojure.walkライブラリ使える. https://clojuredocs.org/clojure.walk\n strinify-keys: keywords to string keywordize-keys: string to keywords  Clojure-Java Class    howto: Javaのclassを生成するには?    ref: https://clojure.org/reference/compilation\nnamespaceに (:gen-class)を記述する. namespaceを持つ .classファイルが生成される.\ndefault(AOT compile?) では compileするとバラバラのファイルが生成され, .classがない.\ndrwxr-xr-x 3 tsu-nera tsu-nera 4.0K 2月 16 13:40 ClojureHelloWorld -rw-r--r-- 1 tsu-nera tsu-nera 1.4K 2月 16 13:40 \u0026#39;ClojureHelloWorld$fn__273.class\u0026#39; -rw-r--r-- 1 tsu-nera tsu-nera 1.1K 2月 16 13:40 \u0026#39;ClojureHelloWorld$fn__275$fn__276.class\u0026#39; -rw-r--r-- 1 tsu-nera tsu-nera 1.3K 2月 16 13:40 \u0026#39;ClojureHelloWorld$fn__275.class\u0026#39; -rw-r--r-- 1 tsu-nera tsu-nera 1.9K 2月 16 13:40 \u0026#39;ClojureHelloWorld$loading__6737__auto____271.class\u0026#39; -rw-r--r-- 1 tsu-nera tsu-nera 1.1K 2月 16 13:40 ClojureHelloWorld.clj -rw-r--r-- 1 tsu-nera tsu-nera 2.4K 2月 16 13:40 ClojureHelloWorld__init.class howto: JavaのスーパークラスをClojureで継承するには？    proxy マクロをつかう. これはJavaのクラスを引数にして無名のサブクラスを返すので適当な値にbindする.\nref: https://clojure.org/reference/java_interop#_implementing_interfaces_and_extending_classes\nClojure: 型ヒント(Type Hinting)    Clojure - Java Interop\nClojureは動的型付け言語だが動的型付け言語のJavaの上に構築されているため, 暗黙的な型はリフレクションによって型推論されている.\nそのため型hintを設定することで型推論の効率化をすることができ, コンパイルや実行速度の最適化をすることができるかもしれない.\nClojureでは, ^ という記号を Record/Type/Protocol/Java Classに設定して変数を宣言することで型ヒントを実現する.\n ref: [Clojure] 型を指定すると速い | Basic Werk\nClojureは型ヒントを使ってコンパイラを助けることで, パフォーマンスの重要なコード領域に対してリフレクションを避けることができる.\nClojureはローカルコンテキストにおけるJavaの基本型を使った高速な計算や算術演算をサポートする. すべてのJava基本型（int, float, long, double, boolean, char, short, byte）がサポートされている。\nActive Recalls    ClojureからJavaのメソッドの呼び出すには？    メソッド名の前に.をおいて呼び出す. (.methodName )\nClojureからJavaのクラスを生成には？    クラス名のあとに.をおいて呼び出す. (Classname. )\n"},{"id":105,"href":"/notes/20220116081924/","title":"📝Clojure Logics","parent":"🎓Keido HOME","content":"Clojureの論理制御のシンタックスまとめ.\n true? false? nil? not = not= empty? seq   up: 📂Clojure Core Languages\nシーケンスに対する述語    第一引数に条件(predicate), 末尾にCollectionを取る.\n (xxx pred coll)\n これらはfilter関数とあわせて用いられる.\n every? any? not-any? not-every?  some    someはシーケンスのいづれかの値が条件を満たすかどうかを判定する.\n(some pred coll)\n戻り値に注意!\n述語がtrueを返したら直ちにその値を返す. 全てがfalseならnilを返す.\n副作用に関わるClojureの述語(do)    いわゆるdoなんちゃら.\n do doto dorun(cf. doall)  do は複数のフォームを手続き的に評価するときに利用する. いちおうなくてもいいけどClojureは関数型パラダイムなので副作用を伴う一連の手続きはdoを書いたほうが親切.\ndoto は 第一引数に対して手続き的な操作を行うときに利用する. 主な利用シーンはDBに対してのコマンド発行.\n dorun, doall は遅延シーケンスのコンテキストで登場する. どちらも遅延評価されたものを強制的に評価して実行する. そのさい, dorunは単に評価してその結果を考慮せずにnilを返す, つまり副作用があろうが関係ない. 一方doallは遅延シーケンスを評価した結果をシーケンスにして返す.\ncf. Clojure: 遅延評価/遅延シーケンス\nActive Recalls    Clojureのempty?とseqの使い分けは?    Collectionが空かどうかはempty?でチェックする.\n一方，空でないかどうかはseqでチェックする.\nClojureのevery?とnot-any?とsomeの違いはなんですか?    every?は，全ての値がtrue.\nnot-any?は，すべてての値がfalse.\nsomeはいづれかの値がtrue.\n"},{"id":106,"href":"/notes/20220302111024/","title":"📝Clojure Macros","parent":"🎓Keido HOME","content":"Clojureマクロ.\nup: 📂Clojure Core Languages refs: 🏷Lisp 🏷LISP Macro 📝Clojure Abstruction\npredefinedなmacroはこっち =\u0026gt; Reader Macros\nClojure マクロの仕組み    2stepにわけられる.\n マクロ展開 コンパイル  Clojureはマクロに出会うと, マクロがまず展開され, その結果がプログラム中のマクロのあった位置に置き換えられる(マクロ展開時処理). その次に通常のコンパイルが動く(コンパイル時処理).\nClojure Macro Syntax     defmacro で宣言する. symbolの前にquote(\u0026rsquo;)をつけるとdefmacro内で評価されない. nilは何度評価してもnilなのでなにもつけない. macroexpand-1 をREPLで叩くとマクロ展開をテストできる.  マクロ利用の指針    マクロ利用の指針 from Programming Clojure     マクロを書くな. それがパターンをカプセル化する唯一の方法ならば, マクロを書け. 同等の関数に比べて, 呼び出し側が楽になるならばマクロを書いても構わない.   繰り返し現れる 特殊形式 (ex. if) を マクロで共通化する.\nデザインパターンとは, 多態的なインスタンス化のパターンに過ぎない. 同様にして, マクロとは共通部分を括りだす層であり, プログラミング言語そのものの記法などの, 既存の文法では括りだすことが難しいところを共通部分として切り出す.\nたとえば, unless記法がない言語では if !hogeのように!を多用する. しかし何度も何度も!が使われるならば, もはやその記法には独自の定義を与えたほうが読みやすいだろう, そういうことだ.\nref: 📚Programming Clojure\nマクロの利用シーンの分類 by Programming Clojure    だいたい6つのパターンに分類することができる.\nref: 📚Programming Clojure\nちょくちょく実例へのリンクを書き足していきたい(urlつきで).\n条件的な評価    varの定義    Javaの呼び出し    評価の遅延    評価を包む    lambdaの省略    "},{"id":107,"href":"/notes/20220211142329/","title":"📝Clojure Product Development","parent":"🎓Keido HOME","content":"up: 📂Clojure Development tags: 🏷Clojure\nClojureプロダクト開発で役立つライブラリとフレームワークまとめ.\n必要に応じてトピックごとにリファクタリングすること.\n refs:  📝Clojure Web Development =\u0026gt; Web関係はこっち 📝Clojure API Client Development =\u0026gt; Client API関係はこっち 📝Clojure Style Rules \u0026amp; Conventions =\u0026gt; コーディング規約や慣習はこっち 📝Clojure Architecture =\u0026gt; 設計周り    Clojure: Backend Framework    Clojure: Duct     https://github.com/duct-framework  https://github.com/duct-framework/core    Integrant をベースにした拡張機能を提供(作者が同じ). Webフレームワークではなくもっと汎用的なもの.\n Ductモジュール入門 はじめてのDuct - Uzabase for Engineers Document how to use duct with tools.deps - GitHub  💡 Javaからのアナロジー    小さな構成のシステムをJavaで作成するならモジュールごとにクラス分割するが, Ductはクラスに初期化データとその方法を定義するためのコンストラクタを定義するようなものか? 責務を意識したクラス設計とはドメイン分割.\nClojure: Roll    https://github.com/dimovich/roll\nbackend for Clojure.\nDuctよりもさらにシンプル, integrantがベース.\nClojure: 状態管理とシステム    いろいろあるがナウいのはIntegrantかな？\n stuartsierra/component tolitius/mount weavejester/integrant  状態管理ライブラリとは関数型パラダイム固有のものかな？ Redux的な.\nそもそもシステムとコンポーネントとは    システムはそもそもアプリケーションが長い間起動しているときに必要となる考え.\nスクリプトやユーティリティの実行では必要ないのだ. それらは処理の終了がプログラムの終了でありリソースの開放である.\nバックグラウンド実行をし続ける部分で構成されるアプリケーション, その部分が依存関係にあり初期化時に関係を構築するもの, これがシステム.\nシステム構築する部品=コンポーネントは単純化すれば, On/Offの操作によるStatefulなObjectである.\nref: Systems in Clojure\nClojure: Component    Stuart Sierra 作.\nClojure: Integrant    データ駆動設計によるアプリケーションを作成するためのマイクロフレームワーク.\nhttps://github.com/weavejester/integrant\nDependency Ingection をClojureで実現.\n設定データに対する初期化関数を定義でき, 設定データの定義から実体を生成.\nUsage     integrant  configuration map をもとに生成されるmicro-serviceの1つの単位.   configuration map  keyの定義をまずする. これは具体的な実装へと初期化される入力情報. Clojureのmapとして表現するかEDNファイルとして外部ファイルに定義する. configuration map同士は ig/ref で 参照することができる.   ig/init-key で integrant serviceの初期化におけるデータと関数を定義. ig/halt-key!でintegrant serviceのinit-keyの定義を破棄する関数を定義. ig/initにconfiguration mapを渡すことで, 依存関係に従って integrant を初期化. init/halt!で 破棄.   (defmethod ig/init-key :handler/greet [_ {:keys [name]}] (fn [_] (resp/response (str \u0026#34;Hello \u0026#34; name))))  {:keys [name]}はClojure 分配束縛の記法.  ref: 📝Destructuring   keyに ::hogeみたいな 2つのコロンをみかける. ::hogeは :(namespace)/hogeの意味.  REPLで評価するとわかる, reader syntax.    Usage: Integrant suspend/resume    https://github.com/weavejester/integrant#suspending-and-resuming\nIntegrantはinitとhalt, つまりシステムの開始と終了の機能を提供する.\nsuspend/resumeは主に 開発用 である. そして使いこなすにはatomとdelayをつかうというひと工夫を加える.\nIntegrantの考え方としてnamespaceにatomをbindingしない. その代わりに init-keyの中で atomを宣言して返り値のmapにbindingする.\nReferences     Enter Integrant: A Micro-framework for Data-Driven Architecture (James Reeves, 2017) - YouTube  作者によるプレゼンテーション動画.   Integrant入門(1) - Integrantの基本 - ayato-p はじめてのDuct - Uzabase Tech  integrantについても書かれてる.    💡考察: Integrantで状態を管理するということ(as State Management)    Clojureの世界では, 普通は状態をatomで管理する.\nIntegrantを導入することで, 各namespaceに散らばるatomで宣言された状態を systemというひとつの状態に紐づけてまとめることができる. そしてこのツリー構造で状態を管理するからこそシステムの停止や再起動が用意にできる.\n逆に言うと, Integrantを利用するということは, namespaceでatomを宣言しないということ.\n Integrant: how to store and access the running system? : Clojure\n\u0026gt; Systems in Integrant are intended to be autonomous.\n\u0026gt; Anyway, my point is that it seems to me Integrant still requires a whole app buy-in in the sense that, unlike with Mount, you have to thread all your state through a single entry-point.\nsystemはthreadで動作する再帰プロセス. しかしこれはIntegrantと言うよりも関数型プログラミングのイディオム.\n\u0026gt; Only constants should be global.\n定数のみが参照可能であり状態は隠されているという考え(debug除く).\n💡考察: Java Command Patternからのアナロジー    クラスというものを単なる抽象データ構造と捉えると, クラスには属性としての値と関数値の集合であり, オブジェクトとはそれをメモリ上に領域確保した状態.\nig/init-keyでやっていることは値とその初期化関数のpairのbindingであり, ig/init-keyで定義したpairの集合をig/initでまとめて初期化している.\nそうすると, ig/init-keyで初期化したそれぞれのオブジェクトを１つのオブジェクトに bindingして管理しているようにもみえる. 管理ということで, suspend, resume, haltはオブジェクトを Command Pattern で扱うようなものとして捉えれば納得がいく.\n(アナロジーとして類推しただけで実装を読んではない\u0026hellip;後で読む).\n💡考察: Integrant Rationale cf. Component    Clojure Component の代替を意識して, とくにComponentが依存関係をプログラム内(Clojure Source Code)で管理するが, IntegrantはEDNで管理するところがこだわりポイント.\nすなわちIntegrantはClojure MapでもEDNでもどちらでも構成定義できるが, 設計動機からいえばEDNつかえよ！ということかな？\n💡考察: Component/MountとIntegrantの決定的違いはOOP vs FP    ComponentやMountを使ったことがないので以下はリンク先からの理解.\nIntegrant: an alternative to Component and Mount : Clojure\nComponentやMountは状態をグローバルに参照することができるので, 関数の引数としてもらう必要がない.\nIntegrantは状態がライブラリの中に隠されていて自由に参照できない. そのためその状態に対する操作は関数の引数としてもらって変化した値を返すように書く. またはhandlerの定義として状態とそれに対する操作を1つにbindingする.\nWebフレームワークならたくさんのサンプルを見ながら自然とこの初期化で状態と関数を handlerとしてbindingするパターンに従えばいいものの, webとは関係なく単にintegrantを使おうとしたとき, ベストプラクティスがないので自分の流儀で実装しがち, 本質を考えよう.\n初期化時に自前でnamespaceにatomに保存しておく方法はそもそもフレームワークで状態を管理する考えに反するアンチパターン.\nIntegrantは関数型プログラミング(FP)の考えに近い. 一方Componentの考えはクラスやOOPに近い.\nとくにFPでシステムを構築すると冪等性を獲得することができ, これが開発時にとくに役に立つ(cf. Reloaded Workflow). Componentは自分が初期化済みかどうかはComponent自身しかわからない.\n ComponentとIntegrantの違い - ayato-p  https://twitter.com/athos0220/status/931003506638458882    💡IntegrantとRing Handlerの2つのパターン     refs:  IntegrantでRingハンドラーをどう扱うか - ayato-p Passing dependencies into ring handlers \u0026hellip; on request map, or `partial`ed into the handler?    2つのパターンがある.\n すべてのRingハンドラーをコンポーネントとして扱う. ルーター部分までをコンポーネントにして、Ringハンドラーはただの関数として扱う.  Component/MountとIntegrantの決定的違いはOOP vs FP の議論に似ている.\nClojure: ロギング(Logging)    Javaの資産を使うか否かが採用のポイントかな？\ntimbreはpure clojureではあるが, やはり設定例やノウハウがGoogle検索で見つかるのは, Javaライブラリが多い(logback).\nJavaのロギングライブラリは歴史がある. ログはViewerがよいとワクワクするからな.\nclojure.tools.logging    clojure tools.logging libaryでJavaの資産を活用.\n official docs  https://github.com/clojure/tools.logging https://clojure.github.io/tools.logging/      ref:  🖊Logbackのログを見やすくする方法(ファイルをgrep, Lilith) | Futurismo Quickly Set up Clojure Logging with the Right Library Clojure Log Configuration    Clojure: timbre    Pure Clojure/Script logging library.\nhttps://github.com/ptaoussanis/timbre\nslf4j-timbre をつかうとJavaのロギングライブラリと連携可能.\nなんかドキュメントがわかりにくいな\u0026hellip;\n日本の時刻設定例:\n(def timbre-config {:timestamp-opts {:pattern \u0026#34;yyyy-MM-dd HH:mm:ss,SSS\u0026#34; :locale (java.util.Locale. \u0026#34;ja_JP\u0026#34;) :tiemzone (java.util.TimeZone/getTimeZone \u0026#34;Asia/Tokyo\u0026#34;)}}) (timbre/merge-config! timbre-config) また現実的な問題点として, timbreはpure clojureではあるものの, 3rd party libraryがjavaのライブラリに依存していると, その制御をtimbreからはできない(Javaから独立していることが利点なので). そのため結局 logback.xmlを書かないといけないかもしれない.\nhttps://github.com/ptaoussanis/timbre/issues/138\n💡 tips: Jetty サーバのログを黙らせる    jetty serverを起動したりclj-httpを使うとREPLを侵食する問題.\n以下はlogback.xmlを設定する例.\n Pedestalのデバッグログがうるさいので、静かにした - ayato-p  https://twitter.com/_ayato_p/status/1115059001459335168   Basic logging in Clojure web service not appearing on console - Stack Overflow  timbre\n Noisy Netty logs show up after adopting this library · Issue #32 · fzakaria/slf4j-timbre · GitHub  References     The Clojure Toolbox  逆引きのClojure Libraryまとめページ.    "},{"id":108,"href":"/notes/20220117205249/","title":"📝Clojure REPL Driven Development","parent":"🎓Keido HOME","content":"🏷Clojure 🏷ソフトウェア開発手法\nREPL-Oriented Programmingとも. RDDと略されたりもする.\nソースコードを即時にエディタで評価してインライン表示などすることで，素早くフィードバックをえることができる.\n正確にはREPLにエディタからソースコードを評価した結果をもらったものを表示だが，操作的にはソースコードと対話するように開発ができる.\nTDDは細かくテストを書くことで素早くフィードバックを得ることで先の不安を事前に取り除き前に進むための確信を得ることが目的のひとつだった. 継続的インテグレーション，継続的デリバリーなども. それらのサイクルの単位よりもRDDは圧倒的にフィードバックが早い! もはや最小単位.\nREPLとは    REPLとは以下の略.\n read evaluate print loop  REPLの説明は以下がわかりやすかった. 少し抜粋.\nref: 🔗REPL Driven Programming - tyano\u0026rsquo;s Techlog\nREPLでnamespaceを読み込むということは簡易実行環境ではなく あなたが書いたプログラム内部に潜り込んでコンソールを開いた状態 そのもの. Clojureにインタープリタは存在しない. 関数をバイトコードにして実行するのみ.\n Road to Common Lispの中で Lisp as a System という章も，例題がCommon Lispではあるものの実体はRDD.\n Lispプロセスを起動。 プロジェクトを読み込む。 コードをエディタで編集。 動作中のプロセスに、編集したコードだけをコンパイルさせる。 プロセス中の変更したコードと対話。 REPL や HTTP request などを通して行う。 出力を調査 （コンソール、ブラウザなどで）。3に戻る。  \u0026gt; Common Lispを書くことは、生物や呼吸する組織とやりとりすること、もしくは 熱心な助手に物事を教えることのように感じることができます。\nref: 💻A Road to Common Lisp - Steve Losh(2018)\nEmacsでのClojure REPL Driven Developmentの具体的な方法     M-x cider-jack-in (REPLにEmacsから接続)  M-x cider-load-file (ファイル単位でevaluate) M-x cider-eval-last-sexp (フォーム単位でevaluate \u0026amp; インラインで結果表示) M-x cider-eval-last-sexp-to-repl(フォーム単位でREPLに送信してevaluate)    ref: 🔗Column: REPL 駆動開発を取り入れて Ring でもう少し遊んでみる — Clojure の日本語ガイド\nDesign Journal    RDDでコードを書くと，まずごにょごにょとアイデアを文で書いたりそれを小さな関数で実装して評価してみたりを繰り返しながら，つまりエディタと対話しながら小さな部品を組み立てていき，それらを組み合わせて大きな機能をつくる.\nそのごにょごにょの部分はソースコードの下のほうにコメントアウトしつつ残しておくことで，どういう設計意図があってこのコードを実装したのかの履歴を，コードとともに残しておこうという考え.\nこういうことができるのは，REPLで関数をかんたんに評価できるということもあるが，別の側面としてはClojureが関数型言語なので簡潔に副作用もなく部品としてコードを残しやすいという側面がある(と個人的には思っている).\n実際の Design Journal実施例 はこちら.\nref: REPL Driven Development - DEV Community\nDesign Journal Tisp with Clojure Cider    comment マクロをつかうとまとめてコメントアウトできる.\n式の評価結果をそのまま次の行に出力すると後で思い出すときにいちいち評価しなくてもいい.\n M-x cider-pprint-eval-defun-to-comment M-x cider-pprint-eval-last-sexp-to-comment  ただしcommentと合わせて使うと評価が動かないのでこれをつかうときはcommentを外す.\nReloaded Workflow    Stuart Sierra さんの提唱で有名になった？開発手法(2013).\nref: 🔗Clojure Workflow Reloaded\nClojureの起動, 特にJVMの初回立ち上げが重くて気軽に再起動できないからこそ生まれた工夫.\nアプリをシングルトンなJVMとして起動するのではなくてインスタンスとして起動することで古いインスタンスは捨ててしまう(i.e.ガーベージコレクションかな?).\nとくにresetを連発してライトにシステム再起動, CIDERで M-x cider-ns-refreshの前後にsuspendとresumeをhookさせるとよいとか.\n.dir-locals.に記載.\n((clojure-mode . ((cider-ns-refresh-before-fn . \u0026#34;integrant.repl/suspend\u0026#34;) (cider-ns-refresh-after-fn . \u0026#34;integrant.repl/resume\u0026#34;)))) 💡考察: reloaded workflowはdocker-composeに似ている    コレはたしかによいね, REPLの再起動が結構ストレスだったので. reset 連発するぞ.\ndocker-composeに発想は似ているな. dockerごとにサービスを定義してdocker-composeで依存関係を制御しつつ立ち上げるところ. docker-composeの再起動ってどのくらいの速さだっけ？\nしかしreplのみで再起動のほうが速そうではある. システムテストならdockerまるごと再起動が必要もしれないが少なくもと開発なら気軽にEmacsから再起動したい.\nSee also     https://github.com/weavejester/integrant-repl  integrantにおいて reloaded workflowを実践.   Clojureで快適なREPL駆動開発のために\u0026quot;reloaded workflow\u0026quot;を実践しよう - Qiita  https://github.com/lagenorhynque/reloaded-workflow-examples   ミニマリストのためのClojure REST API開発入門2 〜リファクタリング編〜 - Qiita  integrant-repl deps.edn設定例があった.    clojure.repl    ClojureのREPLでの便利ツールライブラリ.\nclojure.repl - Clojure v1.10.3 API documentation\nREPLでrequireでライブラリを一切合切ロードしてつかう.\n(require \u0026#39;[clojure.repl :refer :all])  doc: 関数のドキュメントを表示.  cider-doc/cider-clojuredocs/cider-javadocだとEmacs経由で参照できる.   source: 関数のソースを表示.  Clojure RDD Tips    tips: 便利ツールをいろいろ導入    REPLを起動するとuser.cljが自動的に読み込まれる. 例えばpathに dev/srcを設定してその中に user.cljをおいておくと読み込まれる.\nそのuser.cljにREPLで利用する便利関数をいろいろ詰め込んでおくと, 自分専用の開発ToolBoxの完成.\nhowto: namespaceの定義を消したい    clojure.coreには, ns-unmap がありこれでnamespaceからsymbolを消すことができる.\nciderだと cider-undefをつかうとbetter.\n参考リンク     ClojureでREPL駆動開発を始めよう - Qiita REPL Driven Programming - tyano\u0026rsquo;s Techlog REPL driven development · Practicalli Clojure An Architect\u0026rsquo;s View: Talks: Clojure\u0026rsquo;s Superpower  Clojure-Provo December Meeting - REPL-Driven Development – Clojure\u0026rsquo;s Superpower - YouTube REPL Driven Development, Clojure\u0026rsquo;s Superpower - Sean Corfield - YouTube     see also: 🖊REPL 駆動開発について（REPL Driven Development) 調べたメモ | Futurismo\nActive Recalls    REPLとは何の略ですか?    read, evaluate, print, loop\nREPL Driven Developmentとはなんですか？    REPLを使って対話的に開発を行う手法.\nエディタにコードを書いて，REPLに送信して評価して即座にアウトプットのフィードバックを得ることにで，次に何をするかを考えることができる.\n"},{"id":109,"href":"/notes/20220323030746/","title":"📝Clojure spec","parent":"🎓Keido HOME","content":"up: 📂Clojure Core Languages\nclojure.specとは    Clojureにおいて 契約プログラミング を実施するためのライブラリ.\nClojure 1.9から導入された. これは 2017.12 の話なので古い書籍だとそもそもclojure.specの話題を扱っていない.\nclojure.spec Usages    Basics     s/def  満たすべき条件を宣言   s/valid?  条件を検証   s/coll-of  条件を満たす集合を宣言   s/keys  条件を満たす名前付きの値の集合(ie. Map)の条件を定義 :reqは必須のキーワード, :optは任意のキーワード.   s/explain  検証が失敗した理由を出力.   s/conform  条件を満たす場合のみ与えられた値を検証を通過したキーワードに束縛.   s/cat  束縛されるキーワードとその条件をまとめるという宣言.     以下の記事を参考.\nWhat Clojure spec is and what you can do with it - Pixelated Noise Blog\n(require \u0026#39;[clojure.spec.alpha :as s]) ;; basic ;; s/defで満たすべき条件を宣言 ;; s/valid? で検証 (s/def ::username string?) (s/valid? ::username \u0026#34;foo\u0026#34;) (s/valid? #(\u0026gt; % 5) 10) ;; collections ;; s/coll-ofで条件を満たす集合を宣言 (s/def ::usernames (s/coll-of ::username)) (s/valid? ::usernames [\u0026#34;foo\u0026#34; \u0026#34;bar\u0026#34; \u0026#34;baz\u0026#34;]) ;; Maps ;; s/keysで条件を満たす名前付きの値の集合(ie. Map)の条件を定義 ;; :reqは必須のキーワード, :optは任意のキーワード. (s/def ::password string?) (s/def ::last-login number?) (s/def ::comment string?) (s/def ::user (s/keys :req [::username ::password] :opt [::comment ::last-login])) (s/valid? ::user {::username \u0026#34;rich\u0026#34; ::password \u0026#34;zegure\u0026#34; ::comment \u0026#34;this is a user\u0026#34; ::last-login 11000}) ;; Explain ;; s/explainで検証が失敗した理由を出力. (s/explain ::user {::username \u0026#34;rich\u0026#34; ::comment \u0026#34;this is a user\u0026#34;}) s/def: ルールを定義する    s/defで指定するkeywordは ::hogeか :foo/barである必要がある.\n k must be namespaced keyword or resolvable symbol (c/and (ident? k) (namespace k))\n 言い換えると :fooのようなnamespaceから始まるslashを伴わない場合はエラーする.\nclojure.spec conform    いわば正規表現のような, 分配束縛のような機能を提供する.\nClojure specの強力な機能のひとつ.\n s/conform  条件を満たす場合のみ与えられた値を検証を通過したキーワードに束縛.   s/cat  束縛されるキーワードとその条件をまとめるという宣言.     (s/def ::ingredient (s/cat :quantity number? :unit keyword?)) (s/conform ::ingredient [2 :teaspoon]) ;; =\u0026gt; {:quantity 2, :unit :teaspoon} s/defからMapのルールを構築する    s/defで定義したルールを組み合わせてMapやRecordのルールを構築することができる. 結局Clojureの世界ではassociated dataの受け渡しであらゆることを処理していく世界観なのでMapのチェックは大事.\ns/def と s/keys :req-un/:opt-un をつかって構築する.\n(s/def ::person (s/keys :req-un [::first-name ::last-name] :opt-un [:email])) s/conform を利用してチェックと生成を行う.\n;; Map (s/conform ::person {:first-name \u0026#34;Foo\u0026#34; :last-name \u0026#34;bar\u0026#34;}) ;; Record (s/conform ::person (map-\u0026gt;Person {:first-name \u0026#34;Foo\u0026#34; :last-name \u0026#34;bar\u0026#34;})) qualified keywords vs unqualified keywords    なおここで qualified keywordsとunqualified keywordsという概念が登場する. qualified keywordsはnamespaceに属するキーワーで :foo/barのような表記. unqualified keywordsは :fooの表記.\ns/keys で構築するとき :req/:req-unを選択できるが:reqならqualified keywordを指定する必要がある. たとえばintegrantはqualified keywordをつかって構成を定義している.\nしかし大抵はmapといえばunqualifiedなので :req-unでいいだろう.\nclojure.spec: s/fdef    関数というものが[:defn :name :doc :args :body]の5つのキーに束縛されたコードの集合とみなせばそれらに対する検証をすることで関数が検証できる, という考え方.\n(s/def ::function (s/cat :defn #{\u0026#39;defn} :name symbol? :doc (s/? string?) :args vector? :body (s/+ list?))) あるnamespace foo で s/def で ::foo-x と定義したものを別のnamespaceから使う場合は ::foo/foo-x となる.\n(ns foo.core (:requre [clojure.spec.alpha :as s])) (s/def ::foo-x pos?) (ns bar.core (:requre [clojure.spec.alpha :as s] [foo.core :as foo])) (s/valid? ::foo/foo-x 1) clojure.spec Instrument    clojure.spec.test.alpha/instrumentという関数を実行するとその後にspecを定義してある関数を実行するたびにspec通りの引数や戻り値になっているかをチェックしてくれる.\nref: Instrument - spec Guide\nclojure.specによる防衛的プログラミング    ref: 📝Clojure Architecture\n 防衛的プログラミング(Secure Programming) コントラクトシステム(Contract System)  簡単に引数チェックをするらば, ClojureのSpecial Formの(:pre, :post)の利用もできる.\nref. Clojure - Special Forms\n(defn constrained-sqr [x] {:pre [(pos? x)] :post [(\u0026gt; % 16), (\u0026lt; % 225)]} (* x x)) もしくはpredicatesの部分だけclojure.specをつかう.\n(s/def ::x pos?) (defn constrained-sqr2 [x] {:pre [(s/valid? ::x x)]} (* x x)) s/assert で中身をチェックした結果をletでbindしてもいい. このとき s/conform を利用すると例外が上がらずに :clojure.spec.alpha.invalid がbindingされて処理が継続するので注意.\n詳しくはこちら -\u0026gt; Using spec for validateion - clojure.org\nclojure.orgにもあるように気軽な引数チェックならpreでもいいが, ガチりたい場合はsdefを導入すること.\n💡clojure.specは Schemaではない    Eric Normand さんの以下の記事より.\n5 Differences between clojure.spec and Schema\nclojure.spceもSchemaも同じ課題を解決しようとした点で似ている. しかし両者は本質的に別のものである.\n clojure.specは \u0026ldquo;Data DSL\u0026quot;ではない. clojure.specは namespaced keywrodsを好む. clojure.specは強力なシーケンス検証機能がある. clojure.specは検証(checking)とパース(parsing)を兼ね備える(conform). clojure.specはtest.checkとの強い連携がある.  clojure.specと型ヒントとの比較    ref: 📝Clojure: 型ヒント(Type Hinting)\nReferences     GitHub - clojure/spec.alpha Clojure - spec Guide  公式Reference   Clojure - clojure.spec - 論理的根拠と概要 Everyday Life with clojure.spec clojure.specを開発やテストで活用する - ayato-p Clojureで堅牢なコードを書く ｜hden｜note  "},{"id":110,"href":"/notes/20220116191927/","title":"📝Clojure State and Concurrency","parent":"🎓Keido HOME","content":"Clojureの並行プログラミングについて.\nup: 📂Clojure Core ref: 🏷Concurrent Programming\nClojure: 状態(State)    状態とは，ある時系列におけるある時点での 同一実体 である.\nClojureにおいて値は immutable であり persistent である.\nしかし，変更不可なオブジェクトに対して変更可能な参照を作成することで変更不可のものを管理することができる.\nClojureでは，値と同一実体を明確に区別して扱う. 4つの参照型を用意している.\n ref: 協調的，同期的な変更を管理. atom: 独立的, 同期的な変更を管理. agent: 非同期な変更を管理. var: スレッドローカルな変更を管理.  Clojure: atom WIKI    Clojureにおける atom は非協調的(Independent)で同期的(Syncronous)な変更を管理する.\natomの更新ではトランザクションは不要. reset! 関数を用いる.\nswap! 関数は，atomを引数にとり更新した値を返す関数を適用するための関数.\n;; atomの宣言 (def foo (atom 0)) ;; atomがbindされた. foo ;; 参照先の値をリーダマクロ@で読む @foo ;; 値の更新 (reset! foo 2) ;; 関数値の設定 (swap! foo (fn [_] (+ 1 1))) atomでのreset! とswap!の違い    使い分けは単なる変数をセットするだけか, 今の情報を操作をしてupdateするか.\n reset!は今の値に関わらず値をセットする. swap!は今に関数を適用する.  とはいえ, reset!とswap!は互換性がある.\nClojure Style Guide には, Prefer swap! over reset! というルールもある. とりあえず迷ったらswap!でよい.\nClojure: ref    Clojureにおける ref は協調的(Corrdinate)で同期的(Syncronous)な変更を管理する. つまり，複数の参照を同時に更新する.\nSoftware transactinal memory(STM) をClojureで実現するためのシンタックス.\nrefで宣言した値を読むには deref をつかう. リーダマクロである @ をつかって略記する.\n参照先のオブジェクトを変更するには, ref-set or alter をつかう.\ncommute をつかうと，alterに順序保証ができる.\nClojure: agent    Clojureにおける agent は非協調的(Independent)で非同期的(Asyncronous)な変更を管理する.\nリーダーマクロ @ を利用して値を読む.\nsend メソッドを利用することで，値を更新する. 正確には, send メソッドの引数で agentを更新するための関数値を与えると，Clojureはその処理をスレッドプールでの処理エンキューしてあとはClojureがよろしく実行してくれる.\nsend-off を利用すると, スレッドプールが必要に応じて動的に拡張されるので，わかりやすく言えばすぐに実行される.ファイル書き込みなどのようなBlocking I/O, １つの処理によってスレッドが止まってしまう場合に自動で別のスレッドが作られて実行される.\nスレッドプールのスレッドをつかってClojureが暇なときに実行するため, いつagentの値が更新されたかわからない. 待ち合わせには await を利用する.\nagentの値の更新化失敗すると，それ以後のagentの更新はできなくなる. フタをしてしまうようなもの. agent-errors に失敗内容が入っている. また， set-error-mode! メソッドで :continue を指定すると続行することもできる.\nClojure: deref    as known as @ reader macro\n状態の読み出しに利用できるリーダマクロだが, 何でも読める. atomだろうとrefだろうとagentだろう, futureもpromiseも.\nhttps://clojuredocs.org/clojure.core/deref\nClojure Threading Macros だと derefを使うのかな？ best practiceがわからない.\nActive Recalls    Clojureにおいて状態を示す変数を宣言するための4つのシンタックスは？    atom, ref, agent, var\nClojureのatomとrefの違いはなんですか？    複数のrefの更新にはトランザクションを使って協調させる必要があるが，atomは単一の値を独立に更新することができる.\nClojureのatomとrefを更新するための関数はそれぞれなんですか？また参照ためのリーダーマクロは？    atomはreset!, refは alter. @で値が読める.\nClojureのdefとatomの違いはなんですか?    defは値を定義するためのシンタックスであり，値は不変であり永続的である.\natomは同一実体であり，参照先の値が入れ替わっても参照元のシンボルは不変である.\nClojureにおけるSTMを実現するシンタックスはなんですか？またトランザクションを示すシンタックスは?    refでSTMを宣言し，dosyncマクロでトランザクションを張る.\nClojureのagentの２つの特徴はなんですか？    非協調的(Independent)であり非同期(Asyncronous).\nClojureのsendとsend-offの違いはなんですか？    どちらもagentの値を更新するためのものだが，send-offはファイル書き込みなどの１つの処理によってスレッドが止まってしまう場合に自動で別のスレッドが作られて実行される.\n"},{"id":111,"href":"/notes/20220116162321/","title":"📝Clojure Syntax","parent":"🎓Keido HOME","content":" up: 📂Clojure Core refs:\n Clojure.org - syntax  Clojure: フォーム    Clojureの構成要素にいろいろ種類がある. Clojureではとくに フォーム という.\nいったん整理したい.\n number  1   symbol  Clojureの世界での表現されるものはシンボルといってもいい. 関数: foo, bar Javaクラス 名前空間 : user/foo 演算子: +, - etc\u0026hellip;   string  \u0026ldquo;hoge\u0026rdquo;   keyword  :hoge   character  \\h   boolean  true/false/nil   list  (1 2 3)    Clojure: リーダマクロ | Reader Macros    cf. 📝Clojure Macros\nClojure: 特殊形式 | Special Forms    Clojureの特殊形式は, Clojureの評価戦略に従わず, コンパイラが直接解釈するSyntax.\nつまり開発者がマクロで改変できないし, 逆にいれば, これらはマクロの素材になる.\nrefs: clojure.org - Special Forms 🏷Evaluation Strategy\nClojure: Threading Macros     スレッディングマクロ. 基本的には -\u0026gt; と -\u0026gt;\u0026gt; をつかう. 入れ子構造の関数呼び出しを逐次処理な呼び出しに変える.  refs:\n clojure.org - Threading Macros Guide スレッドマクロを整理する - 紙箱  thread-first (-\u0026gt;) と thread-last (-\u0026gt;\u0026gt;)    -\u0026gt; も -\u0026gt;\u0026gt;も1つ目のフォームを初期値にして2つ目のフォームから逐次適用していく.\n-\u0026gt;はフォームの第一引数に引数が入る. 一方, -\u0026gt;\u0026gt;は最終引数に引数が入る.\n-\u0026gt;\u0026gt; 利用するケースは第一引数に高階関数を受取り末尾にリストを受け取るような関数である.(map, filter, reduce\u0026hellip;)\nsee also: 💡Clojureデータ構造の操作関数の分類\ntips: as-\u0026gt; clojure thread-firstとthead-lastを混在させる    thread-as or as-\u0026gt;をつかうことで, 混在させられる.\n(-\u0026gt; [10 11] (conj 12) (as-\u0026gt; xs (map - xs [3 2 1])) (reverse)) ; (11 9 7) tips: cond-\u0026gt; 条件つきスレッドマクロ    cond-\u0026gt;は初期値と(条件, 処理)のリストを受ける. 条件が真のときのみ処理はされる.\n(cond-\u0026gt; (初期値) (条件) (処理) (条件) (処理) (条件) (処理)) Emacs clojure-mode: M-x clojure-thread    Emacs clojure-modeの threadingリファクタリングサポート.\nref: https://github.com/clojure-emacs/clojure-mode/#refactoring-support\n clojure-unwind/clojure-unwind-all:  threading expressionを解く.   clojure-thread-first-all: -\u0026gt; へ変換. clojure-thread-last-all: -\u0026gt;\u0026gt; へ変換.  threading macrosを理解するには, -\u0026gt;\u0026gt; の内側で M-x clojure-unwind-allを叩くとスレッディングマクロを使わない場合に変換される. もとに戻すには, M-x clojure-thread-last-all.\n💡memo: Clojure Threading MacrosはR-langのdplyrのpipe記法に似ている    これは 羽鳥教のdplyrに似てないか？\nref:\n 羽鳥教のすゝめ ～dplyr編～ | kitayama lab 羽鳥教入信のすゝめ - Qiita  そしてこの記法の強力な魅力がデータ分析においてR言語をPythonよりも好む人がいるように, Clojureにおいても大変魅力的に違いない.\n💡memo: threadingとはわたしである    theading = 糸, 筋道. これはつまり, わたしではないか？\nref: 🎓経道とはThreadである\nClojure: MetaData    ClojureのSymbolやCollectionには, MetaDataと呼ばれるデータをmapとして付与して参照することができる.\nMetaDataの リーダマクロは ^ みたいなhat表記.\nsetterとしては, (def ^{:hoge 1} x) のように, defを利用する.\nさらに, (def ^:huga y) のように書かれることも多いが, これは (def ^{:huga true} y)と同じ意味. mapの表記が省略されて keywordのみが現れている.\nMetaDataの一覧を表示するときは, meta マクロを利用する.\nuser\u0026gt; (meta #\u0026#39;x) ;; =\u0026gt; {:line 12, :column 7, :file \u0026#34;*cider-repl repo/kotori-clj:localhost:38291(clj)*\u0026#34;, :name x, :ns #namespace[user]} refs:\n clojure.org - Metadata clojure.org - The Reader - Metadata(^)  Active Recalls    Clojure の グローバル変数への束縛とローカル変数の束縛をするシンタックスはそれぞれなんですか?    それぞれ，def, let.\nClojure Threading Macrosにおいて -\u0026gt;と-\u0026gt;\u0026gt;の違いはなんですか?    -\u0026gt;は第一引数に引数が入る，-\u0026gt;\u0026gt;は最終位置似引数がはいる.\nClojureの特殊形式とはなんですか？また具体例はなんですか？    Clojureのコンパイラが独自に解釈するルール.\nSpetial Formsともいう. def, if, let, fnなど.\nClojureのMetaDataのリーダマクロはなんですか？    ^\n"},{"id":112,"href":"/notes/20220331203002/","title":"📝Clojure Transducer","parent":"🎓Keido HOME","content":"up: 📂Clojure Core\nTransducerとは    Clojure 1.7より追加されたライブラリ.\n reduce(高階関数) の概念を拡張. 合成可能なアルゴリズム変換.  関数合成(comp)により組み合わせ可能 (transducer + transducer =\u0026gt; transducer). composableな ストラテジパターン.   入力源や出力先によらず各要素を変換.  reducing functionとtransducerの定義    まずは用語の定義, 大事なので注意.\nreducing function とはaccumulateされた結果と新しいinputを合わせて新しいaccumulateを生成する関数. (accumulateがなんと訳すのかわからないけど, いわゆるreduce関数だ).\n;; reducing function signature whatever, input -\u0026gt; whatever  transducer とはあるreducing functionを別のreducing functionに変換する.\n;; transducer signature (whatever, input -\u0026gt; whatever) -\u0026gt; (whatever, input -\u0026gt; whatever) Transducerとスレッディングマクロ(-\u0026gt;\u0026gt;)との関係    Transducerとはmapやfilterのcollectionを省いて変換処理だけ抜き出してまとめたもの.\n(-\u0026gt;\u0026gt; coll (map proc1) (filter proc2) (map proc3) (map proc4)) スレッディングマクロで表現されるような４つの処理をたとえば２つをまとめて操作として抽象したり, さらにその関数値を引数にすれば部分的に交換な部品ができたりする.\n🔗References     Understanding Transducers - Elben Shira ClojureScript Unraveled (2nd edition) Reducers, Transducers, and core.async in Clojure - DZone Java Reducers A Library and Model for Collection Proc - Rich Hickey - YouTube  先生のreduceについての詳細解説.    あんまり日本語情報ないな\u0026hellip;\n トランスデューサー(transducer) - clojure.doc 入門Transducers  JavaScriptを用いたtransduceの概念の説明.\n map, reduce もいいけど transduce もね - Qiita 衝撃レポート！！map, reduce の本質にせまる！ - Qiita  "},{"id":113,"href":"/notes/20220118092453/","title":"📝Clojure Web Development","parent":"🎓Keido HOME","content":"ClojureによるWeb開発ノウハウまとめ.\ntags: 🏷Clojure 🏷Web Development\nテーマが大きいので分割するかも.\n API Server はこちら: 📝Clojure API Server Development API Client はこちら: 📝Clojure API Client Development  Clojure Web Development概論    ClojureではRailsやDjangoのようなデファクトスタンダードな Webフレームワークをつかうよりも 小さなライブラリを組み合わせて開発することが多い.\nそのため機能ごとにいろんなライブラリが存在する.\nClojure: Web Frameworks     Luminus Duct (正確には状態管理ライブラリ + モジュール作成テンプレート).  ref: 🏷Web Framework\nClojure: Ring - Webサーバ抽象    https://github.com/ring-clojure/ring\nClojureにおけるWeb Server Abstructionのデファクトスタンダード.\n Why Use Ring? · ring-clojure/ring Wiki · GitHub  なぜRingをつかうのか？  WebアプリをClojureの関数とMapデータのみで構築するという設計概念を示す. Java servletの上で走るアプリにコンパイルする.     4つのコンポーネントからなる(ref).  Handler  Clojureの関数で表現される. Request Mapを受取り, Response Mapを返す.   Request Response Middleware    ref: 🏷Web Server Abstruction 📝Clojure: Pedestal\nring: middleware    お役立ちmiddlewareをまとめていく.\n ring  wrap-params(ring.middleware.params)  ringはデフォルトではrequestに付随するパラメータに対してなにもしない. wrap-paramsを利用すると パラメータを処理してくれる.  (通常getからの) urlについたquery-paramsを :query-paramsにbind. (通常postからの) bodyの中のform-paramsを :form-paramsにbind. :query-paramsと :form-paramsのデータを :paramsにマージ. そのため大抵は :paramsをチェックすればデータが入っている.     wrap-keyword-params(ring.middleware.keyword-params)  ring は request-mapのkeyをdefaultではstringとして扱う.これをkeywordに変換する. wrap-json-paramsの:json-paramsは ring parameter mapである :paramsにマージされる. しかしring paramsは mapのkeyがkeywordではなくstringとして扱うため wrap-keyword-params との併用が必要.     ring-json(ring.middleware.json)  wrap-json-response  response-mapのbodyのColojure MapやVectorをplain/textのJSONに変換.   wrap-json-body  request-mapのbodyのjson形式の文字列をclojure collectionに変換して :bodyにbinding.   wrap-json-params  request-mapの bodyの json形式の文字列を Mapに変換して(:bodyではなく) :json-paramsにbinding.      tips: run-jettyにhandlerのvarを渡してhot reloading    varは リーダマクロ #\u0026rsquo; にて取得できる. すなわち,\n(run-jetty #\u0026#39;handler {:port 3000}) 詳しくは以下を参照.\n Column: REPL 駆動開発を取り入れて Ring でもう少し遊んでみる — Clojure の日本語ガイド 何故、RingハンドラーにVarを渡すと、ハンドラーを書き換えても書き換えたハンドラーが呼び出されるのか - ayato-p  varというのが参照型のため実際を差し替えられる.\n refs  Clojure: clojure.lang.Var 💡 def macro / alter-var-rootによるvarの再定義 Reloaded Workflow    References     clojure-ring - 開発者ドキュメント Part2: Ring について知る — Clojure の日本語ガイド  あやとぴさんのWeb 開発チュートリアル.   ClojureのWeb開発でもっとも重要なRing Handlerについて理解する - TOYOKUMO Clojure Ring Middleware大全 - TOYOKUMO Tech Blog  トヨクモの新卒やアルバイト学生のための教育用Ring解説記事.    Active Recalls    Clojure RingのようなWebアプリを構築するための仕組みを一般的になんといいますか？    Webサーバ抽象, Web Server Abstruction.\nWeb Serverと Web アプリがやり取りをするための仕様.\nClojure Ring における4つのコンポーネントはなんですか？    ハンドラー, ミドルウェア, リクエストマップ, レスポンスマップ.\nHeroku with Clojure     https://devcenter.heroku.com/articles/deploying-clojure  ja: https://devcenter.heroku.com/ja/articles/deploying-clojure   https://devcenter.heroku.com/articles/getting-started-with-clojure  ja: https://devcenter.heroku.com/ja/articles/getting-started-with-clojure   https://devcenter.heroku.com/articles/clojure-support  ja: https://devcenter.heroku.com/ja/articles/clojure-support    leiningenの作者がHerokuで働いてたらしくドキュメントがていねいとか.\nhttps://twitter.com/as_chapa/status/1198104444711256064 https://twitter.com/iku000888/status/1099293410693808128\ntip: Heroku上のappにreplで接続    heroku run lein replでHerokuサーバ上でreplを起動できる.\n\u0026gt; heroku run lein repl\nhowto: Heroku Deployでlein deps失敗の対処方法    \u0026gt; Leiningen 1.7.1 がデフォルトで使用されますが、project.clj に :min-lein-version \u0026ldquo;2.0.0\u0026quot;​ がある場合は (強く推奨されます)、Leiningen 2.9.1 リリースが代わりに使用されます。\nこれにハマった. project.cljに :min-lein-version \u0026ldquo;2.0.0\u0026rdquo; を記載して解決✨\nref: https://devcenter.heroku.com/ja/articles/clojure-support\nhowto: Heroku上で Botを動かそうとするとエラー    web appではなく worker appにする必要がある.\nそうしないと 60secでBootTimeoutとして扱われてProcess Killされる.\n2022-02-11T09:30:12.486217+00:00 heroku[web.1]: Error R10 (Boot timeout) -\u0026gt; Web process failed to bind to $PORT within 60 seconds of launch 2022-02-11T09:30:12.581863+00:00 heroku[web.1]: Stopping process with SIGKILL 2022-02-11T09:30:12.834345+00:00 heroku[web.1]: Process exited with status 137 2022-02-11T09:30:13.225734+00:00 heroku[web.1]: State changed from starting to crashed Procfileを新規作成して以下を記載.\n\u0026gt; worker: lein run\nheroku cliより\n\u0026gt; heroku ps:scale worker=1\nただし workerは30分活動がないとsleepしてしまう.\n実際はheroku schedulerの活用も検討.\nhowto: tools.deps管理のプロジェクトをHerokuにデプロイ    未実施だけどブックマーク. leiningenの作者はライバルにいじわる？\nref: 試行錯誤な日々: clojure cliプロジェクトをherokuで動かす\nFirebase/Google Cloud w/ Clojure    🏷Firebase\nref: https://github.com/tsu-nera/meigen-bot-firebase-clj\nFirebase Firestore(aka. Google Cloud Firestore) w/ Clojure    せっかくのClojureなのでClojure onlyで頑張らずにJavaやnode.jsの資産を活用する方向がいいかな\u0026hellip;Java資産活用しないとリッチーヒッキーの開発モチベに反する🤔\n Add the Firebase Admin SDK to your server | Firebase Documentation Get started with Cloud Firestore | Firebase Documentation  ref: 📝Firebase Firestore\nclient libraries    firestore-cljがよくできている. これをベースに他のリポジトリを参考にカスタマイズするとよい.\n https://github.com/lurodrigo/firestore-clj  java sdk   https://github.com/samedhi/firemore  javascript sdk with clojurescript   https://github.com/cloudfuji/taika  rest api   https://github.com/alekcz/fire  rest api    💡Firestoreのスキーマレスのメリットとclojure.specの思想が反する    FirestoreはスキーマレスDBということを留意する.\nすなわちこの特性によりスキーマ設計が不要というメリットを活かすならば動的言語であるClojureとの 相性がよく JSON Schema(Shcema/Malli/clojure.spce)は不要かもしれない.\nref. 📝Clojure spec\n💡FirestoreのドキュメントデータベースパラダイムとClojureプロトコルの思想が反する    またFirestoreは ドキュメントデータベースということも注意.\nドキュメントのモデルを作成してプロトコルを定義する必要はあるのか？\nなぜならばドキュメントはコレクションに格納されてその範囲内でのみシーケンス処理される.\nプロトコルとは操作抽象であり異なるデータ型を同一IFでシーケンシャルに処理することが目的であるがそもそもドキュメントデータベースのパラダイムにおいては異なるドキュメントを同一コレクションに入れるのかという問題がある.\nref: defprotocol\nタイムスタンプの扱い    調査中だがわかったところまで,\n java.time.x でFirestoreにデータを送るとobjectとして格納される. java.instantでFirestoreにデータを送るとobjectとして格納される. java.data.utilでFirestoreにデータを送るとTimestampとして格納される.  なのでタイムスタンプ型として時刻を格納するときはjava.util.Dateで投げる.\nFirebase Functions(aka. Google Cloud Functions) w/ Clojure    ClojureScriptを利用してJavaScript(Node.js)のライブラリを使うのがよい.\n ClojureScript + Firebase - DEV Community  ref: https://twitter.com/kbaba1001/status/1342628846655324160   My PWA made with Clojure/ClojureScript exceeded 400 users 🎉 - DEV Community  ref: https://twitter.com/b0xp2/status/1259685025122930689    しかしClojureの道に挑戦してしまった\u0026hellip;地雷だらけ.\n基本方針としては, Google Cluud FunctionsのJava11ランタイムのページをみながら, functions-framework-java を利用する.\n https://cloud.google.com/functions/docs/concepts/java-runtime https://github.com/GoogleCloudPlatform/functions-framework-java  2022.01時点での注意点としては,\n 他のJVM言語のところにClojureが登場しない.  https://cloud.google.com/functions/docs/concepts/jvm-langs Scala, Kotlin, Groovyは登場する. 他のJVM言語を真似してClojureを実行しようとすると,エラー.   デプロイ方式は２つあるがおそらくローカルビルドでないと失敗.  https://cloud.google.com/functions/docs/concepts/java-deploy ソースからのデプロイはpom.xmlとソースのuploadは成功するがclojureのビルドでコケる. そもそもCloud Functionsで使われているCloud BulildでClojureのビルドに対応しているのか怪しい. ClojureCoreその他ははdefaultでJava8でビルドされている. 一方Cloud Functionsのランタイムは11. したがってuberjar(fatjar)をローカルで作成して.classファイルと一緒にuploadするのがいい.   以下の3つのリポジトリが参考になる.  https://github.com/pepijn/google-cloud-functions-clojure https://pathom3.wsscode.com/docs/tutorials/serverless-pathom-gcf/#gcf-deploy https://github.com/atomist-skills/gcf-java11-clojure   ハマりポイントはエントリポイントをJavaで用意するところ.  Clojureで用意しようとしてもビルドエラーする.   ruberjarのビルドにはの 📝tools.build のguideをみて, JavaソースをコンパイルしてClojureコードをuberjarで.jarファイルに含める.  📝Google Cloud Run w/ Clojure    🏷Jib を利用してコンテナビルドする.\n Clojure in Google Cloud Run with Jib – Hannu Hartikainen Clojure app on Google Cloud Run | 3sky\u0026rsquo;s notes Google Cloud Run で Clojure アプリケーションを実行しよう | Micheam\u0026rsquo;s TechBlog  実際に検証した感触ではCloud Functionsよりも圧倒的に楽.\nref: https://github.com/tsu-nera/meigen-bot-gcloud-run-clj\n最近, jibbit というclojureからjibを扱いやすしたツールも登場(2022/01).\n https://twitter.com/kipzter/status/1480982692036591620 Containerizing a Clojure Project | Atomist Blog  References     🔗オブジェクト指向とはまったく違うClojureの世界と実際のWeb開発 - 紙箱 🔗Clojure で Web 開発をはじめてみよう — Clojure の日本語ガイド http://ayato-p.github.io/clojure-beginner/intro_web_development/index.html  ayato-pさんの作.  たしかわたしがClojureにはじめて触れた2015ごろにはすでにあった気がする.     Web Development with Clojure (第3版) の紹介 - Qiita  "},{"id":114,"href":"/notes/20220313110515/","title":"📝Clojure コーディング規約と慣習まとめ","parent":"🎓Keido HOME","content":"Clojureの書き方の慣習まとめ.\nup: 📁Clojure Development\n個人的な思想としてコーディング規約は人間がチェックするものではなく linterやformatterを使って自動整形すべきだと思う.\n 📝cljstyle - Clojureフォーマッタ  Clojure スタイルガイド    Clojureスタイルガイド が大変参考になる. あとはGitHubで他人のコードリーディング.\nこのスタイルが実質Clojure界隈でデファクトスタンダードになっていて, いろんなリポジトリを覗いてもこれに従って書かれている.\nここにはとりあえず身につけたい努力目標をメモしていく. 本当はスタイルとかは個人の努力に頼るのはアンチパターンでツールでチェックするのがいい.\n関数名や変数名は kebab-case aka. lisp-case    ref: https://totakke.github.io/clojure-style-guide/#lisp-case\n🏷kebab-case\n別の命名規約との変換のライブラリとして, Clojureでは camel-snake-kebab というものが有名.\nhttps://github.com/clj-commons/camel-snake-kebab\nマイクロサービス開発だと, 各言語によって変数名が異なるので変換が必要.\nClojureで作ったAPIをマイクロサービスの海に隠す - ayato-p\nProtocols/Records/Structs/TypesはPascalCase    ref: https://totakke.github.io/clojure-style-guide/#CamelCase-for-protocols-records-structs-and-types\n🏷PascalCase\nprivate functionsには defn- で印をつける    ref: https://totakke.github.io/clojure-style-guide/#private\n副作用の持つ関数は!, 変換をする関数の名称はtoではなく-\u0026gt;    e.g.) reset!\nJava Classでパフォーマンスが下がったら^でType Hintsをつける    reflection抑止によるコンパイル速度向上.\nref: https://clojure.org/reference/java_interop#typehints\nどちらかというと，使うなという意味だな🤔\n\u0026gt; Normally, one should avoid the use of type hints until there is a known performance bottleneck.\nリフレクションってなに？と思ったら過去記事を書いてた\u0026hellip;\n🖊Java のリフレクションでインスタンスやメソッドを動的生成する | Futurismo\n定数に特別な表記をしない    JavaとかPythonで定数を大文字にする慣習は注意. Clojureでは全てが定数なので不要.\n(def MAX-SIZE 10) ; Java style NG!!!\nReferences     How to Name Clojure Functions – Digital Digressions by Stuart Sierra  関数名どうするか問題.    "},{"id":115,"href":"/notes/20220309085644/","title":"📝Clojure デバッグ","parent":"🎓Keido HOME","content":"Clojure 開発におけるデバッグまとめ.\nrefs: 📝Clojure DX 📝Clojure REPL Driven Development\nprintデバッグ    古代人から現代まで引き継がれている由緒正しきデバッグ手法, aka. わたしの得意技.\nprint/println    Clojureでもっとも有名な標準出力関数.\npr/prn/pr-str    オブジェクトの内容をいい感じに出力してくれる.\n(println \u0026ldquo;おれはここだよ\u0026rdquo;)のようなトレースデバッグにはprintlnをつかい, データの中身をみる(Inspectする)にはprnをつかうのが使い分け.\nstr    clojure.pprint    Pretty Print for Clojure.\nclojure.pprint namespace | ClojureDocs.\nREPL起動すると読み込まれている. pprint: いい感じに出力.\nprnでオブジェクトを表示すると, たとえば大きなネストしたMapは1行に表示されて見にくい.その場合は, clojure.pprint.pprintをつかうと見やすくなる.\nREPLで (pp) と評価すると最終評価結果が表示される. このppの便利な使い方は, 普通に標準出力した結果が複雑だったときに, 再度ppを通じて表示することでさっきのデータ構造がいい感じになる.\nprint-method    Javaのクラスによく自分で実装するtoStringメソッドがClojureにもほしい！\n-\u0026gt; print-method というmultimethodをつかう.\ntoStringをオーバーライドするとJavaのクラスをSystem.out.println するときにクラスの内容表示を自分でカスタマイズできる.\nclojureでは print-methodというmultimethodが定義されている.\nただし, 基本的にはClojureはデータをMapで扱うことが推奨されているので, そもそもいらないかもしれない. JavaでtoStringが必要だったのはオブジェクトの中身を見る必要があるから. Clojureなら直接Eval!\nhashp    https://github.com/weavejester/hashp\nhashpをつかうと spy的に変数の内容を補足できる.\nコレは大変べんり!\nclojure.core tap    Clojure1.10から導入された機能.\n add-tap で出力先を指定. tap\u0026gt; で出力するデータを指定. remove-tapで出力先を削除.  tap自体はEditorやREPLから使うのだが, これと連携するツールが便利. GUIによるデータの可視化が可能になる.\nsee more -\u0026gt; 📝Clojure Data Visualization Tools\nlogging    ref: Clojure: Logging\nClojure REPLエラーメッセージまとめ    REPLで評価したときに出てくるエラーメッセージの分類とその対処.\nCIDERにおけるerror-buffer    エラーメッセージは cider-error bufferに出力される.\nstack-frameはデフォルトでたくさんでてくるが, filterをつかうと見やすくなる.\n(setq cider-stacktrace-default-filters \u0026#39;(tooling dup)) ;; or (setq cider-stacktrace-default-filters \u0026#39;(project)) Unhandled clojure.lang.ArityException    関数呼び出し時の引数の数が違う.\n1. Unhandled clojure.lang.ArityException Wrong number of args (0) passed to: xxxx Tips    nREPLを再起動せずにパッケージを追加したい    https://github.com/clj-commons/pomegranate\nReferences     Clojure における幾つかの実践的なデバッグ方法 - (define -ayalog \u0026lsquo;()) 6. (デ)バグズ・ライフ by (dosync radio)  "},{"id":116,"href":"/notes/20220119063524/","title":"📝Clojure 開発環境","parent":"🎓Keido HOME","content":"tags: 🏷Clojure\nClojure開発をするときの開発環境(DX)向上のあれこれ.\n主にClojure開発に関わるツールやライブラリまとめ.\n RDDはこちら: 📝Clojure REPL Driven Development Debugはこちら: 📝Clojure デバッグ Emacsに特化したものを別ノートに移動: 📝Cljure 開発環境 with Emacs  up: 📂Clojure Development\nLeiningen - Clojure Build tool    https://github.com/technomancy/leiningen\nClojureプロジェクト管理ツール. make的な.\nhowto: Java外部ライブラリをいれるには？    [\u0026lt;groupId\u0026gt;/\u0026lt;artifactId\u0026gt; \u0026lt;version\u0026gt;] という記法でproject.cljのdependenciesに追加.\n これが,\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.google.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;google-cloud-firestore\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.0.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; こうなる.\n[com.google.cloud/google-cloud-firestore \u0026#34;3.0.2\u0026#34;] howto: lein uberjarでThe Main-Class specified does not exist within the jar    main の core.cljのnsに(:gen-class)を追加.\n\u0026gt; Warning: The Main-Class specified does not exist within the jar. It may not be executable as expected. A gen-class directive may be missing in the namespace which contains the main method, or the namespace has not been AOT-compiled.\ntips: project.cljにビルド用設定のみ書いて設定情報はenvironやconfigをつかう    よい.\nref: https://twitter.com/t_yano/status/1163413764827303937\nClojure CLI tools.deps - Clojure Build tool    https://clojure.org/reference/deps_and_cli\n leiningenよりシンプルであることが特徴.  基本的には paths/dependencies/aliasesだけ覚えれば基本はできる. leiningenより学習コストは低い. cljコマンドでREPL起動. clojureコマンドで .cljファイルを実行.   deps.ednファイルで記述.  pathsにclojureのコードのrootからの相対パスを記述. dependenciesに依存ライブラリを記述. aliasesにcustom command を記述.  たとえば clj (-X/-M/-A):hogehoge というようなオプションを気軽に定義できる. npxのようなcommand runnerとしてつかえるかな？？     Rich Hickeyがこれから熱意を入れたいとか.  2022でメジャーなのはleiningenであるもののこれから逆転の可能性はある.  体感でdeps.ednのGitHub repoは増えている.      📝tools.build - Clojureプロジェクトのビルドツール    jar/uberjarの作成には tools.buildをつかうのが今風(2022~)\n https://github.com/clojure/tools.build https://clojure.org/guides/tools_build  refs:\n https://clojure.org/news/2021/07/09/source-libs-builds https://github.com/seancorfield/depstar (~2021) fogus: Clojure builds as an amalgamation of orthogonal parts  https://twitter.com/athos0220/status/1417640780303278082 https://twitter.com/athos0220/status/1411258058265694216    tools.tools    他人のつくったlibをClojure CLI ifに簡単に組み込むことができる.\n https://github.com/clojure/tools.tools Clojure - Using named tools  🔗References     Clojure + deps.edn, a basic guide | Tomek Wałkuski clojure CLI (tools.deps)を使いやすくするためのTips - Qiita Clojure CLIでClojarsにデプロイする - Qiita  cljstyle - Clojureフォーマッタ    Clojureフォーマッタ.\n先発のcljfmtはleiningen縛り. cljstyleはスタンドアロンバイナリとして動作する.\n https://github.com/greglook/cljstyle Clojureのフォーマッターcljstyleの使い方 - TOYOKUMO Tech Blog Clojure開発環境でのフォーマッターcljstyle設定まとめ - Qiita Clojure formatting with cljstyle | Andrey Bogoyavlensky  以下, Doom Emacsの設定例. format-allというpackageの clojure custom formatterとしてcljstyleを設定して, 保存時にフックでフォーマットが走るようにする.\n(add-hook! clojure-mode (set-formatter! \u0026#39;cljstyle \u0026#34;cljstyle pipe\u0026#34; :modes \u0026#39;(clojure-mode)) (add-hook \u0026#39;before-save-hook \u0026#39;format-all-buffer t t)) ref: 🏷Formatter 📝Clojureコーディング規約\nclj-kondo - Clojure Lintツール    ref: 🏷Linter\n"},{"id":117,"href":"/notes/20220316151158/","title":"📝Clojure 開発環境 with Emacs","parent":"🎓Keido HOME","content":" tags: 🏷Clojure 🏷Emacs  Clojure開発環境(IDE)としてのEmacs設定まとめ.\nEmacsに限定しないものは別ノート: 📝Clojure 開発環境\nEmacs CIDER    https://github.com/clojure-emacs/cider\nEmacsでClojure開発をするときのデファクトスタンダード.\nref: quick reference\nUsage     C-c l \u0026rsquo; cider-jack-in REPL起動 \u0026amp; 接続 C-c C-zで REPL - Editor間を移動. C-c C-c で現在の定義を評価. C-c C-e でフォームの末尾の手前から評価. C-c M-p で現在の定義をREPLに送信. M-. 定義に移動. C-c C-d C-d documentをみる. jack-inしている状態で2charくらい打ち込んで C-iで補完候補がでる. C-c M-i で cider-inspectorを起動, defの中身が別バッファに表示される. C-c SPC: clojure-align, alignを自動整形. Evaluation  M-x cider-pprint-last-eval-to-comment  式の評価結果がコメントとして書かれる. Design Journalとしては便利な機能かも. C-u C-x C-e でも可能.   M-x cider-pprint-defun-to-comment  これはフォームの先頭で評価すると次の行に結果表示.     cider-repl-set-ns: namespaceをreplに設定.  cf.: clojure-lsp    同様のツールでclojure-lspという EmacsからClojureのLSPを使うためのEmacs Packageもある. 同じことはCIDERでもclojure-lspでもできるが clojure-lspのほうがCPU使用率が高いとか(未検証).\ntips: cider-jack-inでカスタムの依存を設定    一応cider-jack-inをすると依存関係をよろしく解決してくれるが, productionに含めないdevelopmentの依存関係は自動で解決されない.\n.dir-locals.elに cider-clojure-cli-global-optionsや cider-clojure-cli-aliasesに追加の設定を書く.\n例えば, deps.ednのaliasに :devのような定義があれば,\n((clojure-mode . ((cider-clojure-cli-aliases . \u0026#34;dev\u0026#34;)))) ref: Practicalli: CIDER jack-in to Clojure CLI projects from Spacemacs\ntips: REPLの履歴をつかう(cider-repl-history)    REPLに入力したフォームはM-pで遡ることができる. また C-c M-p(cider-repl-history)で過去の履歴をリスト表示できる.\ntips: 変数定義の中身をみる(cider-inspect)    C-c C-eでフォームを評価して中身をみるのもいいが, ciderには cider-inspectという機能がある.\nこれを調べたい変数の上で実行(C-c M-i)すると, 別バッファに中身が表示される.\ntips: cider-clojuredocsの活用    cider-clojuredocsをすると別バッファで clojuredocs 内の関数定義を参照できる.\nClojureの初学ではライブラリをGoogleで検索することが多い. cider-clojuredocsをつかう習慣を心がけることで, マージン時間の削減につながる.\ntips: cider-connectでのport固定    固定ポート自体はnREPLのオプションから指定.\n:main-opts [\u0026#34;-m\u0026#34; \u0026#34;nrepl.cmdline\u0026#34; \u0026#34;-b\u0026#34; \u0026#34;0.0.0.0\u0026#34; \u0026#34;-p\u0026#34; \u0026#34;12345\u0026#34; \u0026#34;--middleware\u0026#34; \u0026#34;[cider.nrepl/cider-middleware,refactor-nrepl.middleware/wrap-refactor]\u0026#34;] cider-connectの接続先の候補に固定したportを表示する(ref).\n(setq cider-known-endpoints \u0026#39;((\u0026#34;localhost\u0026#34; \u0026#34;0.0.0.0\u0026#34; \u0026#34;12345\u0026#34;))) Emacs smartparens    https://github.com/Fuco1/smartparens\nEmacsでS式を操作する.\npareditよりもsmartparensのほうが最近登場したようなのでこちらをつかう.\ndoom emacsの default設定\n (, [, {などで自動で閉じカッコが挿入される. block movement  ()の中で)を入力すると，現在の)の末尾に飛ぶ. []の中で]を入力すると，現在の]の末尾に飛ぶ.   Navigation  C-M-a: sp-beggining-of-sexp 現在のS式の先頭へ移動. C-M-e: sp-end-of-sexp現在のS式の末尾へ移動. C-M-f: sp-forward-sexp 次のS式に移動 C-M-b: sp-backward-sexp 前のS式に移動 C-M-n: sp-next-sexp C-M-p: sp-previous-sexp C-M-u: sp-up-sexp 現在のS式のひとつ外側のS式の末尾へ移動. C-M-d: sp-donw-sexp 現在のS式のひとつ内側のS式の先頭へ移動. C-M-k: sp-kill-sexp 現在のS式の内側を削除. C-M-t: sp-transpose-sexp   wrapping/unwrapping  C-M-Spaceで現在の部分からwordの末尾までをマーク.  (とか[でマークした部分を囲む.   C-M-\u0026lt;backspace\u0026gt;: sp-splice-sexp  現在の部分の前のS式もろとも削除.      この５つを覚えるだけで、作業効率が上がりおすすめされている.\n Slurp （隣の括弧を吸い込む） Barf （括弧を追い出す） カット （括弧単位でのカット） コピー （括弧単位でのコピー） 削除 （括弧を丸ごと消す）  ref: いまどきのClojureのはじめかた - 紙箱\nrefs:\n https://github.com/Fuco1/smartparens https://ebzzry.com/en/emacs-pairs/ http://kimi.im/2021-11-27-sexp-operations-in-emacs  Doom Emacs Clojure Module    hlissner/doom-emacs · GitHub\n以下の3つのパッケージこ梱包されている.\n cider clj-refactor flycheck-clj-kondo  clj-refactor.el    CIDERの拡張で多様なリファクタリング機能を提供.\nclojure-emacs/clj-refactor.el\nよく使うものを抜粋する.\n cljr-thread-first-all: -\u0026gt; に表記を変換. cljr-thread-last-all: -\u0026gt;\u0026gt; に表記を変換. cljr-unwind-all: スレッディングマクロ表記をネストした()に分解.  とくにこれらはprint-debugで便利. スレッディングマクロはきれいに書けるけど途中経過をみたいときは一旦unwindして部分的にいじってまたもとに戻す.\nref: Clojure: Threading Macros\n cljr-clean-ns: 不要なnamespaceのモジュールを取り除く. cljr-destructure-keys  Clojure: 文芸的プログラミング with org-babel    org-modeのノート上からREPLにjack-inしてコードを評価. すなわち, Design Journal を org-modeから実施する (aka. Literature Programming).\n refs.  🏷org-babel 🏷Literate Programming https://github.com/tkf/org-mode/blob/master/lisp/ob-clojure.el 🖊Clojure REPL駆動開発とorg-babelによる文芸的プログラミング再発見 | Futurismo    header options     begin_src clojureを指定してorg-babelにclojureを設定. :results ppをすることで結果をpretty print  valueという評価結果を表示する指定はdefaultのため省略されている.   :ns fooを宣言すると, 起動時のnamespaceを設定できる.  resultは指定した nsにbindされる.     #+begin_src clojure :results pp (require \u0026#39;[lib.twitter.guest :as guest]) (guest/get-user \u0026#34;richhickey\u0026#34;) #+end_src org-babel実行     まず事前にREPLを立ち上げておく. C-c C-c を実行することでコードを評価.  cider-jack-in or cider-connectの選択を求められる. 事前に立ち上げておいたREPLにcider-connect    tips: org-modeでclojureコードを評価    通常は M-x org-edit-src-codeでコード編集だが, org-modeから編集するTips.\norg-babel で 実行したい言語としてclojureをenable. デフォルトでは emacs-lisp だけ.\n(org-babel-do-load-languages \u0026#39;org-babel-load-languages \u0026#39;((lisp . t) (shell . t) (clojure . t))) これで code blockに関わらずclojureがかける. 評価はorg-modeではC-x C-eがemacs-lispの評価に取られているので, 別のkeybindを設定する.\n(org-defkey org-mode-map \u0026#34;\\C-u\\C-x\\C-e\u0026#34; \u0026#39;cider-eval-last-sexp) References     🔗SpacemacsでClojureを書くために僕が行った設定 - ayato-p 昔のわたしの記事，もう情報が古い(2016)  🖊Emacs で Clojure の開発環境を構築 | Futurismo    "},{"id":118,"href":"/notes/20220116080418/","title":"📝Clojure:名前空間と変数束縛(Bindings and Namespaces)","parent":"🎓Keido HOME","content":"Clojureでは，変数の名前空間と束縛の関係は以下のようになる.\nref: 📂Clojure Core\nClojure: 名前空間(Namespaces)    Clojure の名前空間を namespaceという. ns で宣言する. \\*ns\\* で参照する.\nある名前空間から別の名前空間を参照するには requireをつかう.\n require のみ 省略なしの表記でアクセスできる(namespace/symbols) require :as 省略した表記でアクセスできる(省略namesapce/symbols) require :refer :all 名前空間を書かない表記でシンボルにアクセスできる(symbols)  🏷environments\nClojure: 名前空間のスタイルガイド    🏷Clojure Style Guide\nClojureスタイルガイド より名前空間に関わる部分を抜き出し\n 名前空間は1ファイルに１つ. 名前空間の命名規約はkebab-case(lisp-case). 深い名前空間のセグメントは悪い(せいぜい5つまで).  また. library-name.coreみたいなのはLeiningen Projectの慣習.\n名前空間のフォーマットについて.\n refer, require, importの順に並べる. 適切な改行. requireとimportを整理して並べる. Idiomatic な名前空間の名前をつかう.  具体例は以下にいろいろ書いてある. (io, set, pp, etc..). Use Idiomatic Namespace Aliases - bbatsov/clojure-style-guide 要は長い名前を使うのではなくて省略しましょうということ.    これらは人間が意識するべきではないのでツールに任せたいところだ. Emacs CIDERなら cljr-clean-ns or clojure-sort-ns.\nClojure: Scope    Clojureはデフォルトで静的スコープを採用している.\n🏷Scope\nDynamic Scope    動的スコープ. Emacsなら常識か.\nClojureのDynamic Scopeは bindings マクロで定義する. 名前空間を超えて, 同一スレッド内なら値(var)が参照可能.\nLispの慣例として, アスタリスク(*)でsymbolを囲む.\nそういう意味だと, スレッドローカルといえるかも. スレッドをまたぐ方法はまた別にある? (未調査, keyword: \u0026ldquo;binding conveyance\u0026rdquo;).\nrefs: Clojure - Vars and the Global Environment\nhowto: namespaceにbindingsされたシンボルを確認するには？    ns-xxx という関数で調べる.\n ns-map ns-publics ns-interns ns-refers ns-imports  たとえば, (ns-map \u0026lsquo;my-space)でmy-spaceにbindingsされているvarをすべて返す.\nns-mapは全て. ns-publicsはpublicなvars. ns-internsはrequireやreferなどを除くそのnamespaceで定義されたもの.\nしばしば, (keys (ns-interns \u0026lsquo;my-space\u0026rsquo;))など, keys methodと連携させる.\nM-x cider-browse-nsでEmacs Bufferで閲覧できる.\ntips: すでに他の名前空間に定義されている関数を読み込まない    refer-clojure :exclude をつかう.\n(ns hoge :refer-clojure :exclude [get set!]) Clojure: 変数束縛(Bindings)     変数の名前空間への束縛をdef  list formでbindingする. ex.) (def developer \u0026ldquo;Alice\u0026rdquo;) 無名関数はfn   変数の一時的な束縛を let  vector formでbindingする. ex.) (let [developer \u0026ldquo;Alice in wonderland\u0026rdquo;])   関数の定義はdefn  これはdefのシンタックスシュガーでもある.   無名関数はfn  #() でも表現可能.    🏷bindings\nClojure: defとvarとsymbol    Clojure: clojure.lang.Var     clojure.lang.Varはデータそもものを表すオブジェクト. 可変(mutable). varのリーダマクロは, #\u0026rsquo;  varにはMetaDataを設定できる. よく見かける代表的なのは,\n :dynamic  同一スレッド内で再定義可能. (def ^:dynamic foo 1)   :private  namespaceを超えて参照不可. (def ^:private bar 2)    ref. Clojure: MetaData\nClojure: clojure.lang.Symbol     clojure.lang.Symbolはデータを指し示す参照のオブジェクト. symbolのリーダマクロは, \u0026rsquo; , もしくは quoteで読み出し.  cf. C言語の関数と関数ポイントがvarとsymbolの関係.\n💡 def macro / alter-var-rootによるvarの再定義    def マクロは, clojure.lang.Varオブジェクトを生成する.\nuser\u0026gt; (def x) ;; =\u0026gt; #\u0026#39;user/x user\u0026gt; x ;; =\u0026gt; #object[clojure.lang.Var$Unbound 0x7d08131d \u0026#34;Unbound: #\u0026#39;user/x\u0026#34;] defによる変数束縛は内部で複雑なことをしている.\nuser=\u0026gt; (def foo \u0026#34;hoge\u0026#34;) #\u0026#39;user/foo defがマクロであるとは,\n \u0026ldquo;hoge\u0026quot;オブジェクトがメモリ上に確保される.(実際の値を0xhogohogehogeとしよう). Varオブジェクトがメモリ上に確保される(0xvarvarvaaaaaaaaaaa). varオブジェクトを\u0026quot;hoge\u0026quot;にbind(0xvarvarvaaaaaaaaaaa -\u0026gt; 0xhogohogehoge)する関係を作成.(0xbindbinddddddddddd) fooというsymbolオブジェクトを作成(0xsymmmmmmmmmm) 3のbindingをsymbolにintern(0xsymmmmmmmm -\u0026gt; 0xbindbinddddddd)という関係を作成してnamespaceにbind.  varはmutableでありsymbolはimmutable.\nいわゆるdefによってimmutableな値を宣言するとは, 参照元がimmutableであるということを言っている.\ndefによってvarが再定義可能ということは, defはsymbolを新しいvarを生成してbindingしている.\n一方alter-var-root関数をつかうと, mutableであるvarをそのまま変更する.\nClojure Style Guide では varの変更にalter-var-root推奨している.\nhttps://totakke.github.io/clojure-style-guide/#alter-var\nしかしそもそも論として, defやalter-var-rootによるvarの再定義は REPLやreloadのためのもの,いわば開発用のもの. 普通にプログラミングをしているときにこれが必要となったら何かがおかしい. 別の代替方法を検討したほうがいい.\nClojure: intern    defと似た概念でintern(拘禁)というものがある.\ndef と Symbol と Var の話 - (-\u0026gt; % read write unlearn)\ndefでbindしたsymbol-varの対応関係をnamespaceに登録する.\nClojure: defonce    defもdefonceも名前空間に変数束縛をするが, すでにvarが存在する場合, defは上書き, defonceはスキップする.\n言い換えると, var-symbolのpairをnamespaceに登録するときに, defonceはすでにvar-symbolのpairがあったらなにもしない.\nref: What is the difference between def and defonce in Clojure? - Stack Overflow\ndefonceとatomとhotreload    defonceはhotreloadの文脈でatomと合わせて登場することが多い.\n再起動のときにメモリをたくさん使ったり外部通信して時間がかかったりするときに, いちいちインスタンスを再作成してるとボトルネックになるのでdefonceをつかう.\nただしreplの再起動でよく利用される tools.namespace.replのrefresh関数は, たとえdefonceで定義されていたとしても初期化するので注意.\nref: https://github.com/clojure/tools.namespace#reloading-code-preparing-your-application\nたとえばM-x cider-eval-bufferをうっかりEmacsで実行してバッファまるごと読み込み直しても, defonceで宣言しているならばその変数束縛はスキップされる.\nまあこのあたりのhotreloadによるDX改善は自分で考えるよりもベストプラクティスを真似るのがいいのかも.\nref: Reloaded Workflow\nReferences     def と Symbol と Var の話 - (-\u0026gt; % read write unlearn)  https://togetter.com/li/680027   Clojure の alter-var-root って何だろう？ - Mitsuyuki.Shiiba  ✅ Active Recalls    Clojure の 無名関数のシンタックスはなんですか？    fn or #()\nClojureの名前空間の宣言方法と参照方法はなんですか?    ns と \\*ns*\nClojureで名前空間を参照するためのシンタックスはなんですか?    require\nClojure nsの属性で :requireと:importの違いはなんですか？    どちらもnamespaceに他のnamespaceで定義された宣言を取り込むが, requireはclojureのライブラリ, importはJavaのクラスで利用する.\nClojureでdefとdefonceの違いはなんですか？    名前空間に変数束縛するとき,すでに変数が存在する場合の挙動が違う.\ndefは上書きをする. defonceはスキップする.\nClojure.lang.VarとSymbolの違いはなんですか？    Varはデータもそのものを示す参照.\nSymbolはVarを示す参照.\nClojure defとinternの違いはなんですか？    defは値と参照の対応関係を作成してその対応関係をnamespaceに登録するまでの一連の手続きをマクロにした.\ninternは拘禁でありbindされた写像をnamespaceに登録する.\n"},{"id":119,"href":"/notes/20220116095639/","title":"📝Clojure/ClojureScriptの参考リンクまとめ","parent":"🎓Keido HOME","content":"ref: 🏷Clojure\nここにまとまっているのでもはやわたしがまとめる必要はないかも.\nClojure/ClojureScript関連リンク集 - Qiita\nとりあえず自分の目を通したものをコメントとともにメモしておく.\nClojureリファレンス     clojure.org - 公式サイト  clojure.org の日本語訳 - しっかりと書かれた参考になる日本語資料.   ClojureDocs - CommunityでメンテしているClojureドキュメント.  https://clojuredocs.org/quickref - クイックリファレンス   Clojureスタイルガイド  https://github.com/totakke/clojure-style-guide   Clojure Destructuring Tutorial and Cheat Sheet · GitHub  Clojureb分配束縛についてまとめ    Clojure Trend CatchUps     ClojureVerse  discourse 上のClojure掲示板. 困ったときの知恵袋.   https://www.reddit.com/r/Clojure/  Reddit Clojure板.   https://twitter.com/search?q=clojure%20lang%3Aja\u0026src=recent_search_click\u0026f=live  Twitter検索 clojure lang:ja live.   Clojure - Qiita Clojureの記事一覧 | Zenn Search Results for clojure - DEV Community  Clojure開発役立ち情報     関数型プログラミングClojure | Deus Ex Machina  Clojure個人開発/つくってみた まとめ    とにかくはじめは他人が書いたコードを意味を確認しながら精読するのがよい.\n ClojureでQiita APIをたたく - Qiita  https://github.com/akthrms/qiita-client-sample   Clojure 入門者による【チャットボットづくり】 Part1 - すなぶろ  https://github.com/sandmark/unmo-clojure/    Clojure Books     📚Living Clojure - Carin Meier(2015) 📚プログラミングClojure - Alex Miller, Stuart Halloway(2nd:2013/3rd:2018) 📚The Joy of Clojure, Second Edition Clojure Applied  Clojure中級者向け. https://pragprog.com/titles/vmclojeco/clojure-applied/   Mastering Clojure Macros: by Colin Jones  Clojure Macros の本. Oreilly Online Book でも読める.    Clojureの学習教材     Functional programming with Clojure  オンライン学習 Functional programming with Clojure をやってみた | Futurismo   Clojureに入門したら知っておきたいN個のこと - lagénorhynque  "},{"id":120,"href":"/notes/20220116161735/","title":"📝Clojureの思想","parent":"🎓Keido HOME","content":"Clojureの思想についてまとめる.\nできるだけ他者の意見を集め, それに対する考察は Clojure考察 でまとめる.\nrefs: 🏷Clojure 📝Clojureモチベ\nClojureの設計思想を探るにはYoutubeに投稿されている Clojure Conjの動画をみるのもいいかも. たくさん動画がある.\nLisp Reloaded    Lisp本来の力を持ちながらLispの歴史に成約されない.\nJVMに対する圧倒的な信頼    OSではなくVMが未来のプラットフォームである.\nCode is data, data is code    aka. LISPの思想.\nClojureは不定であり不変    Clojureにおいて値は immutable であり persistent である.\nSimple made Easy     \u0026ldquo;Simple Made Easy\u0026rdquo; - Rich Hickey (2011) - YouTube Clojureの世界観 - 紙箱 \u0026ldquo;simple\u0026quot;と\u0026quot;easy\u0026quot;はどう違う？Simple Made Easyを解説 Part1 - ログミーTech 🎓フルベンオタクなのでシンプルなものは美しい  Prefer data over fucntions    データ \u0026gt; 関数 \u0026gt; マクロの順に選択する.\n Data \u0026gt; Functions \u0026gt; Macros. But why? - LispCast  WIP：Clojure のデータ駆動のメリット - kekemoto    Make Your Data Visible    ref: Thinking in Data\nデータの非公開は不要, なぜなら不定だ. カプセル化はミュータブルな世界の産物.\n🏷カプセル化\nReferences     Clojure - Rationale  日本語訳: Clojure - 論理的根拠   Clojureの世界観 - 紙箱  "},{"id":121,"href":"/notes/20220116175232/","title":"📝Clojureモチベーション","parent":"🎓Keido HOME","content":"Clojureの勉強のモチベをあげる記事. 🏷Clojure 🏷プログラミングモチベ\nWhy Clojure | 英語記事まとめ     Clojure as a Competitive Advantage  スタートアップの言語にClojureを採用した理由.   Why Clojure? I’ll tell you why…. Clojure is a functional programming… | by Ertuğrul Çetin | Medium  Paul GrahamのTwitterリプライにて.  I would suggest Clojure now, not CL.     Are there any Lisps you would recommend (other than Clojure)? (Or languages?) | Hacker News  Hacker newsでのPaul Grahamのコメント(2012)  \u0026gt; Clojure is probably the best bet. I don\u0026rsquo;t know much about it but lots of people seem to use it, and any decent Lisp that lots of people use is probably a good bet.   まあLispのなかではClojureだが，プログラミング言語全体とはいってない.    なぜClojureなのか | 日本語記事まとめ     Clojureだと生産性が上がるわけ | POSTD キメるClojure高速開発 - Qiita  Personal Journals about Clojure    Clojureに関する個人的なポエム.\n 🖊シンプルさが前に進む力となる Clojure | Futurismo  "},{"id":122,"href":"/notes/20220324182338/","title":"📝Cognitect","parent":"🎓Keido HOME","content":" Datomic開発元. Clojure開発コアメンバ所属. Nubankに買収された.  COGNITECT JOINS NUBANK(2020/07/23)    List of Cognitect Developers     👨Stuart Halloway(@stuarthalloway)  "},{"id":123,"href":"/notes/20211211065629/","title":"📝Common Lisp","parent":"🎓Keido HOME","content":" tags: 🏷Programming Language 🏷Lisp wiki: Common Lisp - Wikipedia  Common Lisp Books     📚Land of Lisp - Conrad Barski(2013) 📚実践Common Lisp - Peter Seibel(2008) 📚On Lisp - Paul Graham(1993)    2022年のCommon Lispの学習本はこれだ!  References     💻A Road to Common Lisp / Steve Losh  "},{"id":124,"href":"/notes/20220127181529/","title":"📝DarkHorse","parent":"🎓Keido HOME","content":"DarkHorseとは，今まで見向きもされなかったのに，型破りな方法で突然快進撃をはじめ勝者となる人を指す言葉.\nref: 📚Dark Horse - Todd Rose, Ogi Ogas(2021-08-20)\n偉人とはかけ離れた平凡な普通の人がある日からダークホースになっていった.\nダークホースを研究するダークホースプロジェクトによって，法則性を発見した. いろいろバラバラな部分があった.大胆さも孤独もアウトローも, 一例であり反例もある.\nしかしたった１つの共通点は 充足感の追求 だった.\nさらに研究が明らかにしたのは,充足感を追求して生きるという,\n充足感に従う断固とした決意.\n既存の成功法則 = 標準化時代(Standardization)    産業革命が標準化時代の幕開け，標準化することによる生産システムの効率の最大化. そして工場生産の標準化を発展させた結果，人間の標準化に進んだ.\nカーネギー，ナポレオン・ヒル，ジムロジャーズ\u0026hellip; これらは標準化時代というパラダイムにおける成功法則, 物語に過ぎない. 個別化時代というウラ世界が存在する.\n自分の目的地を知り，それに向かって懸命に取り組み，コースから外れるな.\nヒエラルヒーのトップを目指して金と力を求めて努力する. 組織の上層部を目指す人々にとっては都合の良い考えや習慣.\nこれからの成功法則 = 個別化時代(Personalization)    万人に通じる成功法則はなく，あなたにとっての成功法則を探す必要がある. 誰ひとりとして，平均的な人間はいないというのが，個性学の概念.\n社会では金と力で成功が測れる，しかし個人では充足感と達成感で測れる.\n目標の職業を選択してそのヒエラルヒーのトップへ上り詰めることを断固とした決意でやりぬき金と名声を手に入れる, この物語には充足感が登場しない.清貧の誓い, 苦難の克服, これらは標準化時代の成功哲学の物語にすぎない. 個別化という裏の世界にはワクワク感しかない.\n本当の成功とは, 世界一ではなく最高の自分になること.\nDarkHorse物語の共通点     社会のレールに従った日常を生きる生活や人生に対して 小さな違和感 を感じる. 小さなモチベーション に気づく(これが最重要かつ第一の要素). いくつもの小さなモチベーションを収集する. 人生の転機を体験し，充足感を追求して生きるという決意をする.  DarkHorseの4つの成功ステップ    1. 自分の中の「小さなモチベーション(micro motives)」をみつける    重要キーワード: 小さなモチベーション(Micro-Motives)\n モチベーションは多様にあり，あなたのモチベーションは一般化できない.\n性欲(フロイト), 権力(アドラー), ユング,フランクル(生きる意味), エリクソン(成長)\u0026hellip;たくさんありすぎ！\nしかし組織にとってはひとつで説明できたほうが楽なんだ.\n偏愛こそが充足感に不可欠. ヘンタイバンザイ！ 小さなモチベーション(Micro-motive).\n小さなモチベーションに気づいたらできるだけたくさん集める.\n間違いは単一の大きな情熱に従って生きること. ヒエラルヒーの上位の目的地を目指す単方向で一直線のベクトルではない. 燃え上がるひとつのモチベーションには従わない.\nそうではない, しかし自分にとって重要なたくさんの小さなモチベーションを集める.\nDarkHorseの情熱はたくさんの小さなモチベーションが複雑に絡み合い，さらに移ろうものであり，常に本人の意志で制御されるべきものなので. 小さなモチベーションが多ければ多いほど，ワクワク感とともに充足感が得られる.\n2. 一般的なリスクは無視して，自分にあった道を選ぶ    重要キーワード: フィット(Fit)\n 標準化されたシステムの元では選択肢は限られていて，二択か三択から指定することしかできない.　標準化した教育システムでは選べないものがたくさんある. 大企業の選択肢は, 出世するか，出て行くかの二択. 標準化の枠組みでは選択はできない，指定しかできない.\n料理をしようとしたときに，自炊すれば野菜から創作料理ができるが，お店ではメニューを指定するしかない.\n 標準化された社会の用意した成功の鋳型にフィットすればエリートになれ，フィットしなければ落ちこぼれになる. 敷かれたレールで成功できるかどうかは，あなたが既存の鋳型に自然にフィットするごく少数の幸運な人々のひとりだった場合のみ.\nしかし目的の環境に自分がフィットするかどうかなんてわからないし，仮にその型にあわせるために努力して自分の個性を捻じ曲げてあわせようとしても，そもそもそれはゼロサムゲームであり，席の数は限られている.\n DarkHorseは選択をすることで目的を生み出す.\nDarkHorseは情熱に従わない. 従うのではない，生み出して制御するものである.\nヒエラルヒーの上位の目的地を目指す単方向で一直線のベクトルではない. 燃え上がるひとつのモチベーションには従わない.\nDarkHorseの情熱はたくさんの小さなモチベーションが複雑に絡み合い，さらに移ろうものであり，常に本人の意志で制御されるべきものなので. 小さなモチベーションが多ければ多いほど，ワクワク感とともに充足感が得られる.\nこれがわたしの生きる道です\nお金とか地位とか名誉とか，そんなものをに左右されずに，これでいくという選択を決断し，あとは取り組むのみ.\n仮に目標が達成できたからってお金がもらえるとは限らないが, お金だったり地位だったり，そのようなものを得るための成功の確率で選択していない.\nDarkHorseは自分の選択した道に全力で挑む.報酬は充足感と達成感であり，それを追求する.\n3. 自分の強みを自覚したうえで，独自の戦略を考え出す    戦略とは，うまくなる方法のこと.\nそしてダークホース的な上達方法は，自分自身の強みを案内役にして，独学法やトレーニング方法を編み出すことだ. 一見風変わりでも，あなたにとっては正攻法になる.\nあなただけの必殺技を磨け. 自分にとって最も大切なことで上達する.\n 得意なことと好きなことは全く別物である.\nxxxしたいという欲求は, 意識のなかに強引に(自然発生的に)入ってくることが多い. もしくは内省によって現れる. つまり，感じるんだ.\nしかし強みは状況によって左右され，外的な要因で決定される. それを内的な要因によって感じることは出来ない. 強みとは学びを通じて構築されるもの，たゆまぬ努力によって得られる能力. 強みは内省ではなく，行動によって見定める.\n 戦略を選ぶとは，トライ\u0026amp;エラーであり，色々試すことで最適な方法を探る.\n自分の強みも，小さなモチベーション同様，たくさんあればあるだけよい. なにが状況にフィットして効果を発揮するのかわからないのだから，たくさん集めてたくさん試して試行回数で探索する.\nnote    ここでいう強みは八木さんの強みとは違うな.\n八木さんは強みとは自然にできることが環境によって成果を発揮するもの. スキルと強みの違いは，強みは自然にできることでスキルは学習によって獲得するもの.なので， DarkHorseのこの文脈ではスキルの意味合いに近いかな.\nref: 💻自己分析で考えるべき3項目とは？始める前に見ないと時間の無駄 - 八木仁平\nしかしまあ戦略とはうまくやるための方法であり，そのためには強みもスキルも両方つかうというのがいいという点で厳密な区別は不要かもしれない. 要は武器なのだ.\n4. 目的地のことは忘れて充足感を今抱いているか自問する    DarkHorse的な成功を目指すなら，最終目的地は忘れろ.\n他人や社会が用意した既成の成功をそもそも目指さない. そしてそれを得るために自分を捻じ曲げて無理やり合わせようとはしない. それは充足感を損なう行為だ.\n 前に進んでいるうちに，小さなモチベーションも変化すれば周囲の状況も変化する.目的地が遠ければ遠いほど，あなたは変化する. 失敗により新たな能力に覚醒して成長するかもれない, 小さなモチベーションの組み合わせが予想だにしない進化を遂げるかもしれない. まっすぐな道を歩み始めたときには存在しなかった機会が新たに出現する.\n ダークホースは，目的地は忘れるが目標は無視しない.\n目的地は遠い未来であり達成できるかは不確かだが，目標は期限伴い具体的に達成可能なものだ.\n目的地に到達するには，機械学習アルゴリズムの極大値を探すための勾配法で探す. つまり最もインパクトがある傾斜を進み，止まったらその地点を見渡してもっとも傾斜がある方向を進む.\nActive Recallsj    なぜDarkHorseは自らの情熱に従わないのですか？    従うのではない，生成して制御するもの.\n情熱は他人や社会から与えられるものではなく、自らの好奇心と選択によって戦略的に意図的に作り出すものなので.\n選択と指定の違いはなんですか？    選択は能動的，指定は受動的.\n選択は選択肢が無数にある、指定は選択肢が二つか三つしかない。\nDarkHorseにおける小さなモチベーション(i.e.micro motive)とはなんですか？    DarkHorseにおけるフィットとはなんですか？    自分の個性と，自分の環境や状況が適合して能力を発揮すること.\nネガティブサム・ゲームとはなんですか？    ごく少数の勝者と大多数の敗者を生み出すゲーム.\n誰かが勝てば誰かが負けるような勝率５割のゲームはゼロサムゲームという.\nネガティブサムゲームはその勝率にいびつな偏りが生じたもの.\nなぜDarkhorseは目的地を無視して目標を追うのですか？    目的地は他人が考えた目的に自分が同意して、目指すと決めた地点であり、たいていは標準化システムの定義してものなので。\n自分のマイクロモチーフは変化するし多様な組み合わせで構築するので、不確かであり、単一の目的を定義できない。確かなのは期限とゴールがある目標のみ。\nエリートとダークホースの違いはなんですか？    DarkHorseの成功法則の４つのルールはなんですか？     小さなモチベーションを集める. 自分の偏愛にフィットすることを追求することを決断する. 自分の強みを活かして独自戦略を考える. 長期の目的を無視して短期のゴールを達成しつつ探索的に前に進む.   私の言葉でいいかえると,\n 自分だけのオタクな偏愛を集める. この道で人生をぶち抜くと決断する. 自分独自の必殺技を編み出す. ピボットしながらグロースハックで前に進む.  "},{"id":125,"href":"/notes/20220129084156/","title":"📝DarkHorse的な生き方をしている人まとめ","parent":"🎓Keido HOME","content":"なかやまきんに君    t.8:15 筋肉とお笑いをかけ合わせればなにかが起こるという根拠のない自信.\nref: 私、なかやまきんに君は吉本興業を退所致します - YouTube\nHIKAKIN    スーパーの店員をしながらヒューマンビートボックスの動画を月に数本Youtubeに投稿していた.\n2010/06/19ある日突然 Super Mario Beatbox がいきなり世界中からみられるようになった.\n refs:  【漫画】ヒカキンブレイクまでの軌跡 - YouTube 好きなことで、生きていく - HIKAKIN - YouTube [ Long ver. ] - YouTube    古今亭志ん生    ref: 知ってるつもり？！古今亭志ん生（五代目） - YouTube\nISSA(DA PUMP)    DAPUMP～解散危機からの復活～P.A.R.T.Y. ～ユニバース・フェスティバル - YouTube\n武井荘    ref: けいちょんが自宅に凸してきた！！！ - YouTube\n"},{"id":126,"href":"/notes/20220326063706/","title":"📝Date/Time/Timestamp概論","parent":"🎓Keido HOME","content":"up: 📂ソフトウェア開発\n各論     📝Clojure Date/Time/Timestamp  Timezone: タイムゾーン    タイムゾーンとは、地球上で同一の標準時を採用している地域の集合のこと. コンピュータなどで機器内部の時刻をどの地域の標準時で運用するかを定めた設定項目.\nUTC: 協定世界時    JST: 日本標準時    日本の地域は 日本標準時JST(Japan Standard Time)に定められている.\nUTCから9時間進めた時刻(UTC+9)を日本標準時と定義してある.\nLocale: ローケル    システムやソフトウェアにおける言語や国・地域の設定のこと.\nこれを設定することで例えば日本では月/年のような表記が扱える.\nActive Recalls    時刻の設定でtimezoneとlocaleの違いはなんですか？    timezoneはどの時間帯をソフトウェアで採用するかの設定項目.\nlocaleはどの国や地域の表記に従うかの設定項目.\n"},{"id":127,"href":"/notes/20220215162555/","title":"📝Datomic","parent":"🎓Keido HOME","content":"Clojureの作者, Rich Hickey の開発したDatabase.\nhttps://www.datomic.com/\ntags: 🏷Clojure 🏷Rich Hickey 🏷Cognitect\n💡Datomic First Impression    Downloadは登録が必要でFreeだと年1回のUpdateか.\nどうも期待していたものと違うな. 個人でさくっと試したり遊んだりするものでなくてガッツリ企業が金を払ってサポートも受けながらProduct開発するものだな. SalesForceみたいな.\n流行らない理由がわかったかもしれない. さくっとやってみた系の記事も仕事でこれから使う人しか書かない気がする. 最小構成のDatomic Cloudすら月3500円はちょっと敷居が高い.\n Datomic をとりあえず無料でつかってみるには Datomic On-PremのStarterを使う. Webサイトに会員登録が必要, 登録するとライセンスキーが発行されるのでそれをつかってダウンロード. Starterの場合更新は1年に1回の制限がある.\nもしくは Local Dev versionというものは, メモリ上にデータを保持するので再起動でデータが消えるけどお試しならこれでもいい.\nなによりDatomicはOSSではなかった, 自由に使えると勘違いしてた(笑). 2020にNubankがCognitectを買収したらしいのでこれで風向きが変わるといいな.\nref. Cognitect Joins Nubank\nDatomic On-Prem    Datomicは現在AWS で動かす Cloud とローカルで動かす On-Prem がある.\n Datomic - On-Prem Document Index | Datomic  References     from @hden  Toreta CTO https://note.com/hden Datomic Cloud を半年運用した感想｜hden｜note Datomic Cloudで実現するデータ指向アプリケーションデザイン｜hden｜note week-of-datomic｜hden｜note トレタ社CTO hdenさんとDatomicの濃い話 etcをする - YouTube   from @k2nakakura  Datomic Ions ワークショップに参加した - Qiita Datomic on AWS - Qiita   Clojureの作者が作ったデータベースDatomicが凄い Datomic使ってて嬉しい点/頑張って欲しい点 - Qiita  "},{"id":128,"href":"/notes/20220312121007/","title":"📝Declarative Domain Modeling","parent":"🎓Keido HOME","content":"システムを1つの大きな関数として捉える\nsystem = fn(logic, state, model).\n宣言型プログラミング のパラダイムがベース.\nup: 📂ソフトウェア設計\n用語の整理    system    logic    state    model    References     Declarative Domain Modeling for Datomic Ion/Cloud - Tiago Luchini - YouTube  "},{"id":129,"href":"/notes/20220310114456/","title":"📝Dependency Ingection","parent":"🎓Keido HOME","content":"以下は同じ用語.\n Dependency Ingection DI 依存性注入  refs:\n 📝Clojure: Integrant 猿でも分かる! Dependency Injection: 依存性の注入 - Qiita  "},{"id":130,"href":"/notes/20220322082226/","title":"📝DMM Development","parent":"🎓Keido HOME","content":"tags: 🏷Development\n主に DMM Web API について.\nDMM API SDK    公式と非公式合わせて, 各言語ごとにまとめ.\n official(link)  JavaScript: https://github.com/dmmlabo/dmm-js-sdk PHP: https://github.com/dmmlabo/dmm-php-sdk Go: https://github.com/dmmlabo/dmm-go-sdk   unofical  Java: https://github.com/r-fujiyama/dmm-java-sdk Scala: https://github.com/SuzumiyaAoba/dmm4s Ruby: https://github.com/r7kamura/rdmm Python: https://github.com/miya/dmm-search3    DMM API Web Services     https://github.com/nickwph/JavPlexAgent.bundle https://github.com/libredmm  References     📝Tech系のアダルトサイト制作事例まとめ  "},{"id":131,"href":"/notes/20220316081935/","title":"📝Docker","parent":"🎓Keido HOME","content":"ref: 🏷Domains\n📝Jib: Build container images for your Java applications    refs: 🔗GitHub 🏷Java 📝Google Cloud Run w/ Clojure\nGoogleの開発したJavaアプリのためのコンテナ作成ツール.\nDockerfileを書かなくてもImageをBuildできることが特徴.\nJib を使用して Java コンテナを構築する | Google Cloud\n🔗References       Comming soon\u0026hellip;\n"},{"id":132,"href":"/notes/20211228180209/","title":"📝Emacs","parent":"🎓Keido HOME","content":"🏷Emacs\nreadonly repositories\n https://emba.gnu.org/emacs/emacs https://github.com/emacs-mirror/emacs/commits/master  Emacs Tips    tip: Linux上で動作するEmacsで親指シフトの最適解(2022)    ref: 🖊Linux上で動作するEmacsで親指シフト入力をする最適解(2022)\nnote:\n ブログへ文章を移動した. \u0026lt;2022-01-12 水\u0026gt; こういう流動的なものはwikiに置かないほうがいいかも.  howto: fcitxでEmacs GUIの日本語入力ができないときの対処方法    環境変数でLC_CTYPE=zh_CN.UTF-8を設定して起動する.\nlink: https://fcitx-im.org/wiki/Input_method_related_environment_variables\n#!/bin/bash LC_CTYPE=zh_CN.UTF-8 emacs  日本語情報がなくて苦戦したが中国語でも同じ課題があるだろうという観点で検索したら解決方法か見つかったので載せておく.\n howto: init.elをOrg Fileから生成するには?    see\n Emacsの設定（その2）設定ファイル（init.el）をorg-modeで管理する | A perfect autumn day  init.elをOrg Fileから生成してそうなサイト     https://takaxp.github.io/init.html https://www.grugrut.net/posts/my-emacs-init-el/ https://mugijiru.github.io/.emacs.d/basics/custom-file/  example: Doom Emacs実装    わたしの場合，Doom Emacsをつかっている(2022現在)ので，init.elではなくconfig.elに設定を追加.\n(require \u0026#39;org-install) (org-babel-load-file \u0026#34;~/.doom.d/nothung.org\u0026#34;) 参照    以前，babel-loaderをつかってOrg fileを細かく分割して管理していたが，カオスになったのでゴミ箱に捨てました.\n 🖊babel-loader:org-mode で init.el を管理する方法 | Futurismo https://github.com/tsu-nera/dotfiles/tree/master/.emacs.d  tip: Emacsでマスウスクロールが微妙になめらかに    Emacs29で入ったモード. 微妙にマウススクロールがなめらかになったが気のせいかも. 言われないと気づかないレベル.\n(pixel-scroll-precision-mode) tip: X windows上のEmacsのスピードアップ    \u0026gt; xset r rate 200 60\nnote: いろんなEmacsの改造の中で最近のクリーンヒットはこの設定かも. カーソル移動が爆速になった😄\n"},{"id":133,"href":"/notes/20220307102236/","title":"📝Expression Problem","parent":"🎓Keido HOME","content":"様々なプログラミング言語のプログラミングパラダイムについての長所と短所を議論する際に用いられる用語.\n型変換や条件分岐を使用せずに、既存のデータ型に機能を追加するにはどうすれば良いのか、という問題.\n Expression problem - Wikipedia  (ja) Expression problem - Wikipedia    refs:\n 📝ポリモーフィズム 📝Clojure Expression Problem データ型の追加  条件分岐 switch パターンマッチ   関数の追加  インタフェース    up: 📁Programming Paradigms\n"},{"id":134,"href":"/notes/20220308203433/","title":"📝git","parent":"🎓Keido HOME","content":"refs: 📂ソフトウェア開発\nGit Emoji Prefix    git commit messageのprefixに絵文字をつかってテンションを上げようという流行.\ngitmoji というOSSなど支援ツールもあるものの, 絵文字の種類が多すぎて覚えられないし不要なものもある.\nそのため独自ルールを設定して運用する. 大事なのは決められたルールで統一することなので.\nwikiの都合上, unicodeとgithubの両方の絵文字を記載.\n 🎉init: はじめてのコミット(:tada:) ✨feat: 新しい機能追加(:sparkles:) 🔥fix: バグ修正(:flame:) 💪improve: 機能改善(:muscle:) 🎨refactor: リファクタリング(:art:) 📝docs: ドキュメント修正(:pencil:) ✅test: テスト, 評価(:white_check_mark:) 🔨chore: 雑務(:hammer:) 🐥wip: 取り掛かり中(:hatched-chick:)  動物なら何でもいい   💥refactor: 破壊的変更(:boom:)  逆引きgit: hotto    gitの操作であれどうやるのをまとめていく.\nhowto: gitのローカルのブランチ名を変更したい    古いブランチ名から新しいブランチ名に変更.\n$ git branch -m \u0026lt;古いブランチ名\u0026gt; \u0026lt;新しいブランチ名\u0026gt; 今開いているブランチをリネーム.\n$ git branch -m \u0026lt;新しいブランチ名\u0026gt; "},{"id":135,"href":"/notes/20220412162504/","title":"📝Google APIs","parent":"🎓Keido HOME","content":" :pencil:Google Indexing API  up: 📂ソフトウェア開発ドメイン\nGoogle APIとは    Google のサービスをプログラムから利用するためのAPI群.\nGoogle API ライブラリの整理(Java)    GitHubのリポジトリをみてもいろんな種類がありややこしい.\n一度整理する(Java).\nまずBaseとなるのが以下のHTTPやoAuthのライブラリ.\n https://github.com/googleapis/google-oauth-java-client https://github.com/googleapis/google-http-java-client  google-api-clientはおそらく最も有名. httpやoauthを元に作成されている.\n https://github.com/googleapis/google-api-java-client  google-api-client-servicesはgoogle-api-clientを元に使いやすくしたwrapper. これはこれでいいのだがドキュメントが不十分で結局google-api-clientを使うことになる.\n https://github.com/googleapis/google-api-java-client-services   This repository contains the generated source for individual APIs that utilize Google APIs Client Library for Java.\n Googleのサービスはたくさん種類があり，マイナーなものであればあるほどドキュメントがOutdatedだったりイマイチなのでissueやstackoverflowやGitHubの他人のコードを漁ることになる.\n"},{"id":136,"href":"/notes/20220311153749/","title":"📝Google Cloud","parent":"🎓Keido HOME","content":"Googleの提供するクラウドサービス群\nFirebase は Google Cloudのなかで特にアプリケーション開発に使うものをパッケージングして名前をつけたもの.\n 📝Google Firestore  up: 📂ソフトウェア開発ドメイン\n"},{"id":137,"href":"/notes/20220311153829/","title":"📝Google Cloud Firestore","parent":"🎓Keido HOME","content":"Goolge Cloudの提供するサーバレスなNoSQLサービス.\nGoogle Cloud からFirestoreの機能を切り出したのがFirebase Firestoreなのでここでは同一のもとして述べる.\n 🔗Cloud Firestore | Firebase Documentation  refs: 🏷NoSQL 🏷Google Cloud\nFirestoreの特徴    データベースというよりは、検索可能なデータ置き場. 複雑なデータ処理が要求されるようなアプリには余り向いてない.\nFirestoreの操作     Cloud Firestore でデータを取得する | Firebase Documentation Cloud Firestore にデータを追加する | Firebase Documentation  Quick Reference    いつも忘れるので簡単にまとめておく.\n 追加  add: 新規作成(IDを自動生成)  add(data): CollectionReference =\u0026gt; none   set: 新規作成(IDを指定)  set(data): DocumentReference =\u0026gt; none   set: 新規作成(IDを自動生成)  set(data): DocumentReference =\u0026gt; none     取得  get: 単一ドキュメント取得  get(): DocumentReference =\u0026gt; DocumentSnapshot   get: 複数ドキュメント取得  get(): CollectionReference =\u0026gt; QuerySnapshot   where: 条件指定 orderBy: 並べ替え limit: 個数指定   更新  update: ドキュメント内のフィールド更新  update(data): DocumentReference =\u0026gt; none Map型フィールドを更新:  ドット表記 でネストしたデータを更新.  update({\u0026ldquo;foo.bar\u0026rdquo;: 1})   ネスト表記でネストデータを親から上書き.  update({\u0026ldquo;foo\u0026rdquo;: {\u0026ldquo;bar\u0026rdquo;: 1}})     配列フィールドを更新:  arrayUnion: 要素を配列に追加 arrayRemove: 要素を配列から削除     set: ドキュメントを上書き set({merge: true}): : ドキュメント内のフィールド更新   削除  delete: 単一ドキュメント削除  delete(): DocumentReference =\u0026gt; none   collectionの削除IFはない.  collection内の全てのドキュメントがなくなったら自動で削除 Web UIから手動で削除      💡updateと set(merge:true)の違い    どちらもドキュメント内のフィールドを更新する方法. ドキュメント内のフィールドが存在しない場合の挙動に違いがある.\n updateの場合はエラーを返す. set(merge:true)の場合はフィールドは自動で作成される.  以上を踏まえてパターン整理.\n doc がnot existの場合  doc新規作成  add/set     doc がexistの場合  doc上書き  set: docまるごと上書き   fieldが存在するとき  set{merge: true}: 与えられたフィールドのみ更新. 他は残す.   fieldが存在しないとき  update: 与えられたフィールドを更新.      💡timestamp対するbetweenなクエリ    whereと不等号ではなく, orderBy \u0026amp; startAt(startAfter) \u0026amp; endAt(endBefore)を利用する.\nFirestoreの基本概念: データモデル(DataModel)    ref: Cloud Firestore データモデル | Firebase Documentation\nドキュメントはストレージの単位. コレクションはドキュメントのコンテナ.\n非リレーショナルなドキュメントデータベース    Google Cloud公式ブログの記事でFirestoreの設計概念である非リレーショナルなドキュメントデータベースについての解説がわかりやすい.\nこの記事から推測するとコレクションやドキュメントのような概念は Firestore特有ではなくその一つ上の抽象概念であるドキュメントデータベースのもの.\n コレクション ドキュメント リファレンス サブコレクション  Cloud Firestore の使用経験がないユーザー向けの Firestore の説明 | Google Cloud Blog\nクエリ(query)    Firestoreに送信するリクエストのこと.\nリファレンス(Reference)    リファレンス(Reference)はデータベース内の場所を参照するだけのオブジェクト. リファレンスを作成してもネットワーク操作は実行されない.\n DocumentReference CollectionReference  Referenceに対して.getをするとSnapshotが手に入る.\nスナップショット(Snapshot)    スナップショット(Snapshot)はデータのオブジェクト. .getData()によってデータ本体(JSON)を取り出す.\nJavaのFirestoreに関わるクラスとメソッド    複雑すぎるな\u0026hellip;\n \u0026lt;Firestore\u0026gt;   .collection(\u0026lt;String\u0026gt;)\n \u0026lt;CollectionReference\u0026gt;  .listDocuments()  list of \u0026lt;DocumentReference\u0026gt;   .getAll()  list of \u0026lt;List\u0026lt;DocumentSnapshot\u0026gt;\u0026gt;   .document(\u0026lt;String\u0026gt;)  \u0026lt;DocumentReference\u0026gt;   .get() -\u0026gt; ここから以下は listDocuments()と同等.  \u0026lt;SettableApiFuture\u0026gt;  (futureから取り出す) clojure deref/@  \u0026lt;QuerySnapshort\u0026gt;  getDocuments()  list of \u0026lt;DocumentReferenece\u0026gt;                .document(\u0026lt;String\u0026gt;)\n \u0026lt;DocumentReference\u0026gt;  .get()  \u0026lt;ListenableFutureToApiFuture\u0026gt;  (futureから取り出す) clojure deref/@  \u0026lt;DocumentSnapshot\u0026gt;  .getData()  java.HashMap   .getId()                通信の観点で整理.\nReferenceは通信前, getによって通信がバックグラウンドで開始する.\nFutureは通信をバックグラウンドで実行のため通信中. 通信結果はこの時点ではわからない. exists()などで結果を確認しないといけない.\nSnapshotは通信後. データはkey-valueのペアのため, getId/getDataでそれぞれアクセス.\nFirestore: データの関係(Relationship)    Firestore キー(or ID)    あるドキュメントの参照として別のドキュメントを示すkeyやidをStringで保持する.\nこれが普通の発想でありFirestoreというドメインに特化していない. 残りの2つはFirestoreの独自機能なので便利である分注意も必要.\nFirestore サブコレクション(Subcollection)    ふたつのコレクションが親子関係にあり, 子のコレクションは1つの親にのみ依存するならばサブコレクションをつかうことでツリー構造に管理できる.\nFirestore 参照型(reference type)    他のコレクションやドキュメントへの参照を保持することができる. SQLにおける外部キーの概念.\n参照型をつかうとidよりも格納されているものが明確できる.\n💡考察: データはそのままデータとして扱いたい    ClojureのData as dataのconceptからすると jsonをそのまま格納したほうがsimpleなので, ドメインに依存する参照型はあまり積極的に使う理由はないな. マップの中のマップは見かけるのでサブコレクションは形容できる.\nセキュリティルールも考慮に入れる必要あり.\n設計哲学的に迷ったらよりシンプルな方法を採用したい.\nFirestore: DB設計のベストプラクティス    FirestoreのDB設計は正解はないが指針やベストプラクティスがある.\n 更新頻度によってデータを分ける. セキュリティによってデータを分ける. 速度を優先するなら非正規化, そうでなければ(保守を優先するなら)正規化. データの結合はクライアントで行う(Application Side Join)  Google Firebase公式のデータ構造選択の指針\nデータ構造の選択 | Firebase Documentation\n ドキュメント内のネストデータ  時間経過とともに変化しないものならこれがいい, read only.   サブコレクション  時間経過とともにデータが大きくなる場合はこれ. サブコレクションはかんたんに削除できない(自力で削除).   ルートレベルのコレクション  全てルートにコレクションを配置, サブコレクションは使わない.    FirestoreはNoSQLの仲間なのでNoSQLのベストプラクティスが参考になる.\nNoSQLデータモデリング技法\nFirestore: DB操作のベストプラクティス    Firebase公式のベストプラクティスのドキュメント.\nBest practices for Cloud Firestore\n🎓フィールドが存在しないときの書き込みの挙動    RDBの慣習で新規作成と更新でcreated_at, updated_atをフィールドに持つことを想定するとする. このとき更新をかけようとするとcreated_atは更新せずにupdated_atに現在のタイムスタンプを入れたい.\nこのような存在しない場合のみ上書きの挙動はfirestoreではサーバ側の判定ではなくアプリ側でgetによってdocumentReferenceを取得してexist判定をするしかない.\nそもそもRDBの慣習であるcreated_at, udpated_atというものはNoSQLでは不要なのかもしれない.\n💡複数フィールドへのwhereとorderByは複合インデックスを貼る    Firestoreの制約で絞り込んでから並び替えはできない(where -\u0026gt; orderby). 並び替えてから絞り込みはできる(orderby -\u0026gt; where). where A-\u0026gt; orderby Bをしようとしたら, where A -\u0026gt; orderby A -\u0026gt; orderby BというようにdummyのソートをAにかけてさらにAとBの間に複合インデックスを貼る.\nAのフィールドに対して並びかけをしてBのフィールドに対して条件による絞り込みをする場合, AとBの間に複合インデックスをはらないとエラーする.\nINVALID_ARGUMENT: inequality filter property and first sort order must be the same: actress_count and last_crawled_time ref. Cloud Firestore でデータを並べ替えたり制限する | Firebase\n🎓 Firestoreサーバサイドの複雑なクエリに期待しない    それほど使い込んだわけではないので個人的な所感.\n複雑なロジックによるDB操作は基本的にクライアント側で実装する.\n複数フィールドに対する並べ替えや絞り込みや, 複数コレクションに対するクエリとマージはRDBの常識は通用しない.\nFirestoreにはいろいろな制約事項があり, たしかにStackOverflowを漁れば裏技は見つかるかもしれない. しかし基本的にはwhereである程度のシンプルな絞り込みをしてクライアント側にデータを取得してそこからゴニョゴニョしたほうが結果的に早く問題解決に至れる.\nFirestore: 命名規約    Firestoreの命名規約に関する明確なドキュメントは見当たらなかった.おそらく開発言語の命名規約に従うのがいい.\n複数言語で開発する場合は, Cloud APIsのドキュメントに従うことにする. これはおそらくJavaの慣習.\n命名規則 | Cloud APIs | Google Cloud\n コレクション/ドキュメント  複数形の単語 or 複合語 アメリカ英語のスペルとセマンティクス(not イギリス英語). ex. events, children, deletedEvents   フィールド名  snake_case(lower_case_underscore_separated_names)推奨. 前置詞を含めないことが推奨  reason_for_error よりも error_reason. cpu_usage_at_time_of_failure よりも failer_time_cpu_usage.   後置形容詞を使用しないことも推奨  items_collected よりも collected_items objects_importedよりも imported_objects     タイムスタンプ  タイムゾーンやカレンダーに関わらずgoogle.protobuf.Timestampが推奨. start_time, end_timeのように, 末尾にtimeをつけることが推奨. google.type.Dateと_dateのprefix推奨.   ソフトウェア開発での慣習的略語があればそれを推奨.  config/id/spec/stas\u0026hellip;    🏷命名規約\nFirestore Error Messages    トラブルシューティングとその対処についてまとめ.\nINVALID_ARGUMENT: value for xxx is too large to be used in a query    timestampの昇順データに対する where \u0026lt; による終わりからはじめへの検索で発生. おそらく降順データに対する where \u0026gt; でも発生.\nクエリ対象のデータか大きすぎる.\nActive Recalls    Firestoreのリファレンスとスナップショットの違いはなんですか？    リファレンスはクラウド上のデータへのパスの参照.\nスナップショットはローカルのデータとメタデータを合わせたオブジェクト.\n両者の違いはネットワーク通信をするかどうか.\nFirestoreデータ更新で updateと set({merge:true})の違いはなんですか？    ドキュメントのフィールドを更新するときのフィールドの有無で挙動が変わる.\nフィールドが存在しないとき, updateはエラーするがset{{merge:true}}は自動で追加される.\n"},{"id":138,"href":"/notes/20220411211559/","title":"📝Google Indexing API","parent":"🎓Keido HOME","content":"up: 📁Google Cloud\nGoogle Indexing APIとは    Googleのクローラーにサイトを巡回してもらうようにリクエストを送るAPI.\nIndexing APIでできることは，\n URLを更新する URLを削除する リクエストのステータスを取得する インデックス登録の一括リクエストを送信する  これらの操作はGoogle Search ConsoleからWebUIでできる.\nしかし操作をリクエストしても実際にGoogleが対応してくれるかどうかはわからない. うわさだとIndexing APIで直接URLを指定するとあっという間にクローラーが対応してくれるとか.\n実際, 私のサイト はGoogle Search Consoleから何度サイトマップを送信しても３ヶ月以上シカトされている.\nIndexing APIの使い方    他のGoogle Cloudのサービスと同様に予めサービスアカウントを登録してそれに紐づくcredentialsを利用して認証してAPIをつかう.\nRESTと各種言語のクライアントSDKでAPIを叩ける.\n具体的なRESTの送信方法は以下を参照.\nref. Indexing API の使用\nbatchリクエストについてはgoogle-api-clientで提供されているbatch機能と組み合わせて使うことが必要.\nReferences     Indexing API クイックスタート REST Resource - RESTの使い方Spec googleapis/google-api-java-client - Java Client  Google APIs Client Library for Java   google-api-services-indexing/v3 - GitHub  google-api-clientを使いやすくしたものだがドキュメントほぼないので今はapi-clientをつかったほうがよさげ.   🖊クソブログでもIndexing API をClojureから叩いてGoogle検索で表示されたい！ | Futurismo  "},{"id":139,"href":"/notes/20220103071935/","title":"📝GTD","parent":"🎓Keido HOME","content":"Getting Things Done.\n"},{"id":140,"href":"/notes/20220324072101/","title":"📝HTTP Protocol","parent":"🎓Keido HOME","content":" tags  🏷Protocol   refs.  Hypertext Transfer Protocol - Wikipedia    HTTP Protocolとは    Hypertext Transfer Protorolの略.\nHTTP Header    💡application/jsonにおけるAccept と Content-Typeの違い    AcceptはClientがどんなデータを処理できるかを示す.\nContent-Typeはどんな形式のデータを送信したかを示す.\n Accept  {\u0026ldquo;Accept\u0026rdquo;: \u0026ldquo;application/json\u0026rdquo;} サーバがクライアントにデータをレスポンスするときの情報. 特に指定がなければ通常text/textを好む慣習がある.   Content-type  {\u0026ldquo;Content-Type\u0026rdquo; \u0026ldquo;application/json\u0026rdquo;} GET Requestでは不要, Post Requestでは必須.  具体的には POST requestにおけるbodyのデータ形式を指定.      HTTP GET    クエリ文字列    WebブラウザなどがWebサーバに送信するデータを送信先を指定するURLの末尾に特定の形式で表記したもの.\n以下は全て同じ.\n クエリストリング(query string) GETパラメータ(GET parameter) URLパラメータ URLクエリパラメータ  URLの末尾に「?」（クエスチョンマーク）を付け, 続けて「名前=値」の形式で内容を記述する. 値が複数あるときは「\u0026amp;」（アンパサンド）で区切り「?名前1=値1\u0026amp;名前2=値2\u0026amp;名前3=値3」のように続ける.\nActive Recalls    HTTP Headerのapplication/json指定でAcceptとContent-Typeの違いはなんですか？    Acceptはクライアントがどんなデータ形式を扱えるかをサーバに示す.\nContent-Typeは実際にどんなデータを送信したかを示す.\nHTTP GETや POSTでパラメータを送信するときにつかう仕組みをそれぞれなんといいますか？    GETはクリエ文字列, POSTはリクエストBody.\n"},{"id":141,"href":"/notes/20220303203801/","title":"📝Java","parent":"🎓Keido HOME","content":"refs: 🏷Programming Language\nJavaとは    ジェームズ・ゴスリン - Wikipedia が開発.\n"},{"id":142,"href":"/notes/20220214041613/","title":"📝JVM Base Concepts","parent":"🎓Keido HOME","content":"refs: 🏷JVM\nJAR    JAR    Java ARchiveの略. Java Classファイルとメタデータをアーカイブしたもの.\n  Using JAR Files: The Basics (The Java™ Tutorials \u0026gt; Deployment \u0026gt; Packaging Programs in JAR Files) jar - Java Archive ツール  UberJAR    生産物のJarだけでなく依存関係のjarも含むjarの塊.\nJavaをつかってスタンドアロンアプリケーションとして起動することができる.\n\u0026gt; java -jar exampleapp.jar\nJavaのソフトウェアを配布しようとしたときにサードパーティの依存ライブラリも含めてまとめて配布(all-in-one)できるというメリットがあるものの, 冗長が多くなったり容量が大きくなるなどのデメリットもある.\nfat JAR, JAR with dependenciesともいう. Uberはドイツ語でOverの意. UberEatsとは無関係.\n  Uber-JAR - imagej java - What is a shaded jar? And what is the difference/similarities between uber jar and shaded jar? - Stack Overflow  Active Recalls    UberJARとはなんですか？    依存関係のJARを含む全てのJARファイルをまとめた単一のJARファイル.\n"},{"id":143,"href":"/notes/20211211065603/","title":"📝Lisp Base Concepts","parent":"🎓Keido HOME","content":"refs: 🏷Lisp\nLispとは    LISPとも表記する. その意味は，LISt Processing.\n🔗LISP - Wikipedia\nLISPは神である     神曲: Land of Lisp- The Music Video! - YouTube Lispはなぜ神の言語と呼ばれるのか - SEむううみんのプログラミングパラダイス Lispは神の言語:Geekなぺーじ  https://www.gnu.org/fun/jokes/eternal-flame.html    ハッカーにになろう - エリック・レイモンド\nそれをモノにしたときにすばらしい悟り体験が得られるのです。この体験は、その後の人生でよりよいプログラマーとなる手助けとなるはずです。たとえ、実際には LISP そのものをあまり使わなくても。\nLispは力である     Beating the Averages  LISP Macro    "},{"id":144,"href":"/notes/20220310060216/","title":"📝Lispの思想","parent":"🎓Keido HOME","content":"🏷Lisp 🏷Programming Language Design\nLISPは神である     神曲: Land of Lisp- The Music Video! - YouTube Lispはなぜ神の言語と呼ばれるのか - SEむううみんのプログラミングパラダイス Lispは神の言語:Geekなぺーじ  https://www.gnu.org/fun/jokes/eternal-flame.html    ハッカーにになろう - エリック・レイモンド\nそれをモノにしたときにすばらしい悟り体験が得られるのです。この体験は、その後の人生でよりよいプログラマーとなる手助けとなるはずです。たとえ、実際には LISP そのものをあまり使わなくても。\nLispは力である     Beating the Averages  "},{"id":145,"href":"/notes/20220311163333/","title":"📝NoSQL","parent":"🎓Keido HOME","content":"No SQL.\ncf. 🏷RDB\nNoSQLとは    非リレーショナルデータベースの総称.\nそれぞれの設計思想があるが, だいたい以下の4つに分類できる.\n 列ファミリー ドキュメント  Firestore   Key-Value グラフ  NoSQLの特徴    スキーマレスDB    スキーマが必要ではないデータベース. 暗黙スキーマ.\n投入したデータに合わせてデータカラム（フィールド）の形式を自由に変更できる. データを投入する前のスキーマ設計に関わる手間を減らすことが可能.\nApplication Side Join    Application Side Join, またはClient Side Joinともいう.\nJoinはNoSQLではほとんどサポートされない. そのため2つの集合のデータはアプリケーションて行う.\nドキュメントデータベース    ref: Cloud Firestore の使用経験がないユーザー向けの Firestore の説明 | Google Cloud Blog\nNoSQLのDB設計    NoSQLデータモデリング技法\n💡Application Side(Client Side) Join vs 冗長化モデリング    複数のコレクションの情報を元にデータを処理したい場合, Firestoreではクライアントから２つのクエリでデータを取得して処理する方法が考えられる. RDBのようにサーバ側でSQLの中でマージ処理ができないので.\nまたは別の考え方で１つのコレクションにデータの冗長を許して別のコレクションの情報を予めいれておき１回のreadで読むという冗長化の考え方がある. これはアプリケーションのユースケースに大きく依存する.\n  Refs.  KomercoとFirebaseの話 - クックパッド開発者ブログ Application Side Join    "},{"id":146,"href":"/notes/20211211071525/","title":"📝Org-mode","parent":"🎓Keido HOME","content":"🏷Emacs\norg-capture    アイデアを素早くorg-modeのノートにメモするための機能.\nhowto: Google Chomeの閲覧内容をorg-captureするには?    org-protocol と Chrome ExtentionのOrg Capture を利用する.\n仕組みとしては，Chromeにインストールした拡張機能がorg-protocolというMIME type(アプリケーションを識別する体系)を発行するので，それをemacsclientで受け取って処理をする.\n具体的にはemacslicentのデスクトップアプリケーションを作成して，org-protocolを処理するデフォルトアプリケーションでそのアプリケーションを指定.\nManjaro Linuxの例(xfce)    ~/.local/share/applications/emacsclient.desktop作成\n[Desktop Entry] Name=Emacsclient Exec=emacsclient %u Icon=emacs Type=Application Terminal=false MimeType=x-scheme-handler/org-protocol ~/.config/mimeapps.listに x-scheme-handler/org-protocol=emacsclient.desktop を追記.\nupdate-desktop-databbaseをコマンドラインから実行.\norg-captureの設定例.\n(\u0026#34;p\u0026#34; \u0026#34;browser\u0026#34; entry (file \u0026#34;~/gtd/inbox/inbox.org\u0026#34;) \u0026#34;* %^{Title}\\nSource: %u, %c\\n #+BEGIN_QUOTE\\n%:initial\\n#+END_QUOTE\\n\\n\\n%?\u0026#34;) (\u0026#34;L\u0026#34; \u0026#34;browser link\u0026#34; entry (file \u0026#34;~/gtd/inbox/inbox.org\u0026#34;) \u0026#34;* %? [[%:link][%:description]] \\nCaptured On: %U\u0026#34;) ポイントはorg-captureのトリガキーをpとLにすること.これはorg-capture-extensionなのでこれを守らないと動かない.もしくは自分でブックマークレットを作成する.\nlearn more\n Org-Protocol XDG MIME Applications - ArchWiki https://github.com/sprig/org-capture-extension  org-babel    🏷Literate Programming\norg-mode内にコードを埋め込み実行する.\nob-restclient    org-modeのファイル上でREST clientをインタラクティブに操作できる.\n https://github.com/pashky/restclient.el https://github.com/alf/ob-restclient.el  ある意味最強のREST Client.\nうかつに実行したら戻ってきたらが大量のデータた場合にEmacsがハングする.\n \u0026ldquo;:results none\u0026rdquo; で 出力抑止. \u0026ldquo;:results output silent\u0026rdquo; で minibufferのみに出力.  🔗References     🔗Web操作手順書を自動生成！Emacs org-babelで実現するRun Book Automation(RBA) | Futurismo 🔗org-babel と R の組み合わせがとても心地よい件 | Futurismo  "},{"id":147,"href":"/notes/20211204183600/","title":"📝Org-roam","parent":"🎓Keido HOME","content":"EmacsでZettelkasten Methodを実現するためのOrg-mode実装.\nOrg-roam まとめ    Org-roamを解説した有料記事      An Orgmode Note Workflow - Rohit Goswami\nOrg-roam-bibtexやOrg-noterと連携した文献管理方法を解説.\n  How I note\nOrg-roamでZettelkastenを実現するための方法を解説.\nref: How I note\n  Org-roamから生成したサイトまとめ    a.k.a. Digital Garden.\n https://commonplace.doubleloop.net/  How I publish my org-roam wiki with org-publish - doubleloop   https://braindump.jethro.dev/ https://braindump.badykov.com/about/  My Braindump - Kraken of Thought https://github.com/ayrat555/braindump   https://www.alexeyshmalko.com/ https://notes.alexkehayias.com/ https://hugocisneros.com/notes/  My Org-roam Notes Workflow - Hugo Cisneros   https://seds.nl/notes/ https://github.com/bphenriques/knowledge-base https://wiki.nikitavoloboev.xyz/  Org-roam Tips    Org-roamのノートをサイトに公開するには?    org-publishかox-hugoを利用するのが一般的.\n org-publish を用いてOrgファイルをHTMLに変換して公開. 📝ox-hugo を用いてHugo用のMarkdownに変換してHugoで公開.  将来的にはorg-roamやorg-roam-uiでpublishの機能がサポートされる可能性あり(2022).\nExternal Links     Publishing Org-mode files to HTML Org-roam User Manual Build Your Website with Org Mode - System Crafters Publishing org-roam-ui · Discussion #109 · org-roam/org-roam-ui · GitHub  howto: Org-roamの検索であいまい検索(fuzzy find)するには？    affeをつかう.\nhttps://github.com/minad/affe\n参照     📝Emacs 📝Zettelkasten Method  "},{"id":148,"href":"/notes/20220313164122/","title":"📝Overtone","parent":"🎓Keido HOME","content":"Clojure製Sound Programming Library.\n🏷Clojure\nむかしすこし試した. またやりたいと思っている.\n Emacs でテクノを奏でる?! overtone 連携 と Emacs Live と を試す | Futurismo Clojure で楽器を演奏しよう! Overtone をインストールしてみた | Futurismo  References     illiichi  俺のlisp - YouTube    "},{"id":149,"href":"/notes/20211231044406/","title":"📝ox-hugo","parent":"🎓Keido HOME","content":"Org-modeからHugoに適したMarkdownとfrontmatterを出力するためのEmacs Package.\nref: 🗒Keido Tips\nox-hugo Tips    howot: exportをスキップする方法    ref: https://ox-hugo.scripter.co/doc/tags-and-categories/#marking-files-to-not-be-exported\n file baseでは，#+hugo_tags に noexport subtree baseでは，#+filetags に noexport  org-export-exclude-tagsに除外対象のタグを設定する.\nhowto: ox-hugoで画像を記事に埋め込むには?    ox-hugoは/staticをrootにして画像を探すので，パスは/staticからの相対パスで書く.\nox-hugoはOrg fileに添付された画像をExportするときに自動でMarkdownファイルと同じディレクトリに配置してくれる.これは管理上とても楽である.\n参考: Images in Content — ox-hugo - Org to Hugo exporter\n"},{"id":150,"href":"/notes/20220305075933/","title":"📝Programming Base Concepts","parent":"🎓Keido HOME","content":"up: 📂プログラミング\nProgram: プログラム    プログラム (コンピュータ) - Wikipedia\nパラダイムによって, 定義がことなる.\n 命令型パラダイム \u0026hellip; コンピュータが行うべき命令の列 オブジェクト指向型パラダイム \u0026hellip; オブジェクトとメッセージング 関数型パラダイム \u0026hellip; 関数そのもの.  SICP より    プロセスは計算機のなかに潜む抽象的な存在. プロセスはもう一つの抽象的な存在, データを操作する. プロセスの進行は, 規則のパターン, プログラムにしたがう.\nプログラムは二つの要素をもつ.\n 手続き: データの処理方法 (能動的) データ: 処理したいもの (受動的)  Expression: 式    計算機の解釈系に渡される前の表現. 解釈系に評価されると, 式はプロセスになる.\nref: 式 (プログラミング) - Wikipedia\n言語によって定められた優先順位や結びつきの規定に則って評価される値, 変数, 演算子, 関数の組み合わせ.\nProcess: プロセス    プロセスは計算機のなかに潜む抽象的な存在. プロセスはもう一つの抽象的な存在, データを操作する. プロセスの進行は, 規則のパターン, プログラムにしたがう.\nプログラムに必要な資源のこと. (プログラム自体, データ, スタック, カウンタ, スタックポインタ, レジスタ, メモリなど)\n3 つの状態 (Run, Blocked, Ready) を持つ. 複数のプロセスを仮想的に並列に実行するものがプロセッサ.\nliteral: リテラル    即値 (英: Immediate) ともいい, ソースコード内に値を直接表記したもの.\nref: リテラル - Wikipedia\n静的に構文解析が可能なことが多い.\n変数の対義語. 変更されない値.\nvaluables: 変数    変数の構成要素は以下の 2 つ.\n 識別子 (Identifier) 格納域実体 (Store entity)  x = 1 ということはどういうことかを説明する概念.\n数学的な写像関係で x = 1 を説明しようとしている. { X -\u0026gt; x1=1 }みたいな感じ. x1 がメモリ上の実際の (束縛された) 値で, X がそれを指し示す識別子.\nIdentifiers    識別子 (Identifier)\nStore Entity    格納域実体 (Store entity)\nEnvironments    識別子と変数の写像関係を環境という.\n a collection of (symbol, value) pair. environment has a parent environment, possible to have multiple children. a function + an environment = a closure  Global Environments    どこからでも参照できる environments.\ntop environment, すべての親となる environments.\nSingle-Assignment Store    単一代入格納域. 一度一つの値を束縛したら変更できない変数の集合.定数.\n関数型プログラミングでは, この変数が当たり前.\nbindings    変数束縛.\nType: 型    データ構造・型のページへ移動\nTODO: githubから移植.\nScope: スコープ    Valiable の有効範囲.\nref: スコープ - Wikipedia\nScoping Rules - スコープの範囲\nLexical Scope: 静的スコープ    refs: 静的スコープ - Wikipedia\n変数はブロックの内側のみ有効.\nLexical Scope, Static Scope とも. 字句的スコープともいう.\n free valuables are searched for in the environment in which the funcition was defined.\n ブロック構造 (block Structure)    手続きの仮引数は局所的である. 関数の定義は局所的でない.\n手続きをブラックボックスにするためには, 利用者に必要のない関数は隠蔽する必要がある.\n定義の入れ子を ブロック構造 という. ブロック構造の中で定義された関数は局所的である.\nできるだけブロックを利用することで巨大問題を, 扱える部品に分割できる.\nSICP p17 より.\nR example    Scope の外への戻り値は, Scope 内部の関数のコピーである.\n# from R Programming coursera. make.power \u0026lt;- function (n) { pow \u0026lt;- function (x) { x^n } pow } cube \u0026lt;- make.power (3) square \u0026lt;- make.power (2) Dynamic Scope: 動的スコープ    Emacs Lisp は ダイナミックスコープを採用している.\n Emacs Lisp は, アプリケーション・プログラミングで使われる方言群である Scheme や Common Lisp とは根本的に異なる. 大きな違いの 1 つは, デフォルトで字句的スコープではなく動的スコープを使うことである. つまり, 呼出し関数の局所変数は, ポインタや参照を渡さなくとも, 呼び出された関数から参照できる.\n  動的スコープ - Wikipedia Emacs Lisp - Wikipedia レキシカルスコープとダイナミックスコープ | すぐに忘れる脳みそのためのメモ  State: 状態    State (状態) とは, 必要とされる計算の途中結果を含む, 値の時系列. (sequence of values calculated progressively, which contains the intermediate results of a computation)\n状態の導入によって, プログラムに時間の概念を与える.\nmodular    ある部分を変更しても, 別の部分には変更が加わらないとき, それをモジュール性という.\nFunction Paradium ではできない. State があればできる.\nEvaluation Strategy    評価戦略. Substitutonal Rule (代入規則) とも.\nプログラミング言語や, ラムダ計算のような式から成る計算模型において, 如何なる手順で, 評価すなわち式から値を得るか, という (通常決定的な) 規則群.\nref: 評価戦略 - Wikipedia\n Call-by-Name (名前呼び) Call-by-Value (値呼び) Call-by-Ref (参照呼び)  Haskell    2 つの評価方法があり, どちらを選択しても, 最後の結果が変わらないという性質がある.\n InnterMost Reduction: 最内簡約  内側から評価する. 評価対象が複数ある場合は, 左から評価する.   OuterMost Reduction: 最外簡約  外側から評価する. 評価対象が複数ある場合は, 左から評価する.    Lazy Evaluation: 遅延評価    Haskell の評価戦略.\n Outermost Reduction + shareing.  未整理 SICP より.     正規順序 (normal-order evaluation)  演算子と非演算子を評価. 演算子評価結果の手続きを非演算子評価結果の引数に作用させる.   作用素的順序 (applicative-order evaluation)  その値が必要になるまで, 非演算子を評価しない. 遅延評価??    糖衣構文 | SyntaxSuger    ref: 糖衣構文 - Wikipedia\nプログラミング言語において, 読み書きのしやすさのために導入される構文であり, 既に定義されている他の構文の (人間にとってより理解しやすい)書換えとして定義されるもののこと.\n例外 | Exceptions    プログラムがある処理を実行している途中で,なんらかの異常が発生した場合に, 現在の処理を中断 (中止) して, 別の処理を行うこと. その際に発生した異常のことを例外と呼ぶ.\nref: 例外処理 - Wikipedia\nよくある 2 つの概念.\n try: 例外ハンドラをもつ例外補足コンテクストを生成. raise: もっとも内部の例外補足コンテキストへ jamp し, そこにある例外ハンドラを起動.  各コンテキストはスタックで管理され, try はスタックの 1 つに marker をつける. raise は marker にジャンプして marker の場所に例外処理のコンテキストを挿入する.\nCTMCP p93 参照.\n例外の種類     Asynchronous Exceptions: 非同期例外 Synchronous Exceptions: 同期例外  Traps: 意図的に OS が止める breakpont, systemcall, file open Faults: リカバリ可能な例外, page fault, segmentation fault Aborts: リカバリ不可能な例外, プログラムは強制終了.    💡例外がないと戻り値チェックでうんコード    例外をつかわないと, コンテクストごとの結果を検証必要があり, return 文 と case 文が乱立するうんこコードが出来る.\n例えば, 下位のコンテキスト (A) で発生したエラーは, return -\u0026gt; return -\u0026gt; して上位でも戻り値のエラーチェックが必要.\n#define ERROR -1 #define OK 0  int main (void) { if (C ()==ERROR) { printf (\u0026#34;Error\\n\u0026#34;); } } int A () { return ERROR; } int B () { if (A () == ERROR) { return ERROR; } else { return OK; } } int C () { if (B () == ERROR) { return ERROR; } else { return OK; } } Function: 関数    関数.\nパラダイムによって呼び方や定義が異なる.\n 手続き型: procedure オブジェクト指向: method 関数型: function  手続き型パラダイム: procedure | プロシージャ    戻り値つきのサブルーチン. C 言語 など.\nref: C 言語 - Wikipedia\nプログラム中で意味や内容がまとまっている作業をひとつの手続きとしたもの.\n サブルーチン - Wikipedia  手続きにつけられたラベル.アセンブラのラベルと同義. (ref: 関数プログラミング実践入門)\nオブジェクト指向パラダイム: method | メソッド    あるクラスないしオブジェクトに所属するサブルーチン.\nref: メソッド (計算機科学) - Wikipedia\n各オブジェクトが持っている自身に対する操作. オブジェクトは「データ」と「手続き」から成っているが, その「手続き」の部分に当たる.\nref: メソッドとは 〔 メンバ関数 〕 【 method 】 - 意味/ 解説/ 説明/ 定義 : IT 用語辞典\n関数型パラダイム: function | 関数    関数は, ある型の引数を他の型の引数の結果に変換する. 型とは, 互いに関連する値の集合.\nref: プログラミング Haskell: Graham Hutton\n数学に置ける関数の概念に近い. ある集合から集合への写像.\nref: 関数 (数学) - Wikipedia\nCTMCP での定義    Procedure is a procedure value with a contextual environment.\nSince procedures (and functions) are values, we can pass them as inputs to other functions and return them as outputs.\nSICPでの定義     Processs (プロセス)  計算機のなかに潜む抽象的な存在.   Procedure (手続き・プロシージャ)  データの処理方法.    データにたいして繰り返しで処理をおこなう方法には, 再帰的処理と反復的処理がある.\nRecursive: 再帰的    計算を実行するためには, 以前の計算結果を覚えておく必要がある. 計算効率と空間効率は x の大きさに比例する.\nこれを, 線形再帰プロセスという.\n;; applicative-order evaluation ;; linier recursion (defun plus (x y) (if (= x 0) y (1+ (+ (1- x) y)))) Iterative: 反復的    計算効率は, 入力値に比例する. 空間効率は, 一定.\nこれを線形反復プロセスという.\n;; normal-order evaluation ;; linier iteration (defun plus (x y) (if (= x 0) y (+ (1- x) (1+ y)))) 以下からなる.\n 状態が一定個数の状態変数 状態が移ったときに状態変数をどう変化させるかの規則 プロセスを終了させる条件.  関数の引数    いろいろ種類があり名前がつけられている.\n位置引数    デフォルト引数    キーワード引数    可変長引数(オプション引数): Variadic Variable    可変長引数. Variadic=可変長.\nオプション引数とも.\n"},{"id":151,"href":"/notes/20220310170617/","title":"📝Relational Database技術","parent":"🎓Keido HOME","content":"📂Software Development Domains\nO/R mapper(ORM)    Object-Relational Mappter, ORM.\nオブジェクト指向言語においてオブジェクトとデータベースの間の関係を定義するだけで, データベースアクセスが行える仕組み.\nrefs:\n O/Rマッピング（O/Rマッパー）とは - IT用語辞典 e-Words 🏷OOP  "},{"id":152,"href":"/notes/20211227052646/","title":"📝Sphinx","parent":"🎓Keido HOME","content":"Python製のドキュメント作成エンジン及びサイト.\nSphinx Tips    howto: SphinxのThemeを変更するには?    read: テーマの変更 — Python製ドキュメンテーションビルダー、Sphinxの日本ユーザ会\ntip: MarkdownでSphinxドキュメントを書く方法    MyST-Parserという拡張を利用する.\nnote: recommonmarkを使う方法は情報が古い(2021)\nlinks\n Markdown — Sphinx documentation - 公式 Get started with MyST in Sphinx - MyST公式によるSphinx導入方法  tip: Emacs Org-modeでSphinxドキュメントを書く方法    howto: Emacs Org-modeからreSTファイルを生成するには?    ox-rstをつかう(https://github.com/msnoigrs/ox-rst).\norg-exportの項目としてreSTへの出力を組み込むことができる.または，M-x org-rst-export-to-rst コマンドでOrg fileをreST file変換して出力することが可能.\nox-rstで出力されるフォーマットを細かく設定するには，org-modeのexport設定をする必要がある(https://orgmode.org/manual/Export-Settings.html).\nたとえば，\n author:nilで, authorのexportを抑止. num:nilで, headlineのナンバリングを抑止.   #+OPTIONS: author:nil num:nil howto: ox-rstをCLIから実行するには?    emacsをバッチモード\nemacs $1 --batch --eval=\u0026#34;(load \\\u0026#34;~/.emacs.d/.local/straight/repos/ox-rst/ox-rst.el\\\u0026#34;)\u0026#34; -f org-rst-export-to-rst --kill link: https://github.com/msnoigrs/ox-rst/issues/55#issuecomment-917417497\nhowto: Emacs Org exportのフォルダを指定するには?    EXPORT_FILE_NAME をファイルヘッダに設定する.\n#+EXPORT_FILE_NAME: ~/repo/futurismo-wiki/sphinx.rst howto: Org fileの中にSphinxの文法を書くには?    BEGIN_EXAMPLE rst を書く.\n-- #+BEGIN_EXPORT rst -- .. class:: alert -- #+END_EXPORT howto: SphinxをNetlifyにHostingするには?    Sphinxはビルドで生成される~_build/html~をそのまま公開すればNetlifyでホスティングできる. この方法の嬉しいところは，Netlifyを利用することでホスティングが無料でできるということだ.\nbase directoryに requirements.txtとruntime.txtを配置する.\n$ cat requirements.txt sphinx $ cat runtime.txt 3.8 あとは，~sphinx-build {source dir} {dest dir}~のコマンドを実行すると，_build/html相当のものが{dest dir}にできる. これを，Deploy settingsのbuild commandに設定すればよい.\nlink: Manage build dependencies | Netlify Docs\nnotes: package.jsonをつかった自動化の例    参考までに，わたしはpackage.jsonを配置することで，npm scriptでビルドを走らせることにした.\n{ \u0026#34;scripts\u0026#34;: { \u0026#34;hugo\u0026#34;: \u0026#34;hugo\u0026#34;, \u0026#34;wiki\u0026#34;: \u0026#34;sphinx-build wiki public/wiki\u0026#34;, \u0026#34;deploy\u0026#34;: \u0026#34;npm run hugo \u0026amp;\u0026amp; npm run wiki\u0026#34; } } howto: SphinxにGoogle Analyticsを埋め込むには?    テーマのlayout.htmlをコピーしてオリジナルのlayout.htmlを作成する.\nrootの下の_templatesにlayout.htmlというファイルを作り下記のように記載.\n{%- extends \u0026#34;!layout.html\u0026#34; %} {{ super() }} {%- block extrahead %} \u0026lt;!-- ここにGoogle Analyticsタグ追加 --\u0026gt; {% endblock %} link: Google Analyticsのタグを埋め込む — Sphinxを使ってみよう\nhowto: SphinxのページにGoogle Adsenseを貼り付けるには?    基本的には(howto: SphinxにGoogle Analyticsを埋め込むには?)に同じ. rootの下の_templatesに上書きしたいhtmlを作成する.\nlink: Google AnalyticsやGoogle Adsenceを貼りたい - Sphinxの日本ユーザ会\nexample: page.htmlやsearchbox.htmlの継承    たとえば，私の場合は Sphinx Basic Theme を利用しているので，GitHubから上書きしたpage.htmlとsearchbox.htmlをそれぞれコピーして_templates配下に配置して，以下のようにGoogle Adsenseのコードを追加した. 以下はpage.htmlの例.\n{%- extends \u0026#34;layout.html\u0026#34; %} {% block body %} {{ body }} \u0026lt;!-- ここにGoogle Adsenseタグ追加 --\u0026gt; {% endblock %} howto: Sphinxにサイトマップ(sitemap.xml)を追加するには?    sphinx-sitemapというextentionsを使う.\nlink: https://pypi.org/project/sphinx-sitemap/\n参照     Sphinx | Futurismo - 昔の私の記事だけど2014だから情報が古い.  参考文献     Sphinx documentation - 公式サイト(en)  Sphinx ドキュメント - 日本語はココ   sphinx-doc/sphinx - GitHub Sphinx-Users.jp - Sphinxの日本ユーザ会  "},{"id":153,"href":"/notes/20220301074527/","title":"📝Startup Online Courses","parent":"🎓Keido HOME","content":"Startupがオンラインで学べるコンテンツまとめ.\nup: 📂Startup\n  :pencil:Y Combinator  米国最強アクセラレーター. YC Startup Library | Y Combinator Y Combinator - YouTube Channel Found Xで日本語の翻訳情報が見れるのはよい.   Disciplined Entrepreneurship - Bill Aulet, MIT  edX:  Entrepreneurship 101: Who is your customer? | edX Entrepreneurship 102: What can you do for your customer? | edX Entrepreneurship 103: Show Me The Money | edX   MIT Bootcamps - YouTube Startupは学習可能との理念(なはず)なので当然教材開発にも熱心(なはず).   The SXtarup Owners Manual - Steve Blank  How to Build a Startup | Udacity Free Courses   Design Sprint - Google  Product Design | Udacity Free Courses Design Sprint Foundations | Udacity  最近nanodegree化されたのかな? 有料.     UTokyo Found X - 馬田隆明  特に馬田さんのスライドがよい.  https://speakerdeck.com/tumada/   スタートアップ入門者向け厳選記事 - FoundX Startup Resources FoundX Startup School Course | Coursera 東京大学FoundX - YouTube Channel   起業の科学 - 田所雅之  起業の科学・田所雅之 - YouTube Channel スライドは田所さんのTwitterとかみてると定期的に配ってる.    "},{"id":154,"href":"/notes/20220320182327/","title":"📝Stuart Sierra","parent":"🎓Keido HOME","content":" GitHub Clojureの状態管理ライブラリ, Component の作者. Reloaded Workflow を言い出した.  🏷Clojurians\n"},{"id":155,"href":"/notes/20220119143140/","title":"📝Tech系のアダルトサイト制作事例まとめ","parent":"🎓Keido HOME","content":"refs: 🏷個人開発 📝DMM Development\nなんか昔まとめた記憶もある.\nというより10年以上このテーマを追求している気が. 定期更新.\n驚異のFANZA女優検索(2021)     AzureFaceAPI  【個人開発】DMM.comの女優APIを使って約5万人の女優を検索できる驚異のサービスを作った - Qiita 👓メガネをかけたFANZA女優をピックアップした - Qiita 似た顔のFANZA女優を顔写真から検索出来るようにした - Qiita Calendar for 驚異のFANZA女優検索（ひとり） | Advent Calendar 2021 - Qiita https://fanza-actress-bust-search.azurewebsites.net/ https://github.com/fabsabsfabsabs/FanzaActressBustSearch\n💡なるほど，女優のTwitterアカウントはWikipediaからのスクレイピングか.\nTwitterとInstagramをやっているFANZA女優を一覧で表示するページを作った - Qiita\nAIで画像から似ている○○女優を解析するシステム(2020)    AIで画像から似ている○○女優を解析するシステムを作ってみた - Qiita\nサイトは終了\n Face API  AV半額オブザーバー(2020)    〇〇のセールを見逃さないサービス作りました。【AV半額オブザーバー】 - Qiita\n Vue.js Node.js  AVの作品名から特徴量抽出(2020)    AV女優の特徴ってなんだろう？作品名から推測してみた！(^_^)/~~ - Qiita\n WordCloud  AV女優判定(2020)    Google Cloud AutoML Vision で、10人の女優を識別する - Qiita\n Google Cloud AutoML  AVVRレビューサイト    DMMのAPIを使ってRailsとVue.jsでAVVRレビューサイトを10日くらいでサクッと作ってみた。 - Qiita\n Rails Vue.js  AVソムリエ(2018)    顔認識AI + LINEの新機能 でAVソムリエを作ってみた - Qiita\nFacenetを利用した類似AV女優検索(2017)    Facenetを使った類似顔画像検索のための特徴量抽出 - Qiita Facenetを使った類似AV女優検索 - Qiita https://av-face-search.herokuapp.com/\n Facenet(OpenFace)  chainerによるディープラーニングでAV女優の類似画像検索サービス(2016)    chainerによるディープラーニングでAV女優の類似画像検索サービスをつくったノウハウを公開する - Qiita\n Chainer  TensorFlowによるディープラーニングで、アイドルの顔を識別する(2016) - すぎゃーん     TensorFlow  TensorFlowによるディープラーニングで、アイドルの顔を識別する - すぎゃーんメモ\n"},{"id":156,"href":"/notes/20220124080358/","title":"📝Twitter API","parent":"🎓Keido HOME","content":"🏷Twitter\nTwitter APIまとめ.\n Twitter API Visual Documentation  v2    v1.1    💡その他考察    💡 statusという用語について    もしかしたらv2からはstatusという用語そのものが撤廃しようという動きがあるかも.\n一部の互換性のためところどころstatusという単語は属性に現れるものの, 全体的にほぼない.\nたしかにstatusというのは直感的にはそれがツイートと同一とはわからない. 逆に言えば, Twitter Developerでしかツイートをstatusとは言わないのでは？\nしかし元を考えれば, 当初は今の状態をつぶやくだけのサービスだったので, その用語は適切だったのかもしれない. これはTwitterの思想の論争につながる.\nref: いまなにしている? vs いまどうしている?\n"},{"id":157,"href":"/notes/20220307193727/","title":"📝Twitter Development with Clojure","parent":"🎓Keido HOME","content":"refs: 🏷Clojure 🏷Twitter 📝Clojure Web Development 📂Twitter Development\nTwitter API Client     twttr: Clojure Twitter Client  https://github.com/chbrown/twttr   twitter-api: Clojure Twitter Client  https://github.com/adamwynne/twitter-api    2022からTwitter API v2が正式になったので過渡期ではある. これはClojureに限ったことではない. 自分でv2対応してもいいし, Javaの資産を活用してもいい.\nClojure Twitter Bot Examples    GitHub repos    検索結果: https://github.com/search?l=Clojure\u0026q=Twitter\u0026type=Repositories\n https://github.com/akivascript/xyzzwhy  ファイル構成は参考になりそう.   https://github.com/mwunsch/sonic-sketches  未完のbotだけどaws s3に音声ファイルを送信したり apiで天気取得したり.   https://github.com/chr15m/c64core  cljsで作成されている. nbbというbabashkaのcljs versionを利用している.  https://github.com/babashka/nbb   pikuという謎のサーバ  https://piku.github.io/ private heroku的な.     https://github.com/yogthos/mastodon-bot  twitter/tumblrをmastodonに投稿するbot.  starの数は最大.     https://github.com/astavonin/news-bot  C++関連の情報を集めて投稿するClojure Bot AWS Lambdaを利用.   https://github.com/rogerallen/tweegeemee  自動で画像生成してTwitterに投稿. starが82もついてる. heroku利用.   https://github.com/borkdude/who-follows-me  web app  composureとかringとかつかってる.   片思いチェッカーみたいな. https://twitter.michielborkent.nl/   https://github.com/bzg/retweet  retweet監視    Blog Posts     DuctでSlack Botを作成する  TwitterからSlackへのリレー, Duct利用例. https://github.com/nijohando/chabonze   ring/compojureでサーバを始めてみる(入門編) part3 - Qiita Twitter4jでTweet取得  Clojure その１７ twitter4j を使ってみる - Sphereとともに Clojure その１８ twitter4j を使ってみる２ - Sphereとともに Clojure その１９ twitter4j を使ってみる３ - Sphereとともに  スレッディングマクロでリファクタリング. Clojure その２０ -\u0026gt;\u0026gt;（スレッディングマクロ） - Sphereとともに   Twitter4jでTweetを取得してcsvを作成してBigQueryに送信する例.  https://qiita.com/FScoward/items/d10a69f3fa94e9620ae2 (part1) https://qiita.com/FScoward/items/326479ba990c7c6d805e (part2)      Clojure Chatbot Example    TwitterではないがChatbot周りのブックマーク.\n https://github.com/liquidz/jubot  https://www.slideshare.net/masashiiizuka/clojure-chatbot Clojure で Slack の Bot を作ろう - Qiita   https://github.com/lagenorhynque/clj-slackbot ClojureでLINE BOTを作るためのSDKを作る - Qiita 女子力Bot - syobochim/jyoshiryoku-bot https://github.com/athos/applicosan https://github.com/athos/parabola  "},{"id":158,"href":"/notes/20220308065008/","title":"📝Twitter Histories","parent":"🎓Keido HOME","content":"refs: 🏷Twitter 📝Jack Dorsey 📝Elon Musk\n2022/04/06 イーロン・マスクがTwitter社の筆頭株主 \u0026amp; 取締役へ    なんとあのイーロン・マスクがTwitter社の取締役へ\u0026hellip;\n https://twitter.com/paraga/status/1511320953598357505 ツイッター イーロン・マスク氏が取締役に就任と発表 | NHK | IT・ネット ツイッター 投稿内容変更できる機能 数か月以内に試験導入へ | NHK | IT・ネット  -\u0026gt; 辞退した\nイーロン、Twitterの取締役就任を当日朝になって辞退 | ギズモード・ジャパン\nいまなにしている? vs いまどうしている?    2009/11, Twitterの問いかけが「いまなにしてる？」から「いまどうしてる？」に変わる. 英語表現だと, \u0026ldquo;What are you doing\u0026rdquo; to \u0026ldquo;What\u0026rsquo;s Happing\u0026rdquo;.\nこれは, Twitterの設計思想上の大きな変化.\n今なにをしている？は, 話題の中心は自分であり, 今をつぶやく. 今どうしている？は, 他者への情報発信であり, 将来をつぶやく.\nジャックドーシーは前者, エヴァン・ウィリアムズが後者. そしてエヴァンの支持する価値観が勝ち, ドーシーはTwitter社を去る.\nSNSとそれを支える広告ビジネスにおいては後者の思想のほうが圧倒的に儲かるだろう.\nrefs:\n Twitterの歴史と思想、4人の創業者たちのドラマ～Twitterはどこから来て、どこへ向かうのか～ Twitter、「いまなにしてる？」から「いまどうしてる？」へ | TechCrunch Japan  "},{"id":159,"href":"/notes/20220124053244/","title":"📝Twitter Private API","parent":"🎓Keido HOME","content":"🏷Twitter\nTwitterの非公式API情報まとめ.\nTwitter Private API解析     GET UserSessionList  https://twitter.com/settings/sessions セッションリスト取得   GET account/multi/list.json  https://twitter.com/i/api/1.1/account/multi/list.json ログイン中のアカウントを取得 おそらくauth_multiで判定.  response cookieにてauth_multiを確認.      References    Articles     TwitterScraperの代わりになるような情報収集モジュール作成しまし(Python3)｜神瀬来未｜note TwitterのフロントエンドAPIの使い方(Python3)｜神瀬来未｜note  twitter.com/i/という形式のAPIはheader情報(authorization, x-guest-token)を設定すると利用できる.   【Twitterスクレイピング】twintの代わりにstweetをインストール | ジコログ TwitterAPIめっちゃ調べてみた - Qiita TwitterをCookieで操作する - Qiita  https://www.libertyspecialtymarkets.com/static/2020-07/Liberty-specialy-markets-cookies.pdf 実行したいAPIの特定はChrome Developer ToolsのNetworkタブから Copy -\u0026gt; Copy as cURL(bash)を選択してそれっぽいものをコピー. https://curlconverter.com/ で別の言語に変換して実行.   Logic using cURL, PHP and Twitter without using API - Stack Overflow Cookieを使ってTwitterになりすまし投稿してみよう | すずきライフ How to Hack APIs in 2021 by Hakluke and Farah Hawa | Detectify Labs  SPAアーキの時代はPrivate API-based AutomationはWebdriver-basedによりも有利な時代になったという話. 最近のモダンなサイトはreact やvuejsをつかったspaモデルで構築されているためそのapiをpostmanで解析することで自動化は圧倒的にしやすい時代になった.  これは従来のhttpを解析して自動化するより効率的、なるほど.      Books     ハッカーの学校 ハッキング実験室 - 黒林檎(2017)  『ハッカーの学校 ハッキング実験室』公式サイト  Twitter非公開アカウントに関する情報収集      GitHub     https://github.com/hannahcooper716/oauth-twitter https://github.com/twintproject/twint https://github.com/markowanga/stweet https://github.com/KohnoseLami/Twitter_Frontend_API https://gist.github.com/stepney141/c161a83f02c42e161c905249733b9225  Others     🎓Web Private APIのハッキングは人間のツボを探求することだ  "},{"id":160,"href":"/notes/20220124080448/","title":"📝Twitter Scraping","parent":"🎓Keido HOME","content":"🏷Twitter\nTwitter Scrapingまとめ\nPlaywright は2022の銀の弾丸    セキュリティの会社ですらplaywrightを利用したbotの判定が今や難しい.\nhttps://datadome.co/bot-detection/will-playwright-replace-puppeteer-for-bad-bot-play-acting/\n Example of Twitter Automation.\nhttps://www.martinmcgee.dev/starting-microsoft-playwright/\n"},{"id":161,"href":"/notes/20220205072101/","title":"📝Twitter Technologies","parent":"🎓Keido HOME","content":"🏷Twitter\nTwitterの技術まとめ.\nどうもReactがWebフロントエンドな気がするのは気のせいか？\nTwitter Retweet ID    ref: TwitterでリツイートIDを調べる方法｜Guest｜note\nTwitter snowflake    TwitterのIDはsnowflakeというOSSを利用しているらしい(ref)\nhttps://github.com/twitter-archive/snowflake\n タイムスタンプ、マシンID, 同一マシン内でのシーケンスIDを元に64ビットの一意なIDを生成  IDから時系列比較可能. IDから時間の復元が可能. 69年でオーバーフロー.    ref: Twitterのsnowflakeについて\n"},{"id":162,"href":"/notes/20220410054748/","title":"📝Twitter ルール","parent":"🎓Keido HOME","content":"tags: 🏷Twitter\n主に以下の話題を扱う.\n 通知規制 シャドウバン アカウントロック アカウント凍結  Twitterの扱う個人情報について    Twitterの扱う個人情報についてまとめる.\nref. 個人情報の推測に基づくカスタマイズについて\nこれらの情報がさまざまな規制や凍結に利用されている.\nセッション情報    ブラウザの 設定 \u0026gt; セキュリティとアカウントアクセス \u0026gt; アプリとセッション \u0026gt;セッションから確認できる.\nhttps://twitter.com/settings/sessions\nこのページでブラウザリフレッシュをすると, UserSessionList というget requestが発行され, 現在のセッションが取得できる.\n 端末名 ブラウザ名 ログインの場所 最終ログイン時間  が表示されているということはその情報を保持していることをtokenと紐付けて管理していることを示す. cookieの認証情報の期限がログインから5年後を示しているとすると, ログアウトしない限り5年は保持されている可能性あり.\n 新規IPからログインをするとログイン通知がされる.\n 新規ログインDevice: ChromeにLinuxから Location*: 神奈 横浜市 中区, 日本 When: 2022年4月10日日曜日 at 午後2:18 GMT-7 (3 分前)*場所はログイン時のIPアドレスに基づいて推定されています。\n セッションとIPを紐付けて管理していてknown_hostsなIPに対して通知を出している可能性がある. ただしブラウザから通信を解析した結果IPがresponseとして帰ってきてはいない(session IDやtokenなどはある)ため, これはサーバ側でしか管理していない情報. ということは, クライアントからログインしたときに情報を意図的に保存しておかないとわからなくなってしまう.\nもしくはAndroid/iPhoneのアプリからのログインなら アカウントアクセス履歴 から閲覧可能(Twittr for Android/Twitter for iPhone).\nアカウントアクセス履歴    APIによるアクセス. すなわちAPIを介してアクセスする外部連携アプリや自分で開発したアプリのアクセス情報.\n連携アプリは以下からリストで見れる.\nhttps://twitter.com/settings/connected_apps\nアクセス履歴は以下.\nhttps://twitter.com/settings/your_twitter_data/login_history\np13n_data.jsonにて取得しているよう. ログイン情報はIPと時間が記録されている.\n login_history  app_name country ip time    おそらく情報の保持期間は3ヶ月(経験則).\nログインしている端末とアプリ    以下のrequest urlへのgetで取得できる情報.\nhttps://twitter.com/i/api/1.1/account/personalization/p13n_data.json\nおそらくcookieに埋め込まれたIDやuser-agentを解析した情報をサーバ側で管理しているが, 取得によって確認できるのはラベル付けされた情報.\n associated_devices  num_browsers num_devices    アカウントに紐付けられているブラウザとスマホの数.\nさらに詳細は known_devices, login_historyで管理されている.\n carrier_info  address: 電話番号 carrier_name: キャリア名(jp.au) created_at device_country_name: \u0026ldquo;Japan\u0026rdquo;    電話番号情報.\n この情報取得は設定によりDisableできる.\n-\u0026gt; 設定項目: 推測される識別情報をもとにカスタマイズ\n新規登録情報    p13n_data.jsonにて取得している情報.\n sign_up_details  creation_ip country    ここで注目スべきなのはcreation_ip. この情報を気をつけないと凍結 リスクが高まる.\nauth_token, auth_multi    Webブラウザアクセス時のcookieの中に保存される情報.\nおそらくauth_tokenがアカウントごとに割り当てられるものでauth_multiは複数アカウントでのログイン状態を制御する情報.\nFirefoxコンテナ技術を利用するとそれぞれのアカウントを独立させてログインすることができるのでauth_multiはcookieに保存されない.\nTwitterはどのようにしてアカウントや端末と個人情報を関連付けるのですか？     特定のブラウザや端末からTwitterにログインすると、Twitterは、そのブラウザや端末をTwitterアカウントに登録します。ユーザーがTwitterにログインしているかどうかにかかわらず、パートナーが情報を共有したときや、ユーザーがtwitter.comにアクセスしたとき、Twitterコンテンツを統合したサードパーティーウェブサイトにアクセスしたとき、Twitter広告主のウェブサイトやモバイルアプリケーションにアクセスしたときなどに、ブラウザや端末に関する情報がTwitterに送られます。Twitterは主にIPアドレスと情報を受け取った時間データから、特定のブラウザや端末、またはアカウントとの連携を予測します。\nメールアドレスを含むその他の情報をTwitterに提供すると、Twitterはその情報とアカウントを関連付けます。Twitterはそうした情報からその他の個人情報を推測する場合があります。たとえば、Twitterに提供されたメールアドレスと共通の要素が使われているメールアドレスのハッシュを、アカウントと関連付けます。\n  ログインに使ったことのある端末 ログインに使ったことのあるブラウザ 登録したメールアドレス 登録したメールアドレスに似ているメールアドレス  設定項目: 推測される識別情報をもとにカスタマイズ     設定 \u0026gt; プライバシーと安全  データ共有とTwitter外でのアクティビティ  Twitter外でのアクティビティ      https://twitter.com/settings/off_twitter_activity\n Twitterの表示内容は常に、利用者が登録した情報やログインに使ったことのある端末をもとにカスタマイズされます。この設定をオンにすると、Twitterのログインに使ったことのない端末とブラウザや、Twitterアカウントに登録された情報に似ているメールアドレスと電話番号など、推測される他の識別情報もTwitterのカスタマイズに使用されます。\n これはcreation_ip, login_ipのこと.\n 利用者が登録した情報 ログインに使ったことのある端末  つまりTwitterのアカウント作成時とログイン時のIPはアカウントと紐付けられて保存される.\nさらに以下の情報を利用しようとするので設定項目で採取しないようにできる.\n Twitterのログインに使ったことのない端末 Twitterのログインに使ったことのないブラウザ Twitterアカウントに登録された情報に似ているメールアドレス Twitterアカウントに登録された情報に似ている電話番号  "},{"id":163,"href":"/notes/20220415080505/","title":"📝Twitterシャドウバン","parent":"🎓Keido HOME","content":"tags: 🏷Twitter\nTwitterのシャドウバンについてのまとめ.\nTwitterシャドウバンとは    Twitterシャドウバンは俗語でありTwitter公式ではその用語はない.\nさらにはチェックサイトが2018年くらいにできてそれで用語が定着していったがTwitterの仕様は常に変わっているため現状の規制と乖離しはじめている.\nたとえばSearchBanやGhost BanはEntities(Text/URL/Media)ごとに規制されるようになった. そしてSearch BanがかかることとGhost Banがかかることは同じなので両者を分ける必要もないかもしれない. Reply Deboostingについてはかつては攻撃的な内容を含むだったが, 2022現在はヌード, 暴力, センシティブの３つに細分化されている.\nまた2020年ごろから，アカウントをロックや凍結をするのではなくツイートを隠したり通知規制をするようになった気がする. それはコロナ流行やアメリカ大統領選挙にあわせて都市伝説やデマを拡散するTwitter Botが大量生産されたための対策のように思われる. つまり本人は今までどおり情報発信をしていてもタイムラインに流れなかったりリプライが届かなかった通知欄に表示されなかったり. その変化によって最近(2022現在)より一層このあたりのアルゴリズムが変化している.\nshadowban.euによるシャドウバンの分類    本家サイトはすでに閉鎖済み. 4つに規制を分類している.\n Search Suggestion Ban  This type of ban causes an account to not populate search suggestions and people search results when it is searched for while being logged out. Twitter seems to take tie strength or a similar metric into account. While an account may be suggested to users you are strongly tied to, it may not be shown to others.   Search Ban  This type of ban causes your tweets to be hidden from the search results entirely, no matter whether the quality filter is turned on or off. This behavior includes hashtags as well. This type of ban seems to be temporally limited for active accounts.   Ghost Ban  This is what is referred to as conventional shadowban or thread banning as well. It comprises a search ban while threads are completely ripped apart by hiding reply tweets of the affected user to others. Everything will look perfectly normal to the affected user but many others will not be able to see reply tweets of the affected user at all. Reasons for this ban include behavior like excessive tweeting or following. Again, this type of ban seems to be temporally limited for active accounts.   Reply Deboosting  If Twitter\u0026rsquo;s signals determine that an account might engage in harmful behavior, Twitter hides their replies behind a barrier and only loads them when \u0026ldquo;Show more replies\u0026rdquo; is clicked. This behavior is personalized, i.e. Twitter does not hide the tweets of accounts you follow. We therefore use an unbiased reference account without followings in order to determine whether tweets within a thread can be retrieved without clicking \u0026ldquo;Show more replies\u0026rdquo; from its view. In some cases, Twitter classifies accounts as offensive. In this case, replies are hidden behind a second barrier within the \u0026ldquo;Show more replies\u0026rdquo; section. The outcome of this test may depend on the conversation which we found one of your tweets in. For testing, we take your latest reply tweet that is not within a conversation you started. Note that test results are cached for a short period of time. A failure to test is neither a positive nor a negative test result. This test relies on some conditions that are not fulfilled by all accounts. In some cases, we cannot test for purely technical reasons.    https://github.com/shadowban-eu\n💡個人的なシャドウバンの分類    たとえばTwitterアカウントをハードウェアに見立ててファームウェアでシャドウバン状態のウォッチドッグをかけてステータス遷移するとすると状態の設計は以下のようになる.\n Normal  正常(Online) 非公開(Protected)   Warning  ShadowBan(シャドウバン)  URL規制(URL Ban) ハッシュタグ規制(HashTag Ban) メディア規制(Media Ban)  画像規制/動画規制(entities, extended entities)   メンション規制(Mention Ban)   GhostBan（ゴーストバン)  URL規制(URL Ban) ハッシュタグ規制(HashTag Ban) メディア規制(Media Ban)  画像規制/動画規制(entities, extended entities)   メンション規制(Mention Ban)     Critical  ALLゴーストバン(ThreadBan) ALLサーチバン(SearchBan) アカウントロック(Locked) 永久凍結(Suspended)    TwitterのAPIで情報を取得するとEntitiesという属性がサブカテゴリに分かれていてurl/hashtag/entities/extended_entites/mention/symbolの分類がされているためおそらくこの分類で規制をしている. しかしこれはv1の仕様であり最近(2022)はv2へ移行して仕様がかわっているので今後どうなるかわからない. 少なくともsymbolがもう使われてないように思う.\n用語の定義しては, プロフィールタイムラインからは表示され相手のタイムラインからは表示されない(検索含む)ものをシャドウバン, プロフィールタイムラインからは表示され相手のタイムラインからは表示されない(さらに表示しようとすると「このツイートは表示できません」となる)ものをスレッドバンとする.\nその上で, WarningとCriticalに分類したのは, テキストも含む全ての投稿が制限されるか一部が制限されるかには明確に危険度でレベルがある気がする. いわばサーチバンやスレッドバンがかかったら次はロックへのリーチ, 一方それより軽い規制状態ならスパムとTwitterが判定するような行為を継続してもスレッドバンやサーチバンには格上げされるがロックには至らない(至ったケースも有るが\u0026hellip; ).\nさらにWarningレベルは24時間放置で解除されるがCriticalになるといつ解除されるかわからない. これは３０分ごとに監視スクリプトをかけているときっちり24時間でステータスが変更したことを検出できる. またCriticalからWarningにこっそり移行しているケースもありテキストだけつぶやいて初めてステータス遷移と認識できることもある.\nツイートが原因だとWarning or Criticalのどれかの規制になるがいいねやフォローRTの過剰によるスパム判定はだいたいサーチバンになる. スレッドバンとサーチバンはほぼ同時に起こるがサーチバンはスレッドバンを兼ねることが多い. しかし全く同義ではなく，たとえばおなじようなコンテンツをリプライしすぎてスパム判定されるとスレッドバンになるがテキストだけ検索に表示される状態になり，これはシャドウバンにあたるがサーチバンではない. しかしサーチバンであるがスレッドバンでないケースはみたことがない.\nゴーストバンは基本的に24時間放置で解除されるもののこの状態で再びゴーストバントリガーになるアクションをするとすぐにゴーストバンになりループするだけなので，ゴーストバンから復帰してもしばらくおとなしくしていたほうがいい. なにがきっかけである程度のアクションがでるようになるのかはまだわからないが時間とフォロワー数が解決してくれることは間違いない.\n🤔シャドウバンアルゴリズムの研究     長期に渡る規制は14:00にステータスが変化することが多い. トリガーとなったツイートから24時間, 72時間で規制解除されることがおおい.  シャドウバンチェックサービス     本家(終了)  https://shadowban.eu/ https://twitter.com/shadowban_eu https://github.com/shadowban-eu   by Steve-0628 \u0026amp; HiSubway  Twitter Shadowban Test GitHub - Steve-0628/shadowban-frontend GitHub - Steve-0628/shadowban-backend/ @hisubway   by SNQ  ShadowBird - Twitter ShadowBan Check @SNQ(_SNQ) https://twitter.com/Shadow_Ban_Bot    References     🖊Twitterシャドウバンの個人的分類2022版 | Futurismo https://twitter.com/shadowban_eu/status/1353870304490123264  [2012.05101] Setting the Record Straighter on Shadow Banning    "},{"id":164,"href":"/notes/20220415120253/","title":"📝Twitter検索オプション","parent":"🎓Keido HOME","content":"tags: 🏷Twitter\n逆引きTwitterオプション    引用動画ツイートを特定するには？    screen-nameのアカウントのツイートを引用したツイートを特定するには, 非公開アカウントにて,\n\u0026#39;twitter.com/{screen_name}/status\u0026#39; -from:@{screen_name}\u0026#39; \u0026#39;url:{screen-name} -from:@{screen-name}\u0026#39; アフィリエイトIDが同じアカウントを特定するには？    同一人物による複数アカウント特定方法は、`{keyword} url:{affiliate-id}`\nアフィリエイトをしている場合自演RTをしているケースが多いので whotwi で関連ユーザを調べるのもよい.\n同一人物のAPI投稿を特定するには？    source:{xxx} をつかう.\n"},{"id":165,"href":"/notes/20220220095102/","title":"📝Web Development Basic","parent":"🎓Keido HOME","content":"汎用的なWeb開発技術まとめ.\n言語間に共通する技術の集積を目指す.\n各言語ごと各論はタグでまとめる. 🏷Web Development\nWeb: World Wide Web    World Wide Web. インターネット上で提供されるハイパーテキストシステム.\n World Wide Web - Wikipedia  Web の歴史     Web1.0 ・・・クライアントは静的ページを Web サーバから取得する. ウェブページ. ウェブを読む. Web2.0 ・・・クライアント/ サーバ側で動的にページを作成する. ウェブサービス. ウェブを使う. Web3.0 ・・・クライアントごとがつながりあう. データの上のメタデータをあつかう. クラウドコンピューティング ・・・あらゆるデバイスがネットにつながる. セマンティックウェブ ・・・ビックデータの統計解析から価値を生み出す.  ref: 迫り来る Web3.0 時代を生き抜くエンジニアが持たなければいけない 3 つの視点 | DMTC Magazine\nHTTP Protocols    HTTP は, Hypertext Transfer Protocol の略.\n Hypertext Transfer Protocol - Wikipedia  Web ブラウザと Web サーバの間で, HTML などのコンテンツの送受信に用いられる通信プロトコル.\nHTTP request methods    HTTP Status Code    HTTP ステータスコード.HTTP ステータスコード - Wikipedia\n   1xx Informational 情報     2xx Success 成功   3xx Redirection リダイレクション   4xx Client Error クライアントエラー   5xx Server Error サーバエラー    Mine Type    規格上 US-ASCII のテキストしか使用できないインターネットの電子メールでさまざまなフォーマット (書式) を扱えるようにする規格.マイム.\n Multipurpose Internet Mail Extensions - Wikipedia  Cookies    HTTP におけるウェブサーバとウェブブラウザ間で状態を管理するプロトコル, またそこで用いられるウェブブラウザに保存された情報のことを指す. ユーザ識別やセッション管理を実現する目的などに利用される.\n HTTP cookie - Wikipedia  HTTP Push     Push 技術 - Wikipedia 出版-購読型モデル - Wikipedia  HTTP Polling    クライアントがサーバへ定期的にメッセージを送信する.\nクライアントは, サーバの状態をしらない.\nWeb Server    Web サーバ, HTTPサーバともいう.\nクライアントApplicationのHTTPリクエストに応じて、 HTMLファイルや画像データのレスポンスを返すサービスプログラム.\nex.) Apache, Nginx\nref: Webサーバ - Wikipedia\nWeb Application Server    ビジネスロジックなどを実装したアプリケーションソフトウェアを実行することを専門とするコンピュータネットワーク上のサーバコンピュータ, もしくはそのようなコンピュータ上でのアプリケーションの実行を管理補助するミドルウェア.\nref: アプリケーションサーバ - Wikipedia\n基本機能は次の3つ.\n プログラムの実行環境やデータベースへの接続機能の提供 複数の処理を連結するトランザクションの管理機能 業務処理の流れを制御するビジネスロジックの実装  WebApp Server Examples     Runy  puma unicorn   Java  Tomcat Jetty    Web Application    インターネット (もしくはイントラネット) などのネットワークを介して使用するアプリケーションソフトウェア.\ncf. Desktop Application, Mobile Application\nref: ウェブアプリケーション - Wikipedia\nたとえばRuby on Railsを使って自作したアプリはこれを指す.\n💡ひとくちメモ    Web ApplicatlionがAPIを提供するサーバになってきたため, 2019年ごろからiOS, Android, Webアプリの境目がなくなってきたように思う.\nすなわちMobile AppとWeb Appの区別がなくなってきており, 数年でまた定義を書き直すことになるかも.\n📝Web Server Abstruction    HTTP server abstructionとも. InterfaceによるWebサーバ抽象.\nWeb Serverと Web アプリがやり取りをするための仕様. 言語ごとにいろいろな仕様がある.\n Python WSGI Ruby Rack Clojure: Ring, Pedestal  ただ, これらの概念をまとめる概念として一般的な用語がみつからないので便宜的に自分で定義する. 以下解説.\nJavaにはServlet及びServet APIがあり, 言語仕様として Web Server - Web Application間の仕様か決まっていた.\nコレを真似るかたちでPythonでWSGIの仕様が作成され他の言語も真似ていった.\nWSGIは Web Server Gateway Interfaceの略. もはやこの用語でいいかもしれないが WSGIというとPythonに限定されると誤解しやすい. このServer - Application間の仕様は各言語に存在する.\nただ実際にこれらのWebサーバ抽象を担当するフレームワークをつかうときは, フレームワークに扱ってほしい自作の関数をハンドラとして渡すので, より具体的にはハンドラフレームワークといったほうがイメージしやすいかも.\nWeb Application Framework    T.B.D. あとで.\n Ruby on Rails Python Django Java Play Framework  Web Archtectures    Web Client | (NetWork) | Web Server | Script/Service | (Connector) | DataBase  Model View Controller - Wikipedia  Web Protocols     HTTP, HTTPS (Request, Responce) http://ja.wikipedia.org/wiki/Hypertext_Transfer_Protocol REST-based, Restful, http://ja.wikipedia.org/wiki/REST RPC-based, SOAP SOAP (プロトコル) - Wikipedia  Presentation Layer    プレゼンテーション層.ユーザインタフェースとコントローラを提供. クラス名は Controller, Action.\nPresentation    Presentation Layer の構成要素は以下.\n HTML (構造) CSS (表現) JavaScript (動作)  これらは絶対に, 絶対に, 絶対に, 分けなければいけないと強調される.\nController    画面遷移や画面でボタンが押されたときの動作制御やセッション管理など.\nMiddle-ware Layer    ビジネスロジック層ともいう\nこれらの定義は, Spring3 から引用: http://gihyo.jp/book/2012/978-4-7741-5380-3?ard=1407982106\nトランザクション    分けることのできない一連の情報処理の単位.\n トランザクション - Wikipedia  データベースにおいては, データに対する一つの論理的操作の事.\n   ACID 特性\n信頼性のあるトランザクションシステムの持つべき性質.\n ACID (コンピュータ科学) - Wikipedia       トランザクション境界\nプレゼンテーション層とトランザクション層の境界.\n簡単に言うと,\n (開始) xxx Controller から xxxService のメソッド呼び出し. (終了) xxxService のメソッドの return.    ビジネスロジックの分類    クラスの末尾に Service のついた名前や,対象となるオブジェクト名 (Employee, Order) がつく.\n   Service\nユースケースに表されるような特定業務や特定部署の処理のまとまりをコントロールする.トランザクションの起点.一般的にはステートレス.\n     Domain\nサービスから起動される, ビジネスを行う上で当然認識される顧客や注文といったサービスの集まり. 自分自身がなにものかを示す値と, その値を利用した処理を実現する.\n  ビジネスロジック・パターン     トランザクションスクリプトとは「アクションより起動される一連の手続き」 ドメインモデルとは「ドメイン内の名詞によって体系化されたモデル」  いまさらきけない「ドメインモデル」と「トランザクションスクリプト」\n   トランザクションスクリプト\n ユースケースごとに Service クラスをつくっていく. 手続き処理で記述.処理ごとドメインを呼び出していくだけなので, オブジェクト指向ぽくない. 小規模開発向け. とても簡単で分かりやすい.       ドメインモデル\n 大規模開発向け. とても簡単で分かりやすい. ドメインにロジックを持たせる. (OOP 設計!)    Database Layer    データペースレイヤ. データアクセスレイヤとも.\nデータベースへのアクセスを抽象化する.クラス名の末尾に DAO (Data Access Object) がつく.\nDB Layer 役割     RDB へのアクセスをビジネスロジック層から隠蔽 必要なデータを RDB から取得してオブジェクト (domain) にマッピング.     O/R マッピング\nObject と Relational DB の対応づけ. 基本的に, DD テーブルの 1 レコードが 1 オブジェクトに対応.\n  Relational Database    リレーショナルデータベース. デファクトスタンダードな Db 設計.RDB\n 関係データベース - Wikipedia  The Active Record Design Pattern    REST    Restful,Representational State Transfer.分散ハイパーメディアシステムのためのソフトウェアアーキテクチャのスタイルのひとつ.\n http://ja.wikipedia.org/wiki/REST  2 つの意味で使われている.\n Fielding の REST アーキテクチャスタイルの原則に合わせた Web サービスシステム. RPC スタイルに合わせた簡易な XML+HTTP インターフェイスを採用したシステム (SOAP は使わない) .  Fielding の REST 原則    Fielding の REST 原則に従うシステムは, しばしば RESTful といわれる.\n セッションなどの状態管理を行わない (やり取りされる情報はそれ自体で完結して解釈することができる) 」 (Web システムでは, HTTP 自体にはセッション管理の機構はない) 情報を操作する命令の体系が予め定義・共有されている」 (Web システムでは HTTP の GET や POST などに相当), すべての情報は汎用的な構文で一意に識別される」 (URL や URI に相当), 情報の内部に, 別の情報や (その情報の別の) 状態へのリンクを含めることができる (ハイパーメディア的な書式で情報を表現する) 」 (HTML や XML に相当)  http://e-words.jp/w/REST.html\nPublisher-Subscriber Model    非同期メッセージングパラダイム.\n出版側と購読側の結合度が低いため, スケーラビリティがよく, 動的なネットワーク構成に対応可能.\n 出版-購読型モデル - Wikipedia  Web HTTP Routing    いわゆるルーティングと呼ばれているもの. しかしこの言葉自体がいろんな意味を含むので, ここでは Web Application Framework で利用されるものを扱う.\nなお Routerは発音注意(らうたー, これを言えないと小馬鹿に見られる).\nルーティングとは, クライアントのリクエスト内容と、サーバーの処理内容を紐付ける作業.\n各言語ごとにWebフレームワークがあるように, ルーティングライブラリも各言語ごとにある. Frameworkの中に組み込まれていたりライブラリとして切り出されて使えるものもある.\n極論ライブラリをつかわなくてもkey-valueの集合でいい.\nendpoint    Webアプリケーションにおけるendpointとは, APIにアクセスするための識別子であり, たいていはURL/URIである.\nServer Load Balance    サーバロードバランスは, クライアント/ サーバネットワークにおいて, クライアントとサーバの間にロードバランサー (負荷分散装置) を設置し, 通信アプリケーションの (TCP/UDP) ポート番号をもとに, 2 台~256 台 のサーバが分散処理を行う, コンピュータシステム.\n サーバロードバランス - Wikipedia  外部のネットワークから見て, ロードバランサは仮想的な 1 台のサーバに見える. つまり, IP アドレスやポート番号は, 背後にあるサーバ群の代表としてロードバランサのものだけが見える.\nLoad Balancing    コンピュータネットワークにおける技法の一種であり, 作業負荷を多数のコンピュータ/ プロセス/ その他のリソースに分散し, リソースの利用効率を高め性能を向上させる手法.\nWeb サービスの分類     クラウド上で発展する様々なサービス「 SaaS ・ PaaS ・ IaaS 」|コベルコシステム  PaaS    Platform as a Service ソフトウェアを構築および稼動させるための土台となるプラットフォームを, インターネット経由のサービスとして提供する.\n Platform as a Service - Wikipedia  アプリケーションソフトが稼動するためのハードウェアや OS などの基盤 (プラットフォーム) 一式を, インターネット上のサービスとして遠隔から利用できるようにしたもの.\n PaaS とは 【 Platform as a Service 】 - IT 用語辞典  Examples    IaaS    Infrastrucure as a Service.\n仮想化技術を利用して CPU, ストレージ, OS, ミドルウェアなど, システムを構成するためのインフラをインターネット経由で提供するサービス.\n プロバイダーは基板となるストレージ, ネットワーク, コンピューティングリソースを管理し, 提供します. OS や FireWall のようなネットワーク制御コンポーネントなどのアプリケーションをデプロイ, 実行, コントロールすることが可能です.  VM 上でサービスを提供する.\nExamples    SaaS    Software as a Service\n📚Books     『プロになるためのWeb技術入門』 - ｜技術評論社  良書だけど売却してしまったな\u0026hellip; 2021年に技評から電子PDF版が発売されたのはよい. 🖊HTTP も知らないのぉ~? にカチンときたら読むべき! プロになるための Web 技術入門を読んだ. | Futurismo    🔗References     Web Application Development: Basic Concepts | Coursera  courseraのオンライン講座. 🖊[coursera]Web Application Archtecturesを受講しました | Futurismo    Active Recalls    HTTPとはなんですか？    Webサーバとはなんですか？    Web Application Frameworkとはなんですか？    Middlewareとはなんですか？    "},{"id":166,"href":"/notes/20220301075027/","title":"📝Y Combinator","parent":"🎓Keido HOME","content":"Paul Grahamなどが立ち上げた最強 Startup Accelerator.\ntags: 🏷Paul Graham\n日本では馬田さんが中心になってY Combinatorの情報発信をしているのはありがたい.\nhttps://resource.foundx.jp/beginner/\n refs  My Visit with THE LORD OF THE STARTUPS: Y Combinator\u0026rsquo;s Paul Graham - YouTube  Paul GrahamさんによるY Combinatorの紹介.      "},{"id":167,"href":"/notes/20220107141801/","title":"📝Youtube","parent":"🎓Keido HOME","content":"動画サービス.\nYoutube Tips    YoutubeのプレイリストのRSSを取得するには?    プレイリストのページを開いてplaylist_idを取得して以下のURLで設定.\nhttps://www.youtube.com/feeds/videos.xml?playlist%5Fid=%7Bplaylist%5Fid}\n"},{"id":168,"href":"/notes/20211206071458/","title":"📝Zettelkasten Method","parent":"🎓Keido HOME","content":"Zettelkasten Methodとは    Niklas Luhmannの考案した, 思考をするための方法論，フレームワーク.\nZettelkastenという単語はZettelkastenのフレームワークを指す場合とZettlekastenで管理するPermanent Noteを入れる箱(Slipbox)を指す場合の2つがある.これらは書き手や文脈で統一されてないので情報を得るときは注意が必要.\nZK method, Zettelと省略されることもある.\nZettelkasten Methodまとめ    Zettelkasten Methodでは以下の4種類のノートの概念がある.\n Fleeting Notes Literature Notes Parmanent Notes Reference Notes  📝Fleeting Notes    思いついた思考を書き留めたもの.何でもOK, 思いついたら何でも書く.\n道具は紙でも電子でもなんでもよいが，トピックごとだとあとで整理しやすい.\nメインのシステムにNoteを移動したら捨てる,もしくは移動せずにそのまま捨てる.\nDaily Notesについて    Zettelkasten Methodの文脈での時系列のFleeting NotesとしてDaily Notes(DNP)という単語がある.\nとはいえ，Niklus LuhmanやZonke Ahrensの著作ではこの概念は登場しない.\nRoam ResearchやObsidianなどのZettelkastenのソフトウェア実装の文脈でよく登場する.\n📝Literature Notes    日本語訳では，文献メモとも言われる.Lit Notes, lit notesと略されることもある.\nインプットするたび書く.読んだ本，みたYoutube動画，受けた講座などなど.\n 覚えておきたいこと. 自分の思考. アウトプットに使いたいもの.  自分の言葉でリライトしながら書く. 著者の思想を自分の思想に翻訳する意味が有る.自分が理解していないものに対しては自分で書くことができない.\nカードの裏には書誌情報を書く.\n タイトル 発行年 著者 出版社 引用ページ\u0026hellip;  📝Permanent Notes    Concept(=概念)が書かれたノート.\n番号を振り，他のノートへの関連を番号でリンクさせて, Zettelkasten(a.k.a.Slipbox)のシステムに入れて管理する.\nメモには問い(仮説)が伴う. 問いこそが重要.すなわち，問い，仮説，アイデア.\n内容は自分自身の思想であり，他者の思想とは明確に区別する(他者の思想は入れない).\nPermanent Noteとはブログの見出しのようなもの    つまりNoteをアウトライナーで並べればそれがそのままブログ記事として完成する.\n最終的なアウトプットのためにはアウトライナーで階層的にロジックツリーで管理しうるもの.\nこの Obsidianを利用したZettelkastenの解説動画 でブログ執筆のWorkflowをみて開眼した.みだしの下にPermanet Noteへのリンクを埋め込んでその内容を右ペインに展開すれば，もうすなわちブログ記事がほぼ完成していて，あとはそれを清書するればいい.\nEvergreen NoteとPermanent Noteの関係    Evergreen NoteとはAndy Matuschakが提唱した概念であるが，Zettelkastenから影響を受けているのでほぼ同義. 彼のノートはWebで公開されている(example of Evergreen notes).\nしばしばPermanent NoteはConcept Noteと表現される.Permanent Noteが単一のコンセプトを表現するものならば，この名前はわかりやすい.\nPermanent NotesとReference Noteの関係    Permanent Notesとは，Permanent Noteの集合.Permanent Noteそれぞれは独立しているが, Permanent Noteの性質を扱いたい場合はPermanent Notesという言葉を使う.またReference NoteはPermanent Noteをキーワードと番号で対にして列挙したもの. 文脈によってPermanent NotesがPermanent Noteの性質を述べるものなのかReference Noteを指すのかは注意.\n📝Reference Notes    キーワードとそれに対するメモへのリンクから構成される.\n日本語では索引メモと訳される.\nZettelKastenシステムに入れるがあくまで索引メモはサブのメモ.\nReference NotesとTOC, Structure Notes, MOCの関係    いわゆる目次，TOC(Table of Contents)とはRefenence Notesとは似ている.また，Structure Notesとも表現される.どちらも，構造化したノートという点では広義のReference Notesとなる.\nよくObsidian界隈やLYT(Linking Your Thinking)の中で現れるNick Miroさんの Maps of Conents(MOC) はRefernece Noteも近い.Reference Notesに影響を受けているので.\nただ，そこで列挙するものがトピックならばそれはReference Noteではない.Refenrece Notesで列挙するものはConceptsであり，一般的には文で表現される.\nLuhmanの方法だと，キーワードとそれに対応する番号を列挙したリストがReference Noteとなる.エントリとなるReference Noteにはキーワードに紐づくリンクはせいぜい1つか2つ.メモ同士の繋がりが驚きを生みこれが重要であるから.索引からメモへジャンプしても驚きはない.1つか2つのメモへのエントリポイントであればいい, という考え方.そしてエントリから飛んだ索引メモには，さらに最大25個のPermanent Notesが列挙されていて，それらは英数字で管理された.たとえば，1.a, 1.b, 2.c..など. o Table of Contentsだと，いわゆる本の目次のようにひとつのノートからすべての階層が一覧できる.これはluhmanの方法とは違う.\nPKMとZettelkasten Systemの関係    よくPKM(Personal Knowledge Management)の用語もでてくる.PKMとは個人の情報管理システム.\nこの言葉自体は古くからあるが，最近のRoamブームで再びよく登場するようになっている.\nここでの問題点は，文脈によってこれが他者の知識をまとめたWikiと自分の言葉や思考をまとめたPKMで混同されてつかわれているところ.そして，それらをZettelkasten Methodを参考にしていると表現されているところ.\n参照     📝Org-roam 🖊日本語のツェッテルカステン解説本(TAKE NOTES!)を読んで考えたこと  参考文献     wikipedia: https://en.wikipedia.org/wiki/Zettelkasten  "},{"id":169,"href":"/notes/20211229203145/","title":"📝Zotero","parent":"🎓Keido HOME","content":"Zotero(ゾテロ)とは，論文管理を目的にしたオープンソースの文献管理ソフトウェア.\nhttps://www.zotero.org/\nZoteroまとめ    Zoteroは勉強したインプットのメタ情報の取得とアーカイブが可能    論文管理が目的とはいえ，論文でなくてもいろいろ管理することが可能.1\n Web記事  Amazon(書誌情報) Youtube   PDF etc\u0026hellip;  たとえば，AmazonやYoutubeをZoteroに送信するとメタ情報がZotero画面に表示される. PDFで購入した電子書籍に対してAmazonのページからメタ情報を取得してPDFをその情報に添付することでPDFとメタ情報を管理できる.\nさらに，Web記事はスクリーンショットという機能でhtmlとしてローカルに保存することも可能.\nZoteroは個人用のローカルはてなブックマーク，メモも管理できる    annotationという形でその文献に対するメモを管理することが可能. いわば，はてなブックマークを詳細情報を含めてローカルで個人管理するようなもの.\n参考文献     quick start guide : Zotero公式のクイックスタートガイド(ja) 【令和最新版】文献管理ソフト Zoteroのすゝめ｜SD｜note : 日本語の良記事  注釈      わたしの目的は文献一般を管理すること.論文はなかなか縁がない.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   "},{"id":170,"href":"/notes/20211217134744/","title":"📝Z世代","parent":"🎓Keido HOME","content":"1996-2012に生まれた世代.\nGeneratin Z, GenZともいう.\n"},{"id":171,"href":"/notes/20220310100122/","title":"📝イベント駆動型プログラミング","parent":"🎓Keido HOME","content":"refs:\n 📝組み込みシステムパターン 📝フロー駆動型プログラミング  up: 📁Programming Paradigms\nイベント駆動型プログラミング(Event-Driven Programming)とは    イベント駆動型パラダイムの重要概念    イベント    イベントループ    イベントハンドラ    他のパラダイムとの関係    対概念は フロー駆動型プログラミング.\n他のドメインとの関係    アプリ開発との関係    T.B.D.\n組込み開発との関係    フロー駆動がフローチャートを重視するならばイベント駆動は状態遷移図を重視する. 状態とはイベントループそのもの.\n🏷組込み開発\nReferences     イベント駆動型プログラミング - Wikipedia イベント駆動型プログラミング | IT用語辞典 | 大塚商会  "},{"id":172,"href":"/notes/20220117174424/","title":"📝オブジェクト指向プログラミング","parent":"🎓Keido HOME","content":"up: 📂プログラミングパラダイム\nrefs:\n 📝ポリモーフィズム 💻【超絶IQ列伝】苫米地メソッド EX 「抽象度とは何か？」苫米地英人 オブジェクト指向プログラミング - Wikipedia  オブジェクト指向プログラミングとは    オブジェクト指向パラダイムにおけるプログラミング.\n以下の要素をそなえもつ.\n データ抽象(Data Abstruction) Inheritance Polymorphism  現在オブジェクト指向言語と呼ばれているものは,実際には,\n Abstruct Data Type (Java Integer 型) オブジェクト (Java Object 型)  の 2 つを合わせもっている.\nその意味で, オブジェクト指向言語と言うよりは抽象データ言語というほうが正しい.\nデータ抽象(Data Abstruction)    データ抽象, Data Abstruction. Expression Problem における解決策.\n3 つの構成要素がある.\n Input Output Interface  データ抽象は内部と外部からなるプログラムかつ, 両者がインターフェースを通じてやりとりするもの.\n\u0026gt; A data abstraction is a part of a program that has an inside, an outside, and an interface in between The inside is hidden from the outside.\nデータを抽象的に使う, 使い方.実装にとらわれずにデータを使うこと. インタフェースと呼ばれる規則にしたがって使用される具体化の集合.\nデータ抽象を型 (Type) といって済ますこともある. 抽象データ型 (ADT) は, 特殊なデータ抽象. 値の集合と, それに関する操作の集合.(CPMCP p431)\n以下のコンセプトに支えられている\n High-order Programming (高階関数) Static Scoping (クロージャ) Explicit State (明示的状態)  Data Abstruction は 2 つの実現方法がある.\n Abstruct Data Type (ADT)  Abstract data type: 抽象データ型(ADT) 値と操作をベツベツに保持する.   Object  値と操作を一緒に保持する    Input/Output    内部は外部からは隠蔽されている. -\u0026gt; カプセル化という.\nThe inside is hidden from the outside\nInterface    The interface is a set of operations that an be used according to certain rules.\nデータ抽象には, 主に二つの方法がある.\n Abstract Data Type (ADT) keeps values and operations separate. Object groups together value and operations in a single entity.  Java インタフェースは, 階層を持たない型システムを構築する. (Effective Java p91 抽象クラスよりもインタフェースを選ぶ)\n抽象クラスよりもインタフェースを選ぶ    ref: Effective Java (p93)\n実装の観点では,\n 抽象クラスはメソッドに対する実装を含むことを許されている. インタフェースはメソッドに対する実装を含むことを許されていない.  機能の観点では,\n 抽象クラスはある機能の実装を強制する. インタフェースは任意の機能を混ぜ合わせる.  階層化の観点では,\n 抽象クラスは物事を階層化することに優れる. インタフェースは階層を持たないものをまとめることに優れる.  インタフェースは, 階層を持たない型システムを構築する.\n インタフェースは型を定義するために利用する インタフェースは定数を提供するために使用しない  Enum を検討する Util クラスを検討する 関連するクラスのメンバを検討する    SICP における説明    データオブジェクトをどう表現するかに関するプログラムの部分を、データオブジェクトをどう使うかに関するプログラムから隔離する方法.(SICP)\nconstructor(構成子), selector(選択子) によって、どう使うかに関するプログラムの 抽象の壁 を構築し、抽象レイヤを構築する.\nこれを、Data Abstruction(データ抽象) という.\nデータによるレイヤー構造を構築することで複雑なシステムをうまく構築することができる.\n抽象の壁という意味は、壁をつくることで、ある場所での変更を局所的なレイヤの変更に封じこめることができる.\nカプセル化(Encapsulation)    プログラムと内部と内部をインタフェースで分けること. カプセル化のメリットは大規模開発をシンプルにする.\n 正しさを保証する. 複雑さを解消する.  カプセル化とはあらゆるものを隠蔽すること    カプセル化がデータ隠蔽というのは狭義の定義.\nカプセル化とはあらゆるものを隠蔽すること.\n データ メソッド 実装 派生クラス 設計の詳細 実体化の規則 型  流動的要素を探し出してカプセル化する\n某元チーム先輩エンジニアの発言    ある目的をもったモノの集合.(N 氏) モノには特性 (属性と操作) がある.\nアプリケーションを設計するということは, まずそのアプリケーションで利用されるデータ型を定義するということからはじめる. (AplInteger, AplString みたいなもの)\nその後, 自分が定義したデータ型を操作するインタプリタを設計する.\n実装では, Java をつかっているものの, Java はそれらの抽象データ型のインタプリタでしかない.\n抽象データとインタプリタを設計することが設計. -\u0026gt;(内部 DSL のこと?? ドメインモデル設計)\nAbstract Data Type    OOP を語る上では理解をさけられない.\nref: Abstract data type: 抽象データ型(ADT)\nオブジェクト(Object)    値と操作をひとつのまとまりとしたもの. 以下の構成要素をもつ.\n 値 ・・・ Explicite State (明示的状態 .. 時間とともに変化する値) 操作 ・・・ Procedural Data Abstruction (手続的データ抽象)  メソッドと属性(Methods/Attributes)    オブジェクトは内部と外部はインタフェースを通じてやりとりされる. 内部の明示的状態を Attributes (属性), インタフェースを Methods (メソッド) という.\nたとえば, A1 を属性, M1 をメソッドという.\ndeclare local A1={NewCell 0} in proc {M1 Hoge} end end これはクラスでもインスタンスでもないことに注意!!\nクラス(Class)    抽象データからなるデータ構造.\nメソッドと属性を定義する特別なシンタックスを Class という. 属性とメソッドはレコードデータ構造によって管理されているだけである!\nClass とは, Pair ( attrs[属性の集合] : methods[メソッドの集合]) )\nまたは, Java ならば, こうかいてもいい.\nHashMap\u0026lt;String, HashSet\u0026lt;String\u0026gt;\u0026gt; attrs = new HashMap\u0026lt;String, HashSet\u0026lt;String\u0026gt;\u0026gt;(); HashMap\u0026lt;String, HashSet\u0026lt;String\u0026gt;\u0026gt; methods = new HashMap\u0026lt;String, HashSet\u0026lt;String\u0026gt;\u0026gt;(); attrs.put (\u0026#34;Hoge\u0026#34;, new HashSet (Arrays.asList (\u0026#34;attr1\u0026#34;, \u0026#34;attr2\u0026#34;))); methods.put (\u0026#34;Hoge\u0026#34;, new HashSet (Arrays.asList (\u0026#34;method1\u0026#34;, \u0026#34;method2\u0026#34;))); Class という概念によって, オブジェクトの\u0026quot;宣言\u0026quot;と\u0026quot;生成 (new)\u0026ldquo;を分離する.\n クラス (コンピュータ) - Wikipedia  クラスは, 継承・ポリモーフィズム・カプセル化などの, オブジェクト指向プログラミングにおける重要な概念を実現する強力な手段.\nインスタンス化(Instantiation)    オブジェクトは一つのメソッドで, 異なる属性をもつ複数のオブジェクトを生成できる.\nこの能力を Instantiation (インスタンス化) という.\nProcedure Dispatch    オブジェクトは単一なエントリポイントをもつ. (エントリポイント = 呼び出し口) エントリポイントに渡される引数をメッセージという.\n下の例だと, Counter がエントリポイント. エントリポイントに inc,get メッセージを送る.\n{Counter inc} {Counter get (X)} エントリポイントから, メッセージに対応するプロシージャが呼びだされる.\nメッセージとプロシージャはあらかじめ Dispatch (バンドリング) されている.\nポリモーフィズム    各要素 (定数, 変数, 式, オブジェクト, 関数, メソッドなど) についてそれらが複数の型に属することを許すという性質.\n ポリモーフィズム - Wikipedia  詳細はこっち: 📝ポリモーフィズム\nポリモーフィズムはオブジェクト指向固有の概念ではない. 以下はOOの観点からポリモーフィズムを説明.\nインタフェース: Interface    抽象データ型のメソッド.\nObject 型を分類し, 同じカテゴリに属するクラスに共通のインターフェイスを取り決める.\nimplements ステートメントは, クラスたちのカテゴリ分類を明確にする方法.\n変数の型としてカテゴリクラスを指定すると, そのカテゴリを Implements したクラス (つまり, カテゴリに属するクラス) のインスタンスも格納できるようになる.\n ポリモーフィズムとインターフェイス  オブジェクトが, 共通のインターフェイスを実装している場合, 他のオブジェクトに置き換えることができる.\n継承: Inheritance    継承. あるオブジェクトが他のオブジェクトの特性を引き継ぐこと.\n 継承 (プログラミング) - Wikipedia  継承は単に特殊化と再利用を実現する手段ではない. オブジェクトを分類するための手段である.\nどう分類するか?     共通性: 時がたっても変わらないものを抽象クラスに 可変性: 流動的要素を具象クラスに.  クラスの集合がもつすべての責務を真っ当するためにインタフェースを用意する.\n機能追加と機能実装の違い     「機能追加」 (スーパークラスが持っていない機能をサブクラスで追加) を目的としたもの 「機能実装」 (スーパークラスで定義したインタフェースをサブクラスで実装) を目的としたもの  ref: :Bridge パターン - デザインパターン入門 - IT 専科\nオーバーライド: override    オブジェクト指向プログラミングにおいてオーバーライド (override) とは, スーパークラスで定義されたメソッドをサブクラスで定義しなおし, 動作を上書きすること.\n オーバーライド - Wikipedia  委譲: Delegation    委譲(Delegation).\nあるオブジェクトの操作を一部他のオブジェクトに代替させる手法.\n 委譲を行うオブジェクトは委譲先オブジェクトへの参照を持つ 必要に応じてその参照を切り替える事で動作にバリエーションを持たせる事ができる プラグイン機構  ref: 委譲 - Wikipedia\nコンポジションと移譲の比較     委譲の実現には多くの場合コンポジションを使用する. 委譲は「目的」であり, コンポジションはその「手段」.  ref: コンポジションとデリゲーション - とある技術メモブログ\nComposition    コンポジション.\n新たなクラスに, 既存クラスのインスタンスを保持する.\nhas-a の関係 (not is-a)\nPrefer Composition over inheritance (Effective Java).\n継承と委譲の比較    メリット\n Java の場合継承は一クラスしかできないが, 委譲なら複数可能 継承なら親クラスのメソッドが全て公開されてしまうが委譲なら必要なものだけ公開できる  デメリット\n 継承に比べてコードの記述量が多くなる. 継承は何も書かなければ親クラスの機能が使える. 委譲はメソッドの呼び出しを実装しなくてはならない.  ref: オブジェクト指向で. 継承の他に, 委譲といのが出てきますが. これは具\u0026hellip; - Yahoo! 知恵袋\n関連する Design Pattern     Adapter Proxy Facade State Strategy Decorator  ref: Tricorn Labs » State パターンと Strategy パターンは何が違うのか考える\n手続き型とオブジェクト指向の違い    ref: 📝手続き型プログラミング\n機能分解    ある問題を小さな機能にブレークダウンすることで, その問題を構成する機能要素の洗い出しをすることを機能分解と呼ぶ.\n構造化プログラミング的アプローチ     (手続き的な) 機能を適切な順序で呼び出す「メイン」プログラムが必要になる. メインプログラムにはすべてを正しく動作させる,  すなわち機能の組み合わせと呼び出し順序を制御するあまりに大きな責任が課せられる   結果的にソースコードは複雑になる  オブジェクト指向的アプローチ     部分機能に対してそれ自体の振舞いに関する責任を持たせ, 実行指示を行うだけであと任せておく. これが委譲 (delegation) という考え方.  オブジェクト指向のこころ読書メモ    OOP の 2 大原則    オブジェクト指向のこころとは, ズバリ以下だ.\n 流動的要素を探し出してカプセル化する クラス継承よりもオブジェクトの集約を多用する  オブジェクト指向設計    オブジェクト指向分析設計 - Wikipedia\n名詞/ 動詞 抽出法     問題領域に存在する名詞を洗い出しそれらを表現するオブジェクトを生成する. 名詞に関連した動詞を洗い出し,それらを表現するメソッドを追加する  共通性/ 可変性 分析法     共通性分析:  時間が経っても変化しにくい構造を見つけるもの 共通性分析によってまとめられた概念を抽象クラスによって表現   可変性分析:  変化しやすい構造を洗い出すもの 可変性分析で得た流動的要素は抽象クラスの派生クラスによって実装される    設計手順:\n (抽象クラス) このクラスが持つ責務をすべて全うするにはどうようなインターフェイスが必要か? (派生クラス) この特定実装の中でどうのようにして与えられた仕様を実装できるのか?  Jim Coplien が提唱. p235 第 15 章から抜粋.\nReferences     オブジェクト指向の本懐 (7) ・オブジェクト指向分析 - Strategic Choice 共通性・可変性分析 (commonality/variavility analysis) - Debuginfo  Is-a/has-a関係    Is-a: 継承関係    Is-a は 継承関係.\n is-a - Wikipedia  Is-a 信仰. なんでも継承すればいいという考え方.\nHas-a: 包含関係    Has-a は 包含関係 (委譲)\n has-a - Wikipedia  References    ものすごくよい記事.歴史が端的にまとまっている.\n  新人プログラマに知っておいてもらいたい人類がオブジェクト指向を手に入れるまでの軌跡 - Qiita\n むだに Hoge インタフェースと HogeImpl クラスがあったり, むだに new するだけの create メソッドがあったり, どこで値が設定されてるかわからないオブジェクトがひきまわされてたり, ソースコードを追いにくくするためにやってるとしか思えない, オブジェクト指向なコードをよく目にする.\nクラスは単にユーザー定義型であり, 継承は部分型と差分プログラミングを実現する仕組みだととらえるのがいい. オブジェクトがメッセージを送りあうとかメルヘンの世界には入らず, 機能だけ考えるのがいい.\n  オブジェクト指向は禁止するべき - きしだのはてな    eesay: Rees by Jonathan Rees    ref: Rees Re: OO\nオブジェクト指向というのは, このリストのいろいろなサブセットとして 定義されているようだ. つまり, 「オブジェクト指向」というのはちゃんと定義された概念ではない!\nカプセル化    型の実装を構文的に隠蔽できること. 例えば C や Pascal では何かが構造体であるか配列であるか常に意識することになるが, CLU や Java ではその違いを隠すことができる.\n保護    型の使用者がその実装をのぞくことができないこと. これによって,ふるまいさえ変えなければ, 実装を変更しても型の使用者に影響を与えないことが保障でき, またパスワードのような情報が漏れ出さないようにることもできる.\nアドホックポリモルフィズム    関数やパラメータつきデータ構造が たくさんの異なる型の値をとることができる.\nパラメトリックポリモルフィズム    関数やデータ構造が任意の値 (例:任意のオブジェクトのリスト) に対してパラメタライズできること.\nML と Lisp はこれを持つ. Java は非 Object な型のために, これを完全に持つとは言えない.\n全てはオブジェクトなり    全ての値はオブジェクト. Smalltalk では真だが, Java では (int 等のため) 真ではない.\nメッセージを送ることだけができる (All you can do is send a message,    AYCDISAM) = Actor モデル\nオブジェクトを直接いじることはできず, それと通信する, もしくはそれを起動することのみができる. Java における field の存在はこれに反する.\n仕様継承 = サブタイピング    ふたつの異なる型で, 一方の型の値が もう一方の型の値として使われても型の正当性を破らないことを言語が保障できるようなもの.\n(例: Java のインタフェース継承).\n実装継承, 再利用 ひとまとまりのコードを書いたら, それと似たコード    (そのスーパーセット) が制御された方法で生成できる.\nつまりコードをコピーして編集する必要がない. 制限された, 特殊な抽象化である. (例:Java のクラス継承).\n「関数の積和 (sum-of-product-of-function) 」パターン    オブジェクトは (実質的に) 有限の簡単な名前の集合から選ばれるキー引数を第一引数に取り, それによってメソッドを呼び出す関数として動作する.\nBooks     オブジェクト指向入門  上下巻あるみたい. Amazon.co.jp: オブジェクト指向入門 第 2 版 原則・コンセプト  Amazon.co.jp: オブジェクト指向入門 第 2 版 方法論・実践    "},{"id":173,"href":"/notes/20220401042325/","title":"📝コーディング規約概論","parent":"🎓Keido HOME","content":"コーディング規約やスタイルについての一般論をまとめる.\n命名規約については別ページに移動 =\u0026gt; 📝命名規約概論.\n各論     📝Clojure コーディング規約と慣習まとめ  🎓１行の長さ80文字問題と個人的な見解    どうも一般論がよくわからないので推測も兼ねてまとめる.\nまずコードとテキストという２つの分類ができる.\nコードに関してはコーティング規約があったほうが統一感があってよい. かつてLinuxは80文字だった. これは当時のディスプレイサイズを考慮したもので2020には適切でないとして100charに緩和された.\nテキストメールもLinuxにならい80文字, またはさらに少なめの76文字にする慣習が生まれた. これはみやすさのため.\nゲームチェンジャーはWebのCSSによって自動折り返しが登場こと. Webだとレスポンシブに自動で調整することができる. そのため手動で改行しなくてもよくなった.\nこれからのテキストの折り返しは基本的にエディタなりブラウザなりが自動で折り返しをしてくれることを期待して書くのがよい. もちろんみやすさのための折り返しなのでより見やすいように手動で調整するのはよい\nまたコードに関しては規約は必要なため, 80なり100なりのなんらかのルールが必要. 個人的なルールに留めるなら自分がつかっているディスプレイサイズに最適なものがいい.\n  refs.  メールの１行が78文字の理由【日記 2019/10/23】 Linuxカーネルコード、1行の文字制限を80字から100字まで緩和 | TECH+    "},{"id":174,"href":"/notes/20220214050955/","title":"📝コンパイラ","parent":"🎓Keido HOME","content":"コンパイラ, またはコンパイリング技術まとめ.\nコンパイル方式    AOT compilation    事前コンパイル, AOTはAhead-of-timeの略.\nアプリケーション実行前に事前にコンパイルすること.\nJVM系言語のバイトコンパイルの文脈でよく登場する. C言語やC++では事前コンパイルが当たり前のため, 単にコンパイルと言われる.\n対義語はJITコンパイル.\nrefs:\n Ahead-of-time compilation - Wikipedia  事前コンパイラ - Wikipedia    JIT compilation    実行時コンパイル, JITはJust-In-Timeの略.\nソフトウェアの実行時にコードのコンパイルを行うことで実行速度の向上を図る.\nインタプリタのJITコンパイルによって高速化！という文脈で登場することが多い. またはJITによってJavaでもJShellのようなREPLを実現する.\n対義語はAOT.\nrefs:\n 実行時コンパイラ - Wikipedia  Active Recalls    AOTコンパイルとJITコンパイルの違いはなんですか？    AOTは事前に機械語にコンパイルする, JITは実行時に機械語にコンパイルする.\n"},{"id":175,"href":"/notes/20220327060248/","title":"📝コンフォートゾーン","parent":"🎓Keido HOME","content":"ref: 💡ダンテの神曲との関係\n🏷心理学\n"},{"id":176,"href":"/notes/20220309190147/","title":"📝システム制御パターン","parent":"🎓Keido HOME","content":"信頼性に関わる設計パターンまとめ.\nわたしがかつてF通ストレージシステムのシステム制御チームとして命を賭けた(= 爆死)領域.\nup: 📂ソフトウェア設計\nFault tolerant    フォールトトレラント.\n フォールトトレラントシステム - Wikipedia  構成部品の一部が故障しても正常に処理を続行すること.\nFault tolerant の条件    Wikipedia より.\n1 単一障害点がないこと (障害に対して全体の障害とならないよう対策が施されていること)) 2 単一故障点がないこと (ハードウェア故障についても同様) 3 障害部品の隔離ができること (部分縮退) 4 障害の伝播を防ぐこと 5 代替モードがあること\ndependable system    高信頼システム. 以下の要求を満たす.\n 可用性 \u0026hellip; システムがすぐに使えるようになるという性質. 信頼性 \u0026hellip; システムが障害をおこすことなく実行しつづける性質. 安全性 \u0026hellip; システムが一時的に正常にどうさしない状況でも, 重大な問題が生じないこと 保守性 \u0026hellip; システムが容易に回復できること.  システムの状態について\n 故障 (fail): システムが予定した行動をとれなくなった場合 エラー (error): 障害を引き起こすかもしれない状態. エラーの要因を障害 (fault) という.  システム制御とは, 以下をさす.\n 障害を防ぐ 障害を除去する 障害を予測する  障害は以下に分類される\n 過渡障害 \u0026hellip; 一度だけ発生して消滅するもの 間欠障害 \u0026hellip; しばしば発生するもの 永久障害 \u0026hellip; 欠陥が除去されるまで繰り返し存在し続けるもの  single point of failure    単一障害点. 冗長化がされていない部品.\n冗長化     レプリケーション  同じシステムの複製を複数用意し, それら全部に同じ処理を並列に実行させ, 定足数を満足した結果を正しい結果として採用する.\n 冗長性  同じシステムの複製を複数用意し, 障害が発生したら予備のシステムに切り替える.\n 多様性  同じ仕様の異なる実装のシステムを複数用意し, レプリケーションのようにそれを運用する. この場合, 各システムが同じ障害を発生することがないと考えられる.\nCommunication Protocol Styles    Multicast    決められた複数のネットワーク端末 (ノード) に対して, 同時にパケット (データ) を送信する事.\n マルチキャスト - Wikipedia  マルチキャストは UDP を使用する. 信頼性が求められる情報通信には向かない.\nTree-Based Multicast と組み合わせることも. 最小探索木を作成して, Multicast.\nOrdering    順序性を保証するために 3 つの代表的なアルゴリズムがある.\n FIFO ordering  Multicasts from each sender are received in the order they are sent, at all receivers.\n casual ordering  Multicasts whose send events are causally related, must be received in the same causality-obeying order at all receivers.\n Total ordering  高信頼クライアントサーバ間通信    RPC エラーのリカバリ方法のまとめ. (分散システム p340)\n  クライアントからサーバの位置か特定できない場合\n  クライアントからサーバへの要求メッセージが喪失した場合\n  サーバが要求を受けたあとにクラッシュした場合クライアントはタイムアウトにしかみえない. 対処は 3 つある.\n at-least-once semantics 最低一回リトライする at-most-once semantics リトライせずに異常を通知 なにもしない. 異常を無視.    サーバからクライアントへの要求メッセージが喪失した場合\n  クライアントで要求メッセージを送信後に障害が起きた場合\n  高信頼グループ間通信    Reliable Multicalsing (分散システム p346).\nMake sure that all of them receive the same updates in the same order as each other.\n  仮想同期 (Virtual Synchrony)  Gossip (Epidemic)-Style Multicast (Protocol)    Gossip はうわさのこと. 人のうわさがあっという間に広まるのには理論的根拠があった.\nMulticast には以下の課題がある\n Nodes may crash Packets may be dropped 1000\u0026rsquo;s of nodes  Multicast 通信で, 特定のグループに情報を伝達するためのよい手段.\n epidemics とも呼ばれている. 速く, 信頼性があり, スケーラブル. Amazon EC2, S3 Cassendra NNTP  あるノードが通信を受信すると, ランダムに選んだ n つのノードにメッセージを送信する.\nウワサや伝染病が広まるように, 情報が伝達していく.\n Gossip protocol - Wikipedia, the free encyclopedia  Unicast    ユニキャスト.単一の送信相手を指定して, データを送信する. TCP を利用することが多い.\nBroadcast    不特定多数のノードに, 同時にパケットを送信すること.\n ブロードキャスト - Wikipedia  高コスト.\nLeader Election    選任アルゴリズム.\n通常, 分散システムでは, Coordinator が存在する. Coordinator で異常が発生したさい, 次の Coordinator を決定する必要がある.\nまた, 異常な Coordinator が復旧したときに Coordinator を戻す必要がある.\n古典的な Coordinator を決定するためのアルゴリズムは以下.\n Bully algorithm Ring algorithm  実際の実装例.\n Google Chubby Apatch ZooKeeper  Bully Algorithm    Bully (ガキ大将) アルゴリズム. つよいものが勝つというもの.\n CS 551: Synchronization, Bully Election Algorithm Example Bully algorithm - Wikipedia, the free encyclopedia  3 種類のメッセージがある.\n Election Message: Sent to announce faster election Answer Message: Respond to the election message Coordinator message: Sent to announce the identity of the elected process  手順は以下\n あるノードが Master の異常を検出したとき, Election を開催する. Master が異常状態から復旧したときも, Election を開催する. あるノードは自身よりも高い ID をもつノードにたいして, Election Message をおくる. (生存宣言) Election Message をうけとったノードは, Answer Message をかえす. そして, 自身よりも高い ID をもつノードにたいして, Election Message をおくる. 2, 3 が続いた結果, どのノードからも応答がない, 送信するノードがない場合に, そのノードが Master となる. Master は Coordinator messag をおくる.  Ring Algorithm    リング上にノードの ID が割り振られる. あるノードは自身のとなりにならぶノードにメッセージを送る.\nとなりとなりにメッセージをおくることで, リングを一周したら, リングを構成するノードの生存確認がとれるので, もっとも高い ID をもつノードが Master になる.\n CS 551: Synchronization, Token Ring Election Algorithm Example  Bookmarks     Distributed Algorithms http://www.hpcs.cs.tsukuba.ac.jp/~msato/lecture-note/dsys-2014/lecture-dist-mutex.pdf  Failure detector    分散システムのノードの中で, 異常検出を担うもの.\nIn distributed computing, a failure detector is an application or a subsystem that is responsible for detection of node failures or crashes in a distributed system.\n Failure detector - Wikipedia, the free encyclopedia  以下の論文で提出された概念.\n Unreliable failure detectors for reliable distributed systems Chandra – Toueg consensus algorithm - Wikipedia, the free encyclopedia  Failure Detector の解説を噛み砕いて書いてある.\n FailureDetectors  Failure Detector の異常検出方法    2 種類のパターンしかない.\nAlive - Suspected - Failed という 3 つの状態遷移がある.\n故障したかを確認するのに, タイムアウトの仕組みを使うことが多い\nAck-Ping Protocol    能動的にプロセスがお互いに\u0026quot;生きてますか\u0026quot;という旨のメッセージを送信しあう.\n A は B に T 秒ごとに ping を投げる. B は A に ack を応答する. A は B からの応答が 2T 秒 以内が帰ってこなければ B を異常と判断. タイムアウトは 2T 以内.  Heartbeating Protocol    受動的に相手からの通信をまつ.\n B -\u0026gt; A へ T 秒ごとに heartbeat を投げる. A は T 秒ごとに heartbeat を受信する. A は B からの heartbeat が 3T 秒間なければ, A は B を異常と判断.  Faulure Detector の特徴       Property Description     Completeness each failure is detected.   Accuracy there is no mistaken detection.   Speed Time to first detction of a failure.   Scale Equal Load on each member/ Network Message Load.    (No bottlenecks, single failure point)    HeartBeating    ネットワーク上で, コンピュータやネットワーク機器が自身が正常に稼動していることを外部に知らせるために送る信号.\n ハートビートとは 【 heartbeat 】 - 意味/ 解説/ 説明/ 定義 : IT 用語辞典  Keep-Alive ともいう.\n実施方法は, いろいろ.\n Centralized Heartbeating -\u0026gt; scale において x. Ring Heartbeating -\u0026gt; Accuracy において x All-to-all Heartbeating -\u0026gt; o Gossip-Style Heartbeating -\u0026gt; All-to-all よりも効率的.  Membership protocols    メンバリストを互いに送信しあって, 同期をする方式.\n Gossip-style SWIM  Gossip-style Heartbeating    Better All-to-all Heartbeating.Probabilistic Failure Detector.\nMulticast 通信で, 特定のグループに情報を伝達するためのよい手段.\n epidemics とも呼ばれている. 速く, 信頼性があり, スケーラブル.  すべてのノードに heartbeat をするのではなく, ランダムに選出したノードに対して heartbeat を実施する.\nLoad (負荷) は N に比例しないという特徴がある. つまり, いくらでもノードを動的に拡張できるということ.\nGossip はうわさのこと. 人のうわさがあっという間に広まるのには理論的根拠があった.\nあるノードが通信を受信すると, ランダムに選んだ n つのノードにメッセージを送信する.\nウワサや伝染病が広まるように, 情報が伝達していく.\n Gossip protocol - Wikipedia, the free encyclopedia  Amazon EC2/S3 で利用されている.\nSWIM Membership Protocols    SWIM (スケーラブル, 弱一貫性のあるプロセス·グループ·メンバーシップ·プロトコル)\ndirect-ping と indirect-ping の両方を利用する.\nping-ack ベースのプロトコル.\n first detection time が 一定. process load が一定 (Scalable)  だれかさんの和訳.\n https://gist.github.com/masahitojp/8430314  Bookmarks    なんか, MOOC と同じ絵が載っているスライド見つけた.\n http://www.cse.buffalo.edu/~stevko/courses/cse486/spring13/lectures/07-failure_detectors.pdf  Outage (停電)    以下の要因で停電にある. 70%は人間のミスで発生する.\n Power outage Over-heating Human error Fire DOS Attack  References    Fault-tolerant Patterns    Fault-tolerant で利用される概念がコンパクトにまとまっている.\n http://www.slideshare.net/ufried/no-crash-allowed-fault-tolerance-patterns  Fault-tolerant のパターン. POSA と同じ出版社.\n Amazon.co.jp: Patterns for Fault Tolerant Software (Wiley Software Patterns Series) 電子書籍: Robert Hanmer: Kindle ストア  上の本の書評\n Patterns for Fault Tolerant Systems - copton  Pattern についてまとまった PDF.\n http://www.dcl.hpi.uni-potsdam.de/teaching/depend13/07_ftpatterns.pdf  "},{"id":177,"href":"/notes/20220323121452/","title":"📝ソフトウェアアーキテクチャ概論(Software Architecture Basic)","parent":"🎓Keido HOME","content":"ソフトウェアアーキテクチャ概論.\nup: 📂ソフトウェア設計\n ソフトウェアアーキテクチャ用語まとめ    ソフトウェアアーキテクチャに関わる用語の整理.\n文脈や人によって説明が異なるところがやっかい. しかしだからこそ共通点を抽象することでまとめることに価値はある.\nInterface    外部との境界.\nBoundary    Clojure Duct Framework: Boundaries の文脈での説明.\n\u0026gt; Boundaries are protocols that provide an interface to an external service.\nClojure Protocol とはポリモーフィズムにおける操作抽象であるので, その意味するところはinterfaceのグルーピング \u0026amp; 抽象化.\n よくDatabaseの例が挙げられる. これはシステムが10年の寿命対してだいたい5年もたてば新しい技術へのreplace開発が必要になるので事前にadaptiveに開発しておこうというベストプラクティスだが, 個人開発には必要ないかもしれない.\nAdapter    Controller    Presenterの対概念.\nPresenter    Coltrollerの対概念.\nGateway    "},{"id":178,"href":"/notes/20220316182358/","title":"📝ソフトウェア開発環境(IDE)","parent":"🎓Keido HOME","content":"up: 📂ソフトウェア開発\n🏷Linter    🏷Formatter    "},{"id":179,"href":"/notes/20220310095153/","title":"📝データ指向プログラミング","parent":"🎓Keido HOME","content":"データ指向プログラミング(Data-Oriented Programming)まとめ\n up: 📁Programming Paradigms  データ指向プログラミングとは    データ指向プログラミング(Data-Oriented Programming, DOP).\nデータ駆動型プログラミング(Data-Driven Programming)とも呼ばれる.\nデータ駆動設計(Data-DrivenArchitecture)と混同しがち. これはドメイン駆動設計の業界用語.\nData-Oriented Programmingの方がClojure界隈で使われているようだ.\nまたデータ指向設計(Data-Oriented Design)という用語がゲーム業界やC++界隈で使われているように見える(たぶん違う概念).\nデータ指向プログラミングのコンセプト    📚Data-Oriented Programming by Yehonathan Sharvit より.\n Separate code from data. Model entities with generic data structures Data is immutable Data is Comparable by value Data has a literal representation   Thinking in Data の動画もよい.\nClojureはDefaultでData-Oriented Programmingできるので, どちらかというとClojureのDataに対する設計思想みたいなものが感じられた.\ndata as code example    コードをデータとして扱う. 以下具体例.\nAnt    Javaのビルドツール.\n data: XMLでビルド, メンテナンス, テストなどの仕様を記述して code: Ant プログラムでbuild.xmlを読み込んで処理を実行, xxx.jarを生成.  XMLで記述していくところに拡張性の無理があったが, こうやって宣言的に仕様を定義するところにはインサイトがあった.\nClojure Compiler    Clojureのcompilerは, Clojureのcodeをdataとして受け取り(data as code), 評価して別のデータやコードを返す.\nclient-server model    Web ServerはClientからJSONを受取り, なんらかの処理をしてJSONを返す.\nfirst-class data    (詳しく調べてないのであとで書き直す可能性あり).\nおそらく最近できた造語で, 第一級オブジェクト(first-class object) の中で特にデータに着目してプログラムを組み立てるときの文脈で出る言葉.\nデータはImmutableでPersistent. ドメイン駆動設計の値オブジェクト.\n📚Data-Oriented Programming by Yehonathan Sharvit    Data-Oriented Programming の書籍を書いた人. Manningより出版.\nこの書籍はJavaで書かれている. おそらく, Clojureではこのパラダイムはよく知られているので, 他の言語のコミュニティへ紹介したいという意図がありそう.\n2021に投稿されたYoutube動画はいくつもあるがだいたいスライドは同じ.\n Data Oriented Programming in Practice - Yehonathan Sharvit - YouTube Data-Oriented programming - slide  どちらかというとblogに書籍の内容の一部が書いてあるのでこっちがわかりやすかった.\n https://blog.klipse.tech/ Data-Oriented Programming: A link in the chain of programming paradigms | Yehonathan Sharvit Principles of Data Oriented Programming | Yehonathan Sharvit  オブジェクト指向プログラミングとの比較    オブジェクト指向(OO)ではドメインをオブジェクトでモデリングする. オブジェクトはMutableなデータ(aka. 状態)とそれを操作する特定の関数をひとつのデータとして扱う.\n Write code as methods inside classes Encapsulate data as members inside classes  データ指向(DO)ではドメインをImmutableなデータの集合でモデリングする. データは関数で操作するが, その関数は汎用的=特定のデータに依存しない.\nOOの世界では, 世界をオブジェクトでモデリングすることを徹底的に洗脳される. その結果データは透明性を失い, 汎用的な関数による操作もできない.\nカプセル化やインタフェースはMutableなデータを扱う上でのGood Practiceであるが, そもそもデータ構造が同じでImmutableであればいいのでは？という話になる.\ncf. 📝オブジェクト指向プログラミング\n関数型プログラミングとの比較    データを第一級データ(First-Class Data)をベースにしてプログラムを組み立てるのがデータ指向の考え方.\n一方, 関数型プログラミングは第1級関数が大事な概念.\nfirst-class Data = first-class object - first-class function\nデータ指向という言葉自体がまだ知名権を獲得していない造語のイメージがある. 関数型プログラミングとして慣れ親しんでいるパラダイムの中で, さらに不定普遍のデータを中心にプログラムを書いていこうという想い.\ncf. 📝関数型プログラミング\nReferences     Data-Oriented Programming - Yehonathan Sharvit, Manning What is Data Oriented Programming? | Yehonathan Sharvit  Active Recalls    データ指向プログラミングの文脈におけるData-Oriented/Data-Drivenとはどのような概念ですか？    第一級データ(First-Class Data)をベースにしてプログラムを組み立てる概念.\nfirst-class Dataとは first-class object - first-class functionのこと.\n"},{"id":180,"href":"/notes/20220309184220/","title":"📝デザインパターン","parent":"🎓Keido HOME","content":"GoF デザインパターン.\nデザインパターン (ソフトウェア) - Wikipedia\nパターンとは    建築環境に繰り返し現れる課題を解決に導く具体的な方策を記述したもの.\nアレクサンダーのパターン形式     パターン名 写真 上位パターンへのつながり 本文 下位パターンへのつながり  パターンランゲージ    建築において繰り返し現れる構造を再利用しやすい形式でまとめたもの. あるいは, パターンを集めて一つの体系としてまとぬあげたもの.\n建築家クリストファーアレクサンダーが考えた建築手法.\n マイスターになるためには, 型をにつけ, 型を破る! パターン, Wiki, XP,を読んだ読書メモ | Futurismo  時を超える建築の道    パターンランゲージを記した建築理論. 本の題名.\n角谷信太郎さんのおもしろいはなしの youtube 動画も見つけた.\n https://www.youtube.com/watch?v=SctvxjoKDGA  無名の質    生き生きとした建築や街が備えている特性. 古い街並みに潜む住みやすさや美しさ.\n生成に関するデザインパターン    Factory の原則    生成と実装を分離することで, プログラムはシンプルになる.\n 生成パラメータの指定方法をシンプルに 生成後の管理をシンプルに 生成するオブジェクトの指定方法をシンプルに  特定のケースで特定のオブジェクトを生成するのは手続き思考的.\n2 つをわけて考えることで設計に集中.\n 動作方法 生成,管理方法  Factory Method    オブジェクトの生成を行う時のインタフェースを規定して, インスタンス化するクラスを決定するのはサブクラスに任せる.\nfactoryMethod の中でオブジェクトの生成をすることで, 生成を生成オブジェクト (メソッド) 内にカプセル化.\nswitch 文は Abstract Factory によってリファクタリング可能.\n Factory Method パターン - Wikipedia 状態ありはプロトタイプパターンで, 状態なしはファクトリメソッドで実装 (Java) | Futurismo https://gist.github.com/db8a24ed41d6806f4187  C 言語での応用    C 言語で Abstruct Data Type な設計をつかうときの常套手段.\nint createInstance (void) { return calloc (4); } int destroyInstance (int ptr) { free (ptr); return NULL; } int main (void) { int *instance = createInstance (); instance = destoryInstance (instance); return 0; } 使いどころ    グループ化されたオブジェクトについて,\n 生成用オブジェクト (Creator) 振る舞い用オブジェクト (Product)  のペアを作成するとき.\nAbstract Factory    関連するオブジェクト群を, その具象クラスを明確にせずに生成するための インタフェースを提供する.\n Abstract Factory パターン - Wikipedia  関連するインスタンス群を生成するための API を集約することによって, 複数のモジュール群の再利用を効率化することを目的とする.\n実装は意識せずに, インタフェース (API) のみで, 抽象的な部品をつくりあげる.\nFactory Method 自体のカプセル化. マルチ Factory Method. Factory Methods.\n Factory Method と Abstract Factory の違いを順に理解する | Futurismo  Builder    オブジェクトの生成手順が複雑な場合に, その生成過程をカプセル化する.\n Builder パターン - Wikipedia エレガントな Effective Java の Builder Pattern を実装してみた | Futurismo  ドメイン駆動設計でいうところのエンティティオブジェクトを生成する Factory.\n 抽象データ型とドメイン駆動設計の関係について | Futurismo  Prototype    生成するオブジェクトの原型をコピーして新しいオブジェクトを生成する.\n Prototype パターン - Wikipedia 状態ありはプロトタイプパターンで, 状態なしはファクトリメソッドで実装 (Java) | Futurismo  Abstract Factory と似ている.\n new でオブジェクトを生成すれば Abstract Factory. clone をつかう場合の Prototype.  複製を作成するためのメソッドを用意する. といういたって単純なもの.\nプロトタイプ が複製を担当し, それ以外の生成における操作をクライアントが 担っている.\nMap にテンプレートを登録しておいて, 利用するときに複製する. バイナリデータをマップにいれておいて, キーとなる名前をつけて管理する, など.\nJava には, Clonable インタフェースがある.\n Cloneable (Java Platform SE 6)  クラスの数をかなり減らすことができる.\n利用シーン     Abstract Factory パターンでなされるように,  クライアント・アプリケーションにおいてオブジェクトの生成者をサブクラスにすることを回避する\n 標準的な方法 (例えば\u0026rsquo;new\u0026rsquo;) で新しいオブジェクトを作ることによる  固有のコストが所与のアプリケーションにとって高すぎる時にそれを回避する.\nSingleton    システム内で生成可能なインスタンス数をひとつだけに制限する.\n Singleton パターン - Wikipedia Java のユーティリティクラスでシングルトンパターンをためす | Futurismo  一般的なシングルトンパターンの実装方法は以下.\n static method private な 定数に オブジェクトを保存 オブジェクトは getInstance () メソッドで取得  各 Factory の違い     デザインはしばしば,\n 比較的に複雑でなく, カスタマイズしやすく, サブクラスを急速に増やす  ファクトリメソッドを用いるところから出発\n一層の柔軟性が必要となる箇所が発見されるに伴い,より柔軟だが複雑な Abstract Factory, Prototype, Builder へと発達してゆく.\n  Prototype パターン - Wikipedia より引用:  Factory Method    ファクトリのクライアントとなるオブジェクトが, ファクトリオブジェクトにインスタンスの生成を委譲する.\n 親クラスである Creator クラスが子クラスである  ConcreteCreator クラスにオブジェクトの生成を委ねる\n Creator クラスと ConcreteCreator クラスとの関連である. 継承 [オブジェクト生成] の抽象化にポイントを置いたパターン  Abstract Factory    親クラスであるファクトリが, 実際のオブジェクトの生成をサブクラスに委譲する\n Client のインスタンスが ConcreteFactory のインスタンスにオブジェクトの生成を委ねる オブジェクト同士の関連 委譲 [関連するオブジェクト群をまとめて生成するための手順] の抽象化  参考:     Abstract Factory パターン - WTOPIA v1.0 documentation Abstract Factory パターン と Builder パターンの違い オブジェクト思考: Factory (ファクトリ) パターン  構造に関するパターン    Adapter    インタフェースを変換することにより, インタフェースに互換性がない クラス同士を接続する.\n Adapter パターン - Wikipedia  単なるラッパークラスとも言える.\nラッパー方法は 2 つ.\n  継承でラッパーする.\n  委譲でラッパーする.\n  Adapter, Facade, Proxy パターンの違いのメモ | Futurismo\n  ここでは, ConcurrentLinkedQueue と ConcurrentArrayQueue を生成時に交換するために, Adapter をつかっている.\n Java で Producer-Consumer Pattern を実装してみた | Futurismo  Bridge    クライアントがアクセスするクラス (インタフェース) と実装クラスを分離して, それぞれを独立に変更できるようにする.\nオブジェクト指向のこころの本にとても詳しく書いてある.\n Bridge パターン - Wikipedia  これぞ, オブジェクト指向の本質! みたいな.\n インタフェースを用いて設計する.  機能追加と機能実装の組み合わせ爆発を抑止することができる.\n Java で Bridge パターンを実装をしてみた | Futurismo  Composite    部分-全体階層を表現するために, クラスの木構造に組み立てる.\n同一のクラスから派生したサブクラスを木構造のノードとし, クライアントは木構造の任意の部分を同一のインタフェースで扱える.\n Composite パターン - Wikipedia コンポジット・パターン (Composite Pattern) と TkComposite についてしらべた | Futurismo  別名, フォルダパターン. フォルダには, フォルダとファイルがある. こっちの名前のがわかりやすいし, 覚えやすい.\nDecorator    サブクラス化ではなく委譲により, クラスに新しい機能を追加する.\n Decorator パターン - Wikipedia  ポイントは, オブジェクトの委譲方法が,\n 集約ではなくてコンポジション 継承ではなくてコンポジション  LinkedList 構造.\n 動的に機能追加!Java で Decolator パターンを実装してみた | Futurismo  Facade    複数のクラス群からなるサブシステムにアクセスするための, インタフェースを提供する.\n Facade パターン - Wikipedia  facade とは, 正面という意味.\n Adapter, Facade, Proxy パターンの違いのメモ | Futurismo  Proxy    オブジェクトへのアクセスをフックするための代理オブジェクトを提供する.\n Proxy パターン - Wikipedia  Proxy は英語で代理人.\nWindows のデスクトップショートカットもプロキシ.\n本物のオブジェクトにアクセスするまえにクッションを置くことで, そこに機能追加できる.代理プラスアルファの機能をもつ.\n  ログ\n  トレース\n  キャッシュ\n  モック\n  Adapter, Facade, Proxy パターンの違いのメモ | Futurismo\n  Flyweight    一度生成したインスタンスはプーリングしておき, 必要なときに取り出して使う.\n Flyweight パターン - Wikipedia Java のユーティリティクラスはシングルトンパターン/ フライウェイトパターンで実装する | Futurismo  シングルトンパターンはフライウェイトパターンと合わせて利用されることがおおい.\n特徴は,\n private な 変数に オブジェクトを保存. オブジェクトが存在すれば, getInstance で渡す. オブジェクトが存在しなければ, オブジェクトを作成して getInstance で渡す.  wikipedia から説明引用    その時点で対象のインスタンスが生成されていない場合\n 対象のインスタンスを新たに生成する. 生成したインスタンスをプールする (言い換えると, メンバのコンテナオブジェクトに格納する). 生成されたインスタンスを返す.  対象のインスタンスが既に生成されていた場合\n 対象のインスタンスをプールから呼び出す. 対象のインスタンスを返す.  振る舞いに関するデザインパターン    Command Pattern    動作を表現するオブジェクト.\n動作とそれに伴うパラメータをカプセル化したもの.\n Command パターン - Wikipedia Java で Command Pattern を実装してみた | Futurismo  特徴     手続きに必要なパラメータの一時格納場所として便利. 関数呼び出しのためのパラメータを集めて, 後で使用するためにコマンドを保存しておくことができる. 保存されたデータ構造に対する追加, 削除が可能になる. コマンドの生成と実行のタイミングの分離.  Chain of Responsibility    責務を持たせたオブジェクトの Chain に 要求を渡していく.\n Chain of Responsibility パターン - Wikipedia  要求は,\n そのオブジェクトで処理できればそこで処理する そのオブジェクトで処理できなければ, 次のオブジェクトに渡す.  参考記事:     Java で Chain of Responsibility Pattern を 末尾再帰で実装した | Futurismo  Interpreter    文字列からなる構文を構文解析 (Interprete) し, 構文を表現したオブジェクト構造ともとの文字列を関連付ける.\n Interpreter パターン - Wikipedia  Iterator Pattern    オブジェクトの集合 (データ構造, コンテナ) があるとき, その集合の内部構造はカプセル化したままで, 要素に対して順にアクセスする方法を提供する.\n イテレータ - Wikipedia Iterator パターン - Wikipedia Java で Iterator Pattern を実装してみた | Futurismo  コンテナオブジェクトの要素を列挙する手段を独立させることによって, コンテナの内部仕様に依存しない反復子を提供することを目的とする.\n言語でサポートしていることがおおい. 拡張 for 文, for-each 文などと呼ばれる.\n自前で実装するよりも, 言語に頼るほうがよい.\nJava    Collection フレームワークでは, 反復子が利用できる.\nList\u0026lt;Integer\u0026gt; list = LinkedList\u0026lt;Integer\u0026gt; for (int i; list) { System.out.println (i); } Iterator インタフェースを実装することで, 自前のクラスにイテレータを適用できる.\n Iterator (Java Platform SE 6)  Ruby    Enumerable モジュールを Mix-in する.\n module Enumerable  参考:     Iterator パターン - デザインパターン入門 - IT 専科 1. Iterator パターン 1 | TECHSCORE (テックスコア) 【プログラム設計】デザインパターン学習 \u0026ldquo;Iterator パターン\u0026rdquo; とは【オブジェクト指向】 - NAVER まとめ  Mediator    複数のオブジェクトを相互作用させる場合に, お互いのオブジェクト同士が直接参照することをなくすため, 相互作用そのものをオブジェクトとして定義する.\n Mediator パターン - Wikipedia  Memento    オブジェクトの状態を保存しておき, 元に戻せるようにしておく. オブジェクトを以前の状態に (ロールバックにより) 戻す能力を提供する.\n Memento パターン - Wikipedia Java で Memento パターンを実装をしてみた | Futurismo  Observer    あるオブジェクトに依存した複数のオブジェクトがある場合に, 被依存オブジェクトの状態変化を, 依存オブジェクトに通知する.\n Decorator パターン - Wikipedia  Ruby ではライブラリがある.\n オブザーバ・パターン (Observer) でサブウィンドウから情報を取得する | Futurismo  イベントリスナ.\nState    状態に応じてオブジェクトの振る舞いを変更したいときに, 振る舞いを別オブジェクトにカプセル化する.\n State パターン - Wikipedia 簡潔さは力なり!Ruby でステートパターン (State Pattern) を実装する | Futurismo 手続き型・オブジェクト指向型・関数型 3 つのパラダイムでステートパターン (Java) | Futurismo  ストラテジパターン | Strategy Pattern    アルゴリズムをカプセル化して, アルゴリズムを交換可能にする. ひとつの入力データに対して, アルゴリズム毎に異なる結果を出力する.\n Strategy パターン - Wikipedia 委譲のまとめと Strategy パターンの実装 (Java) | Futurismo Effective Java にのっている エレガントな Enum の使い方メモ | Futurismo  アプリケーションで使用されるアルゴリズムを動的に切り替える必要がある際に有用.\n Android Windows Linux  名前のつけかたはxxxStrategyが多い.\n変更を考慮して設計するアプローチ    オブジェクト思考のこころより引用.\n 変更内容を予測するのではなくて, どこに変更が発生するのかを予測する 実装を用いてプログラミングするのではなくて, インタフェースを用いてプログラミングする.  クラス継承よりも, オブジェクトの集約を多用する. 流動的要素をカプセル化する.    switch 文を多用したり, グチャグチャになってきたら赤信号. switch 文は流動的要素なので, その部分をクラスに分離してカプセル化する.\nクラスに分離する際は, 継承をさけて集約を多用する.\nEffective Java から    p101 戦略を表現するために関数オブジェクトを使用する\n 戦略を現すインタフェースを用意 個々の具象戦略に関してそのインタフェースを実装しているクラスを定義.  具象戦略が一度しか利用されないならば, 無名クラスで作成 繰り返し利用されるならば, public static final の フィールド or static factory method を通じて提供.    Template Method    単なる継承.\nアルゴリズムを複数のステップに分解し, それぞれのステップを抽象メソッドにする. 各ステップでのメソッドの実装はサブクラスで定義する.\n Template Method パターン - Wikipedia  システムのフレームワークを構築するための手段としてよく活用される.\nFactory Method パターンは, 内部に Template Method パターンを包含することが多い\nclass A def execute () raise \u0026#34;to be implemented\u0026#34; end end class B \u0026lt; A def execute () end end class C \u0026lt; A def execute () end end Visitor Pattern    複数のオブジェクトからなるオブジェクト構造があるときに, それぞれのオブジェクト要素に処理を追加またはオブジェクト要素の処理を変更するため, Visitor クラスを用意する.\n Visitor パターン - Wikipedia Java で Visitor Pattern を実装してみた | Futurismo  デザインパターン深堀り    カプセル化の視点で整理    カプセル化がデータ隠蔽というのは狭義の定義.\nカプセル化とはあらゆるものを隠蔽すること.\n データ メソッド 実装 派生クラス 設計の詳細 実体化の規則 型  流動的要素を探し出してカプセル化する. 委譲は手段.\nこの観点から, デザインパターンをとらえ直すと,\n   流動的要素 Pattern     アルゴリズム Strategy   状態 State   振る舞い Decorator   パターンマッチ, 型 Visitor   動作, 要求 Command   実装 Bridge   変化への反応 Observer   相互作用 Mediator   生成 Factory Method, Abstract Factory , Prototype   一意性 Singleton, Flyweight   構造の生成 Builder   集合の巡回構造 Iterator   インタフェース Adapter   システム Facade   設計の詳細 Template Method     カプセル化, 情報隠蔽, データ隠蔽 - ぐるぐる~  パターンで考える    オブジェクト指向のこころ 13 章より.\n パターンの洗い出し \u0026hellip; ドメインに存在するパターンをまずは列挙. パターンの分析・適用 \u0026hellip; 1-4 を繰り返す.  パターンの並べ替え パターンの選択と設計の拡張 追加のパターンの洗い出し 繰り返し   設計の詳細  関数型言語との関係     ラムダ式で Command パターンで書かれたコードをシンプルにする ~ ラムダ式使いへの第一歩 (1/5):CodeZine Design Patterns in Haskell : Inside 206-105  Haskell での置き換え    Pattern  Desc     Strategy ○ 高階関数を渡す   State × 状態をもたない   Momento × 状態を持たない        References    概要がかかれたページ\n http://homepage3.nifty.com/satoshis/oo/patterns.html  噛み砕かれた, わかりやすい説明.\n GoF の 23 のデザインパターンを, Java で活用するための一覧表 (パターンごとの要約コメント付き) - 主に言語とシステム開発に関して  図解で解説されている.\n サルでもわかる 逆引きデザインパターン 第 1 章 はじめてのデザインパターン はじめに  サンプルソースが豊富.\n デザインパターン | TECHSCORE (テックスコア)  Gang Of Four のインタビュー\n Episode 215: Gang of Four – 20 Years Later : Software Engineering Radio  結城浩さんの並列・平行プログラミングのパターン紹介\n デザインパターン紹介 Amazon.co.jp: パターン, Wiki, XP ~時を超えた創造の原則 (WEB+DB PRESS plus シリーズ): 江渡 浩一郎: 本  "},{"id":181,"href":"/notes/20220120032054/","title":"📝パレオさんの食事についての情報まとめ","parent":"🎓Keido HOME","content":" 「1日2食」と「8時間睡眠」でハイパフォーマー｜最高の体調-パレオな男に聞いてみた  ここで掲載されている写真に感銘をうけた. 真似したい.    "},{"id":182,"href":"/notes/20220310102005/","title":"📝フロー駆動型プログラミング","parent":"🎓Keido HOME","content":"refs: 📁プログラミングパラダイム 📝イベント駆動型プログラミング\nフローチャート    "},{"id":183,"href":"/notes/20220310124045/","title":"📝プログラミング: データ構造","parent":"🎓Keido HOME","content":"データ構造とは    データの集まりをコンピュータの中で効果的に扱うため, 一定の形式に系統立てて格納するときの形式.\n データ構造 - Wikipedia  Container: コンテナ    コンテナとはオブジェクトの集まりを表現するデータ構造. コレクションともいう.\n コンテナ (データ型) - Wikipedia  配列  スタック キュー 連想配列データと別のデータやデータ構造を一対一に関連付けて格納する  ハッシュテーブル ルックアップテーブル     線形リストデータが次の (あるいは前の) データへの参照を持つ.  グラフデータが任意の他のデータへの参照を持つ.  木構造一つの頂点から樹状に枝分かれしたグラフ.        各データ構造の詳細    Record    データと別のデータやデータ構造を一対一に関連付けて格納するもの.\nもっとも基本的なデータ型.\n Atom Tuple List  List    Tuple,Struct    異なるデータ型であっても格納できる. ベクトルやリストは型がすべて同じものしか格納できない.\n タプル - Wikipedia  Record, Struct, 構造体と同義で利用されることもある.\n 構造体 - Wikipedia data structures - tuples vs records - Stack Overflow  Tree    Stream    要素は遅延評価される. そのため, ストリームは無限の長さをもつことができる.\n 具象不変コレクションクラス - Scala Documentation  For streams, this is a by-name parameter. That\u0026rsquo;s why the second argument to Stream.cons is not evaluated atthe point of call.\nInstead, it will be evaluated each time someone calls tail on a Stream object.\n"},{"id":184,"href":"/notes/20220310123730/","title":"📝プログラミング: 型システム","parent":"🎓Keido HOME","content":"refs: 📝データ構造 📝ポリモーフィズム 📂プログラミング言語処理系\nType: 型    型, データ型, Type.\n データ型 - Wikipedia  互いに関係する値の集合. (OOP においては) 値の集合と値に対する操作の集合を一緒にしたもの.\nType System: 型システム    プログラミング言語において, その式などの部分が持つ値を, その種類 (型 (type)) に沿って分類し, プログラムが正しく振る舞うこと, といった性質について保証する手法である.\n型システムは, 型理論に基づいており, プログラミング言語の理論において最も確立された軽量形式手法である.\n 型システム - Wikipedia  型の分類    型があるかないかよる分類\n 型なし (untyped) 型あり (typed)  動的片付けと静的片付けよる分類\n 動的片付け .. 実行時に型検査 静的片付け .. コンパイル時に型検査  データによる分類\n 基本型: 言語でサポートされた型. -\u0026gt; プリミティブ型 - Wikipedia 抽象データ型 (ADT): 自身で定義した型.   代数データ型:\n 列挙型: 列挙型 - Wikipedia 直和型: 直積型:  -\u0026gt; 詳細は functional programming のページへ. 代数的データ型 - Wikipedia\n  抽象データ型\n 構造体: クラス: インタフェース:  -\u0026gt; 詳細は, OOP のページへ 抽象データ型 - Wikipedia\n    Java インタフェースは, 階層を持たない型システムを構築する.\nBookmarks     So you want to learn type theory\u0026hellip; 【翻訳】\u0026ldquo;型\u0026quot;を語る際の 7 つの重大な誤り | POSTD  Type Checking: 型検査    プログラムが型に整合性があるかどうかをチェックすること.\n コンパイルエラー: 静的 ランタイムエラー: 動的  Algebraic data type: 代数データ型    関数型パラダイムで利用される.\n 代数的データ型 - Wikipedia  それぞれの代数的データ型の値には,以下をもっている.\n 1 個以上のコンストラクタ 各コンストラクタには 0 個以上の引数  2 引数で与えられた他のデータ型の値を, コンストラクタで包んだようなもの.\n Java で代数的データ型 - いじわるだねっ  Enum: 列挙型    プログラマが選んだ各々の識別子をそのまま有限集合として持つ抽象データ型.\n 列挙型 - Wikipedia  番号を持たないカテゴリ変数. 一意の文字.\n実行時には, 番号が振られることが覆いが, 言語によっては番号はプログラマに見えないこともある.\nStruct: 直積型    内部に値を持つ型です. 他言語の構造体に相当.\nUnion: 直和型:    列挙型にフィールドを付加することで, 複数の直積型を定義したものです. 列挙型と直積型の両方の特徴を併せ持っています.\nC 言語では共用体に相当しますが, C 言語のように共用体のフィールドを選ぶことで解釈を変えることはできません.\n参考:\n Haskell 代数的データ型 超入門 - Qiita  各言語について    Visual Basic    Variant 型. なんでも入れることが出来る型だが, メモリ使用量が多いので乱用はさける.\n Variant 型とは 〔 バリアント型 〕 - 意味/ 解説/ 説明/ 定義 : IT 用語辞典  抽象データ型との比較    Wikipedia より.\n関数型言語で抽象データ型を実現する手法のひとつに, モジュールシステムによるスコープ制限を利用して, コンストラクタを掩蔽し, 型のみを公開する, という手法がある.\nデータコンストラクタそのものの代わりに, 相当する引数をとって, 目的の型の値を返すような, コンストラクタを抽象化した関数を定義し, そちらの関数を公開する.\nこの関数が, オブジェクト指向言語におけるコンストラクタに相当する.\n Haskell の代数的データ型と型クラス, instance 宣言の関係 | すぐに忘れる脳みそのためのメモ  CPMCP より.\n\u0026gt; カプセル化と多様体をあわせると, ADT になる.\nオブジェクト型では, 内部状態を持つのに対して, Haskell のような代数的データ型では, 値の集合を定義するのみで, 操作を定義する場合, 別に関数定義する.\n Haskell のモジュールの階層化と, 型クラス - パラメータ多相とアドホック多相 | すぐに忘れる脳みそのためのメモ  抽象データ型 | Abstract data type(ADT)    抽象データ型. ADT と略されることも.\n構造化プログラミングは仮想機械モデルに基づく段階的詳細化法 (stepwise refinement) をもたらしたが, データ構造の変更を行うと変更部分がソースコード中に散在してしまうという弱点があった. データ抽象の概念はその欠点を補完するものであった\n 抽象データ型 - Wikipedia  An ADT consists of a set of values and a set of operations.\n Integer 型 Value:1,2,3 Operation:+ Stack 型 Value: elemtent Operation: push, pop, \u0026hellip;  Value と Operation それ自体は State を持たない. CTMCP, p433\nバンドルされていないデータ抽象.\nrefs: 比較的わかりやすい: 抽象データ型\nラッパー    ADT に アクセスするための key (キー) を導入することで, 安全にアクセスすることができる.\n値の集合に直接アクセスさせないための操作.(CPMCP p210)\n 値を安全に保持するためには, 鍵 (key) を利用して (包む) 操作を追加すればよい.   Key={NewName} SS={Chunk.new w (Key:S)} 包み, ほどきを行うデータ抽象をラッパーと定義する.\nproc {NewWrapper ?Wrap ?Unwrap} Key={NewName} in fun {Wrap X} {Chunk.new w{Key:X}} end fun {Unwrap X} try W.Key catch _ then raise error (unwrap (W)) end end end end 以下のように, Wrap, Unwrap する.\nS={a b c} SS={Wrap S} S={Unwrap SS} Example    Diference between ADT and Object. Stack をつかった実装の違い.\nADT    local Wrap Unwrap in {NewWrapper Wrap Unwrap} fun {NewStack} {Wrap nil} end fun {Push W X} {Wrap X|{Unwrap W}} end fun {Pop W X} S={Unwrap W} in X=S.1 {Wrap S.2} end fun {IsEmpty W} {Unwrap W}==nil end end この手法は Stateful ADT という.\nそして, C 言語では, こうやってデータ抽象化を行うことがおおい. もちろん関数ポインタ配列を使えば C 言語でも Object をつくることができるが, 実際にはそこまでやらない. (面倒)\nObject    オブジェクトでは, データに対する操作はプロシージャ変数として扱われることに注目.\nfun {NewStack} C={NewCell nil} proc {Push X} C:=X|@C end proc {Pop X} S=@C in X=S.1 C:=S.2 end fun {IsEmpty} @C==nil end in stack (push:Push pop:Pop isEmpty:IsEmpty) end オブジェクト指向言語は, 単に Object をサポートする言語ではなくて, Abstruct Data Type も強力にサポートしている.\nObject と ADT の意味がごっちゃにつかわれているのが現実の現状.\nClass    共通のメソッドを提供する型の集合.\n"},{"id":185,"href":"/notes/20220215061448/","title":"📝プログラミングエッセイまとめ","parent":"🎓Keido HOME","content":"ネットで読める無料コンテンツまとめ.\n Xが知るべき97のこと  プログラマが知るべき97のこと ソフトウェアアーキテクトが知るべき97のこと プロジェクト・マネジャーが知るべき97のこと ゲームクリエイターが知るべき97のこと ゲームクリエイターが知るべき97のこと 2   ポールグレアム(🏷Paul Graham)  naoya_t:ポール・グレアムのエッセイと和訳一覧 ポールグレアム（Paul Graham）の日本語訳エッセー｜Jack｜note 普通のやつらの上を行け｜Jack｜note a.k.a. beating the averages Hackers and Painters - ハッカーと画家   エリック・レイモンド  The Cathedral and the Bazaar: Japanese - 伽藍とバザール Homesteading the Noosphere: Japanese - ノウアスフィアの開墾 The Magic Cauldron: Japanese - 魔法のおなべ How To Become A Hacker: Japanese - ハッカーになろう   GNUプロジェクト30周年と、「自由2.0」PDF版 | オープンソース・ライセンスの談話室  up: 📂プログラミング\n"},{"id":186,"href":"/notes/20220305093025/","title":"📝プログラミング意味論","parent":"🎓Keido HOME","content":"up: 📁Programming Paradigms\nプログラム意味論 | Semanticsとは    プログラム意味論. formal semantics, mathmatical semantics ともいう.\nプログラムの正しさや正確さを理論づけるための方法.\n形式的検証 - Wikipedia\n4 つのアプローチがある.\n 操作的意味論 公理的意味論 記述的意味論 論理的意味論  Operational semantics: 操作的意味論    Explains a program in terms of its execution on a rigorously defined abstract machine\nどのパラダイムにおいても適用できる.\n Kernel Language Abstract Machine  ref: 操作的意味論 - Wikipedia\nプログラムの正しさを数学的に証明することを目指す.\n Specification: プログラムの入力と出力を定義したものを Program: プログラミング言語によってかかれたデータ  Program が Specification を満たしているかを証明する. そのために,\n Semantic (意味の対応付け) Abstruct Machine (抽象化された実行環境)  という概念を導入する.\nProgram は kernel Language に分解され, Kernel Language の構成要素が Abstruct Machine と対応付けられる.\nSemanitic Program --\u0026gt; kernel Language -----\u0026gt; Specification Abstrucut Machine コンピュータの理論は, Kernel Language と Abstruct Machine によって離散数学 (Discrete Mathmatics) を元に議論することが可能になる.\nMathematical induction    recursive function (再帰関数) の正しさは, 数学的帰納法 (mathematical induction) で証明する.\nexample    Specification\n0! = 1 n! = n × (n-1)! when n\u0026gt;0 Program\nfun {Fact N} if N==0 then 1 else N*{Fact N-1} end end Semanitc Expression\nE={Fact → fact, N → n, R → r} (AbstcutMachine) σ={fact=(proc ... end,CE),n=0,r} (memory) CE={Fact → fact}. ( Contectual Environment) {Fact N R}, E, σ 広義の意味では, 関数に forcusing したプログラミング.\nAxiomatic semantics: 公理的意味論    Explains a program as an implication: if certain propertieshold before the execution, then some other properties will hold after the execution\n状態があるモデルに適している.ステートマシンの証明. 数理論理学に基づいてプログラムの正当性を証明する手法.\n公理的意味論 - Wikipedia\nCoq    定理証明支援系言語.\n Coq - Wikipedia プログラミング Coq Coq で独習するならどのページがいい? と聞かれたときのメモ - 簡潔な Q  モデル検査     モデル検査 - Wikipedia     VDM\nモデル検査用のソフトウェア\n VDM information web site - VDM とは?    Proof-Driven Development (証明駆動開発)    Denotational semantics: 記述的意味論    Explains a program as a function over an abstract domain, which simplifies certain kinds of mathematical analysis of the program\n宣言的プログラミングの証明に適する.\nLogical semantics: 論理的意味論    Explains a program as a logical model of a set of logicalaxioms, so program execution is deduction: the result of a program is a true property derived from the axioms\n宣言的計算モデルに適する.\n"},{"id":187,"href":"/notes/20220114074914/","title":"📝プログラミング言語用語集","parent":"🎓Keido HOME","content":"いずれ 📝Programming Base Concepts に統合するかもしれない.\n未整理な用語置き場.\n📝immutable WIKI    不変性. 一度値をセット(束縛)したらあとから変更できないということ.\n破壊的変更が起きないともいう. データが変わる心配が不要.\n📝persistent WIKI    永続性. データを変更する際に変更前のバージョンを常に保持するデータ構造の性質.\n永続データ構造と訳される.\nref: 永続データ構造 - Wikipedia\n note: deep copy vs shallow copy  ❓Active Recalls    Immutableなデータとはなんですか?    不変なデータ. つまり，値を１度セットしたらあとから変更できないデータ.\nPersistentなデータとはなんですか?    永続的データ. つまり，データを変更する際に変更前のバージョンを常に保持するデータ構造の性質.\n"},{"id":188,"href":"/notes/20211215145556/","title":"📝ベートーヴェン","parent":"🎓Keido HOME","content":"クラシック音楽の作曲家.\n🏷クラシック音楽 🏷作曲家\n💡ベートーヴェンは音楽家を職人から芸術家にした    これは Paul Grahamの Hackers and Painters のテーマとまさに同じである. (🎓作曲家が楽譜を書くのとハッカーがコードを書くことに違いはない)\nref: モーツァルトとベートーヴェンの決定的な違い | テンミニッツTV\n\u0026gt; こうした音楽家の位置付けを画期的に変えたのがベートーヴェンでした。ベートーヴェンを境に音楽家は「職人」から「芸術家」へと変容を遂げました。作曲することで依頼人から報酬を得ることはかないませんが、いわばフリーランスとして自分の作りたい音楽を一音、一音にいたるまでこだわり、自分が気に入るまで徹底的に吟味して昇華させていく。こうした芸術家の時代になったのです。\nref: ルートヴィヒ・ヴァン・ベートーヴェン〈前編〉 | Tokyo Art Navigation\n\u0026gt; 音楽家の地位を、「雇われ職人」から「自律した芸術家」へと高めた\n📚Books    📚ベートーヴェンの手紙 小松雄一郎編訳 岩波文庫    傑作といわれる楽曲はいずれも彼にとって解決しなければならぬ, 緊張度の高い生活上の問題であった. それは彼個人だけの問題ではなく, 当時の社会にとって「偉大とされるものは何か」「信仰とは何か」を市民的な立場で音楽で考えたものであった. そして彼は自分の考えを曲げず, 自我に従って規制の権威にも習俗にも屈せず生活し音楽にした.\n大切なことは, 奏者も聴衆もベートーヴェンの音楽から彼の生活の仕方を摂取し, わが身につけることである.\n彼の音楽は彼の生活から生まれているのだから, 一つ一つの作品は彼の生活が波乱に富んでいるように千変万化しながら一生涯続いている. 彼は次々と新しい課題を発見し, そのために新しく音楽様式, 用語を発展させ, 永遠の挑戦を続けている. ベートーヴェンが提起している問題と, 提起している仕方を全作品との関連でつかまえなければベートーヴェンの音楽にならない.\n1801 年 6 月 29 日    僕は惨めな生活を送っているというべきだろう. 僕は自分がつんぼです, とはとても人には言えない.\nだからこの二年来すべての社交というものをほとんど避けてきた. なにかほかの職業に携わっているのならまだしも, 僕の仕事では, これは恐ろしい事態だ.\nこの状態が続くようだったら, 半年ばかり田舎に行き, 百姓をやろうと思う. そうすればひょっとしたら事態も変わるだろう.\n諦念! なんと悲惨な逃避手段だろう. しかしそれが僕に残されて唯一の道なのだ.\n1801 年 11 月 16 日    ああ, この災いを逃れられるなら, 僕は世界を抱きしめるのだが. 僕の青春は今始まったのだと実際に感じるのだ.\n僕はこれまでいつも病弱な人間ではなかったろうか. すこし前から, 今までずっと体力がついてきたし, 精神的にもそうだ. 日に日に目標に近づいている. それは感ずるのだが, 言葉では言い表せない.\n唯, この中にのみ君のベートーヴェンは生きていけるのだ. 休息のことなど言いたもうな!\n僕には休息とは眠ること以外に知らぬのだが, それでもこれまで以上に睡眠に費やさねばならぬのは大きな嘆きだ.\n不幸・・・いや, それには耐えられない. 僕は運命の喉っ首をとっつかまえてやろう. へたばってなんかしまうものか. ああ, 麗しきかな人生, 千倍も生きるとは!\n静かな生活. いや, 僕は感ずるのだ, それには向かないと.\n1802 年 10 月 6 日 (ハイリゲンシュタットの遺書)    たびたびのこうしたことで, 僕はほとんど絶望し, もう少しのことで自殺するところだった. ただ彼女だけが, 芸術が, 僕を引き止めてくれた.\nああ, 僕には自分に課せられていると感ぜられる創造を, 全部やり遂げずにこの世を去ることはできないと考えた.\n死が, わが芸術的全才能を繰り広げる機会に恵まれないうちに来るようなことがあれば, たとえわが運命がいかに過酷なものであろうとも, 死はなお早く来すぎた憾みがあろう. 僕は死の来るやおそきを願う. よしや死が来たとしても, 僕は満足する. 死は果てしなき苦悩より僕を救いだしてくれるのではないだろうか. 来たれ, 汝の欲するときに. 僕は敢然と汝を迎えよう.\n1810 年ごろ    音楽はすべての知識や哲学よりもずっと高い啓示であることを, 考えてもみないような世界をわたしは軽蔑しないわけには参りません. 音楽は新しい創造を醸し出す葡萄酒です. そしてわたしは人間のためにこの精妙な葡萄酒を搾り出し, 人間を酔わすバッカスです. 酔いから醒めたときは, 彼らはあらゆる獲物を持っており, それを正気の世界の持ち帰るのです. 私には友人は一人もありません. 孤独で生きてゆかねばなりません. しかし, 私の芸術においては, 神は他の人よりずっと私の身近に居られることもよく承知しております.\nたいていの人は何かよいものには感動します. しかしそれが芸術家たるの資性ではありません. 芸術家は火と燃えています. で, 泣くなどしません. 私は感激の焦点に立ってあらゆる方向にメロディーを放射しなければならぬのです. それを追求し, 激情を持って再び抱きしめる. それが遠ざかってゆき, 多様な興奮の群がりの中に消えてゆきます. まもなく新たな激情がそれを抱きしめ, 私とそれとが分かちがたいものとなる. 束の間の恍惚状態にあって, あらゆる転調を行いそれを多様化しなければならぬのです. そしてついに最初の楽想を超え凱歌を上げるのです.\n御覧なさい. それが交響曲です. 実際, 音楽は精神生活を感覚的生命としてとらえられるようにする正しい媒介です. メロディーは韻文の感覚的生命です. 一つの詩の精神的な内容を感覚的につかめるようにしてくれるのはメロディーではないでしょうか? このメロディーは「ミニヨン」の歌の感覚的な情趣をすべて伝えていないでしょうか? この感覚と情趣に刺激され, さらに新しい創造が生み出されるのではないでしょうか? そうなれば精神は阻むものとてない普遍性をもつものに広がりゆきます. そうなれば単純な音楽的思想をもとにした感情の地盤の上にすべてが築き上げられるのです.\nそれがハーモニーです. そのことは私の交響曲の中で表現されつくされています. ハーモニーの融合は多面的な形態をとって感情の地盤の把握しきれぬものが, 精神的なものの総てにあるのを感じます.\n私は作品の目的を達したと感じたときでも, いつも永遠に満たされることのない飢えを感じます. しかも, 最後のティンパニーの響きで私の喜びを, 私の音楽的な信念を聴衆に叩き込んで力を出し尽くしたと感じたときにそうなのです. そしてまた子供のように新しく始めるのです.\n音楽の本質をとらえるのは精神のリズムのなす業です. 音楽は予感, すなわち天の如き知恵の霊感を与えるものであり, 精神が音楽によって感覚されるものとなったもの, 精神的認識の具象化です. 人間が空気によって生きているように, 精神は音楽によって生を得ているにもかかわらず, 精神が音楽を掴み取るということはさらにまた別のことです. 魂が音楽から感覚的な養分を吸い取れば吸い取るほどそれだけ精神は音楽との結びつきが深く豊かになるのです.\n総ての芸術と同じく音楽の基底には道徳的観念が高い目標になっています. 総ての真の感情というものには道徳的進歩があります. 音楽自身は極めつくしえぬ法則に服しており, これらの法則あまた精神が自ら啓示を表現する上で拘束し制限するのです.\nこれは芸術独自の原則です. 法則から自由になる啓示となるには神の恩寵をまたなければなりません. それは荒れ狂う奔放な力に静かな支配力が働きます. そうなると創造力は最高度に旺盛に働きます. こうして, 芸術はいかなるときにも神聖なものの代表者となるのです. 神聖なものと, 人間の関わりあいは信仰であるが, われわれがそれを芸術を経て得るものは, 神からの, 神の聖なる啓示であり, 人間の能力が到達すべき一目標となるのです.\n思いまつげの下に, あふれる涙が待ち伏せいていようとも, 確固たる勇気を奮って最初の努力を傾けて, 反抗し打ち破れ!\n無限の精神をもつ有限なわれわれは, ただ苦悩と歓喜とのために生まれた. そして, ほとんど, こういうことができよう. もっとも優れた人は苦悩と通じて歓喜を勝ちうるのだと.\n1816 年 5 月 13 日    こういうとき (悩んでいるとき) にこそその人の力が試されるのではないでしょうか. それはぶつぶつ言わないで耐え忍び, 自己の空しいことを感じ, 空虚なる物を通じて神があなたに与えられんとするその力です.\n自由と進歩のみが, 総ての偉大な創造におけると同様に芸術の世界の目的であります\n📚ベートーヴェンの生涯 - ロマン・ロラン    親愛なベートーヴェン! 彼は近代芸術の中で最も雄々しい力である. 彼は悩み戦っている人々の最大最善の友である.\n不幸な貧しい病身な孤独な一人の人間, まるで悩みそのもののような人間, 世の中から歓喜を拒まれたその人間が自ら歓喜を造りだす - それを世界に贈り物とするために. 彼は自分の不幸を用いて歓喜を鍛えだす. そのことを彼は次の誇らしい言葉によって表現したが, この言葉の中には彼の生涯が煮詰められており, またこれは, 雄々しい彼の魂全体にとっての金言でもあった.\n「苦悩を突き抜けて歓喜にいたれ! 」 (Durch Leiden Freude.)\n"},{"id":189,"href":"/notes/20220310125619/","title":"📝ポリモーフィズム","parent":"🎓Keido HOME","content":"up: 📂プログラミング言語処理系\nrefs:\n 📝プログラミング: Expression Problem 📝データ抽象(Data Abstruction) 📝抽象データ型(ADT)  ポリモーフィズム(Polymophism/多相性)とは    ポリモーフィズムとは, 各要素 (定数, 変数, 式, オブジェクト, 関数, メソッドなど) についてそれらが複数の型に属することを許すという性質.\nPolymophism, 多相性ともいう.\n同種のクラスをカテゴリに分類してまとめ, 基本的な動作・設計部分を統一することで, オブジェクトインスタンスの扱いに柔軟性と規律を持たせるための機能.\n多相型は いくつか分類できる\n アドホック多相: 関数を適用する型を制限する パラメータ多相: 具体的な型について言及しないことにより, 新しい型に対応できるようにする サブタイプ多相:  たとえば Java だと\n アドホック多相: オーバーロード パラメータ多相: ジェネリクス サブタイプ多相: 継承  refs:\n 🖊Java におけるポリモーフィズムの整理 | Futurismo ポリモーフィズム - Wikipedia Polymorphism (computer science) - Wikipedia, the free encyclopedia A Gentle Introduction to Haskell: Classes  Polymorphic type: 多相型    データ構造のコンテナ.\nデータ形式に依存しないコンピュータプログラミング方式をジェネリクスプログラミングという.\n ジェネリックプログラミング - Wikipedia  アドホック多相    オブジェクト指向におけるアドホック多相とは, オーバーロードに相当する.\n多重定義ともいう.\n 多重定義 - Wikipedia  Clojureもアドホック多相を持つ(multmethod).\nパラメータ多相    型変数    多相型は宣言されたクラス, 関数に対して, 利用時に具体的な型を与える. これを型変数 (Type variable) という.\nJava の名前つけルールがあるらしい.\n 名前付けルール - Java 入門  Generic Type: 総称型    型付けされたプログラミング言語においてデータ型の定義とそれを参照する式 (型式) の一部にパラメタを許すことによって類似した構造を持つ複数のデータ型を一括して定義して, それらを選択利用する仕組み.\n 総称型 - Wikipedia Java でのジェネリックスの使い方まとめ | Futurismo  Overload: オーバーロード    継承 (inheritance) と並んでプログラミング言語においてポリモーフィズムを実現するための一つの手段.\nSubtyping: 派生型    データ型 S が他のデータ型 T と is-a 関係にあるとき, S を T の派生型 (はせいがた, subtype) であるという.\n 派生型 - Wikipedia  基本型のデータを処理するように作られたプログラムは, その派生型のデータでも正しく処理することができる.\n基本型-派生型関係ではリスコフの置換原則 (Liskov Substitution Principle) が成り立つ.\n2 つの方法がある\n インタフェース: 型をグループで分類 継承: 型を階層構造で分類  inheritance: 継承    ほとんどのクラスベースオブジェクト指向言語では, サブクラス (インヘリタンス) が派生型の概念を実現している.\nref: 継承: Inheritance\ninterface: インタフェース    ref: インタフェース: Interface\n型クラス    Haskell の概念.\n 型は値をグループ化する. 型クラスは, 型をグループ化する. その結果, 型クラスの制約が付いた関数は, その型クラスのグループに属していない型には適用できない. インスタンス化とは当該の型クラスに所属する宣言.  この説明はわかりやすい.\n Haskell のモジュールの階層化と, 型クラス - パラメータ多相とアドホック多相 | すぐに忘れる脳みそのためのメモ  型を分類する点でいえば, Java のインタフェースと同義.\nOOP とFPの比較     オブジェクト指向はクラスでインヘリタンス 関数型は代数的データ型で選択  Modegramming Style: クラウド温泉 3.0 (2) / 代数的データ型 Modegramming Style: クラウド温泉 3.0 (3) / 代数的データ型 on Scala    References     型システム入門  Amazon.co.jp: 型システム入門 -プログラミング言語と型の理論-: Benjamin C. Pierce, 型システム入門 サポートページ 数学初心者のための「型システム入門」入門 - 廻る技術の覗き穴    "},{"id":190,"href":"/notes/20220327055825/","title":"📝モーツァルト","parent":"🎓Keido HOME","content":"tags: 🏷作曲家 🏷クラシック音楽\n魔笛     ドイツ語で書かれたオペラ. 主人公は日本の王子?  "},{"id":191,"href":"/notes/20220116195030/","title":"📝並行プログラミング","parent":"🎓Keido HOME","content":"up: 📂プログラミングパラダイム\nConcurrency.\n同一実体(Identity)    時間が経過して値が変化してもそれを指し示すものは変わらない参照.\nSoftware transactinal memory(STM)    いわゆるSTM(表記が長いじゃないか\u0026hellip;).\nref: 🔗ソフトウェアトランザクショナルメモリ - Wikipedia\n3つの重要な特性がある.\n Atomic  複数のメモリを更新しても外部からはひとつのイベントで観測される.   Consistent  更新は一貫している. 更新後のvalidationが失敗すれば全ての更新処理は失敗する.   Isolated  あるトランザクションから別のトランザクションをみることはできない.    References     📝Clojure Concurrency  Acitve Recalls    ソフトウェアの並行性と並列性の違いはなんですか?    ロックとトランザクションの違いはなんですか?    同一実体とはなんですか?    時間が経過して値が変化してもそれを指し示すものは変わらない参照.\nSoftware Transactional Memoryの３つの性質はなんですか？    単一性(Atomic), 一貫性(Consistent), 独立性(Isolated).\n"},{"id":192,"href":"/notes/20220309205315/","title":"📝初音ミク","parent":"🎓Keido HOME","content":"初音ミクハック    また初音ミクハックしたいなあ.\n 🖊iRemoconでミクミクにしてやんよ。 | Futurismo  "},{"id":193,"href":"/notes/20220110081806/","title":"📝勉強法","parent":"🎓Keido HOME","content":" 📝集中力が上がる時間管理まとめ  参照     💻Learning How to Learn - Barbara Oakley(coursera) 💻Augmenting Long-term Memory - Michael Nilsen(2018)  "},{"id":194,"href":"/notes/20220218134001/","title":"📝原田喜右衛門","parent":"🎓Keido HOME","content":"ref: 🔗原田喜右衛門 - Wikipedia 📝原田孫七郎 📝菊池氏族原田家\n 原田孫七郎の上司. ルソン壺交易、長谷川法眼と原田喜右衛門以外取引を禁じるように秀吉が許可.  ref: https://www.rikkyo.ac.jp/research/institute/caas/qo9edr000000ml88-att/b_36.pdf ルソン壺はフィリピンで日常的に使われる壺なので, そのへんに転がっている壺をタダ同然で仕入れて売りまくって稼いだのか？  千利休や秀吉がルソン壺を気に入って 値段高騰, 一時期は１壺で家１つ変えたとか.  ルソン壺ってどんなツボ？     ルソン壺は後に便所にも使われていることが発覚して叩き壊される. おそらく破産の原因はこれ. しかしルソン壺交易などでフィリピン事情に明るかったからこそ孫七郎と一緒に秀吉の命を受けて交渉の役を受けたのか？   マニラでの中国人2000人一斉蜂起を鎮圧した.  豊臣秀吉とルソン総督間の交渉 - メキシコ情報サイト「アミーゴWEB」 原田喜右衛門のマニラでの活躍の真偽最近ネットでこうした逸話を知りま\u0026hellip; - Yahoo!知恵袋  作り話の可能性あり.   学校では教えない豊臣秀吉が朝鮮に出兵した本当の理由｜小名木善行 - YouTube  t.5.00 作り話かもしれないが, 戦闘の素人2000人の蜂起など鎧と刀をつけた元は武士の商人たちにとっては結構簡単にやっつけられるのでは? たとえればいなげやとかマルエツで買い物をしているじいさんばあさんと自衛官の戦いだからね.     フィリピン人の人身売買がもとで殺害される.  NHK大河ドラマ: 黄金の日日    1978年のNHK大河ドラマに登場.\n黄金の日日 - Wikipedia\nその影響か Twitterとかで検索するとだいたい黄金の日々と関係して情報か見つかる.\n 時代劇の悪役キャラとして登場.  黄金の日日 唐十郎 - 原田喜右衛門 - YouTube 大河ドラマの歴史になお残す悪役キャラ，トリックスター？ とても演技がうまい. タガロク人か日本人か.    ドラマの中の最期のシーンでダンテ神曲の地獄の門をくぐるとき一節を引用して死んでいく. もちろんフィクションだが設定ではダンテ神曲の翻訳作業をしていたとか.\n ここを過ぎて かなしみの都。ここを過ぎて、涙の都。さばかりも つれなき海をあとにしてかくてかの 第二の国を歌わまし。人の霊 そこに清まり天高く登るにも ふさわしき者とこそなれ\n ref: 📝ダンテ: 神曲\n💡考察     悪いやつなので一族でなくてもよい.  一族の可能性の根拠は, 孫七郎が肥後熊本出身の菊池氏の可能性が書籍にあり, 孫七郎と喜右衛門が同族という記述がネットにあったからこの２つからの推論.  この２人の先祖からの言い伝えはない.   そもそも武家と商人は矛盾しているので一族から追放された可能性もある. しかし先祖に直右衛門という人がいる気がしたので名前が似ている\u0026hellip; さらに初代原田七郎と原田孫七郎という名前的なつながりも気になる.    "},{"id":195,"href":"/notes/20220218132917/","title":"📝原田孫七郎","parent":"🎓Keido HOME","content":"ref: 📝菊池氏族原田家 🔗原田孫七郎 - Wikipedia 📝原田喜右衛門\n 原田喜右衛門の部下. (しかし同じ一族とか). 秀吉の銘でスペイン領フィリピンの総督ゴメスに日本の属国になれという(ヤバイな\u0026hellip;)  台湾に同じことをしようとしに旅に出たが台湾の統一国家が見つからずに帰る.     先祖の可能性がある. mixiのコミュニティで教えてもらった.\n整理すると要点は以下の2点.\n 『姓氏家系大辞典』に菊池氏の記述. 肥後熊本の出身.   以前に長崎の商人原田孫七郎の話題に触れましたが、この原田孫七郎は下記のドラマに登場するらしい(未確認）。 黄金の日日 (NHK大河ドラマ) http://ja.wikipedia.org/wiki/%E9%BB%84%E9%87%91%E3%81%AE%E6%97%A5%E6%97%A5_%28NHK%E5%A4%A7%E6%B2%B3%E3%83%89%E3%83%A9%E3%83%9E%29 原田孫七郎は原田喜右衛門の手代とあり、 原田喜右衛門は長崎の豪商、助左を海賊と勘違いし、捕縛。誤解が解け、助左とルソンでイスパニア軍との交易を持ちかけるが、助左に断られた事から船を襲い、五右衛門に命を狙われる。人身売買が元で助左の襲撃に遭い、敗死。 なんか恐ろしげ。 原田孫七郎は定番の『姓氏家系大辞典』には菊池氏に記述があり、また、大蔵氏の流れを汲んだ菊池氏などとあるのですが、どうも肥後熊本の出らしいですね。長崎の貿易港開港で長崎にいたようですが。 肥後熊本の（大蔵の流れかどうかわからないけど？？）菊池氏原田というのは、 肥後国球磨郡原田村の菊池氏から原田氏が出ています。 菊池氏族原田氏はある情報では揚羽蝶紋を用いた記載があるとか。 肥後国球磨群に原田邑あり 『菊池系図』に「持朝―為光（号宇土）－経兼（原田七郎、弟実遠」とあるようです。 肥後 宇土古城 室町時代には宇土忠豊の養子に肥後守護菊池持朝の子為光が迎えられている。明応二年（1493）、重朝が死去すると、そのあとは若冠十二歳の能運（武運）が継いだ。能運を若年と侮った重臣隈部氏が、相良氏と結んで謀叛を起したが、能運はこれを征圧した、しかし、家中の動揺は続き、文亀元年（1501）には叔父で宇土氏を継いでいた宇土為光が守護職を狙って叛旗を翻した。 球磨郡球磨村渡に原田城あり。 原田孫七郎は肥後出身と言う話もあるので、この菊池(宇土）為光から出たとする原田氏の流れをくむ原田氏から孫七郎が出ているのかもしれませんね。 そういえば菊地系図の「経兼（原田七郎・・・」は何か通称孫七郎と関係を感じさせる名前ではありませんか。 ま、孫七郎は長崎にいたかもしれないけど、肥後出身の原田氏だということがあるようですね。菊池氏族と言うのも納得。 きつねさんはじめまして 別の原田コミュでは詳しすぎるのでこちらに移しました。 肥後国球磨群に原田邑あり 『菊池系図』に「持朝―為光（号宇土）－経兼（原田七郎、弟実遠」この流れのようですね。 ちなみに、肥後宇土古城は、室町時代には宇土忠豊の養子に肥後守護菊池持朝の子為光が迎えられている。明応二年（1493）、重朝が死去すると、そのあとは若冠十二歳の能運（武運）が継いだ。能運を若年と侮った重臣隈部氏が、相良氏と結んで謀叛を起したが、能運はこれを征圧した、しかし、家中の動揺は続き、文亀元年（1501）には叔父で宇土氏を継いでいた宇土為光が守護職を狙って叛旗を翻した。 ちなみに、菊池氏の「丸に並び鷹の羽」と似ている「丸に違い鷹の羽」は同じ九州の大蔵姓原田氏も多く用いているようです。おそらくこれは南北朝以降大蔵氏と菊池氏の深い関わりがあったからではないかと考えています。 歴史上の人物で言えば、藤原姓菊池氏族原田氏としては、原田孫七郎が秀吉の下で名前が知れていますが、菊池氏族原田氏とされます。長崎の商人だそうですが元は肥後熊本だそうで、一族の可能性がありますね。 それにしても、この菊池系原田氏が丸に並び鷹の羽というのを知ることができてすっきりしました。 経が続いているのはいいですね。系図とかはあるのでしょうか？  菊池氏族原田家初代が原田七郎経兼であり孫七郎とは名前が似ている, 孫？年代的には初代から3代離れて孫であっても説明はつく.\n通常, 経Xというのは死ぬときの最後の名前としてつけられるため 生前は経Xの名はつかない.\nさらには苗字をもつということは, 元は武士であった可能性は高い. ただし1500年代というのは比較的苗字は手に入りやすかった, 秀吉あたりから厳しくなったとか.\nひいおじゃいちゃんが直右衛門, ひいひいおじゃいちゃんが三郎だったかも. あれ, 孫七郎と喜右衛門に名前が似ているな\u0026hellip;困るな😕しかしこのX郎というのは菊池氏の流れでも宇土氏の流れでもなく名戸氏の流れかも.\n"},{"id":196,"href":"/notes/20220305082606/","title":"📝命令型プログラミング","parent":"🎓Keido HOME","content":"up: 📁Programming Paradigms\n命令型プログラミングとは    Imperative Programming, 命令型プログラミング.\n計算をプログラム状態を変化させる文の列で記述するパラダイム.\nref: 命令型プログラミング - Wikipedia\nFunction paradigm に Cell (状態) の概念を加えたもの.\nImperative programming = Function paradigm + Cell Declarative Programing の対になる概念. Imperative vs Declaretive is also Stateful vs Stateless.\n命令型パラダイムのプログラミング言語     C 言語 アセンブリ言語  関数型プログラミングと命令型プログラミングの違い    cf. 📝Functional Programming\nFunction Paradigms と Imperative Paradigm の違いは,\n Functional  状態変化しない (Immunity) 機能追加時にインタフェースの変更の影響度がおおきい.   Inperative  機能追加時にインタフェースの変更の影響度がない. (モジュール性, モジュールプログラミング) 状態変化する. 実行するたびに, 内部の状態によって結果がことなる.(副作用) 械語は命令から構成される    低レベルから見た場合, プログラムの状態はメモリの内容によって定義され, 文としては機械語の命令が相当する.\nExplicite State    明示的状態.\n 生存期間が 2 度以上の手続的呼び出しに渡るような一つの状態. 関数の実行の中に値をもつ. 手続きの引数に現れないもの.  同様なことを関数型パラダイムで実現するためには, 仮引数に状態を持たないといけない.\nCell    Explicite State (明示的状態) を表す基本型. 二つの構成要素からなる.\n 名前値 (Vaiue) 単一代入格納域への参照 (Identifier)   declare fun {Reverse L} % 空リストの cell を生成 Rs = {NewCell nil} in % リストの各要素を取り出して内部 Cell に結合 for X in L do Rs := X|@Rs end % 内部セルをリターンする. % Ruby っぽい! @Rs end {Show {Reverse [1 2 3 4]}} "},{"id":197,"href":"/notes/20220308155618/","title":"📝命名規約概論","parent":"🎓Keido HOME","content":"プログラミング言語の命名規約概論.\nNaming Conventions.\n up: 📂Software Development refs: 📝コーディング規約概論\n変数の命名規約    🏷PascalCase     複合語の先頭が大文字からはじめる. camelCaseと区別するために, CapitalCase, UpperCamelCaseと表現されることもある.  🏷camelCase     複合語の先頭が小文字からはじめる. PascalCaseと区別するために, lowerCamelCaseと表現されることもある.  🏷snake_case     複合語はすべて小文字 単語間の繋がりはアンダーバー _ Python  🏷kebab-case     複合語はすべて小文字 単語間の繋がりはハイフン - lisp-caseともいう. LISP系言語で採用. 🏷Clojure  codic    codic - プログラマーのためのネーミング辞書\n日本語からよい変数名を生成してくれるWebサービス.\n🎓個人的な命名規約に関するインサイト    とりあえず書き溜めておく. これをどうするかは後で考える.\n💡 Web API設計の命名: snake_case vs camelCase    一般的には snake_case or camelCase.\nどうも絶対的な結論はないようにみえる.\n誰がどこで使うかという観点で使いやすい方を選ぶ.\n💡3つ以上の複合語からなる変数はより大きなデータ構造とそのグループにまとめる    変数名なんて2つの複合語で収まることが多く, それ以上になるなるばより大きな抽象でグループにまとめるべきサインな気がする.\n長い変数名は見た目が悪い.\n確かに可読性のために丁寧に記述することは大事だ. C言語開発ではやたらとprefixを多用した経験がある. しかし構造体よりももっと簡単に連想配列やその抽象が構築できる令和の現在は, もっとカジュアルにデータをグルーピングしてもいいんじゃないかな？\nグルーピングすることで構造がより見いだせるようになり, コードに秩序が加わる.\n"},{"id":198,"href":"/notes/20220323034550/","title":"📝契約プログラミング(Contract Programming)","parent":"🎓Keido HOME","content":" up: 📁Programming Paradigms refs: 📝Clojure Spec  契約プログラミングとは    契約プログラミング - Wikipedia\n防衛的プログラミング(Defensive Programming)    セキュアプログラミング/Secure Programmingともいう.\n外部との境界における引数チェック.\n契約プログラミングと防衛的プログラミングとの違い    契約プログラミングは宣言的, 防衛的プログラミングは手続き的.\n"},{"id":199,"href":"/notes/20220217110458/","title":"📝宇土為光","parent":"🎓Keido HOME","content":"ref: 📝菊池氏族原田家 🔗宇土為光 - Wikipedia\n うとためみつ, と読む. 菊池氏19代当主菊池持朝の子. 肥後国宇土城城主.  今の宇土城は 戦国時代の武将, 小西行長が建てた. 宇土氏の治めた城は，今は宇土古城と呼ばれる.   3回くらい本家に対して下剋上しようとしている.  お家騒動ゴタゴタかつ滅亡へ導いたトラブルメーカーの重宝人かもしれない\u0026hellip; 実際22代 vs 為光の内輪争いのせいでその後24代で途絶えているし\u0026hellip; 内輪で揉めてるうちに外から滅ぼされるというよくないパターン.   我が家の初代 📝菊池氏族原田家 経兼の父の可能性がある(歴史から消された?).   ここからは考察.\n宇土為光 - Wikipedia\n菊池氏族原田家の初代はこの子である(七郎)経兼からはじまるらしい.\nつまり19代から分家. うちは分家なのでNARUTO日向ネジみたtいなもんだ. おそらくお家騒動のゴタゴタで菊池姓を変更せざるをえなくなったのかな？\n22代と争ったがそもそもその後24代で本家が途絶えた\u0026hellip;\n 子重光・孫宮光丸とともに処刑され、菊池系宇土氏はここに滅亡する.\n Wikipediaによると滅びたことになってる\u0026hellip;いやわたしがいるよ！\nしかしこの重光が経兼と同一人物なのか, それとも別の人物なのか？そしてそもそもここから菊池姓から原田姓に変わったのは, 史実的には死んだことにして実際は生き延びたのか\u0026hellip;🤔\nどこから菊池から原田に変わったのか, 実はよく知らない. 歴史は消された?\nしかし以下は事実.\n うちの家紋が並び鷹の羽であり先祖が菊池氏族. 初代からことごとく男子に経の字をつけまくって室町時代から400年くらいやってきた. 初代が原田七郎経兼であり40代継続中.(38代だったかも).  あとはネットで見つけた 為光 - 経兼の繋がりを菊池系図という書籍で確認すれば全てのピースがつながるわけだ. ネットの情報だけじゃ信頼できない. 熊本県の菊池市や宇土市の図書館に行けば実際の本があるのかな？\n歴史ミステリーにドキドキ!!!\n 名和顕忠(なわあきただ)とのかかわりもわからないな.宇土為光の娘を名和顕忠が迎え入れたということは, この娘と経兼は兄弟ということになる. 当然, 初代経兼も名和氏を頼ったはず. 親の為光が謀反者として捉えられたら頼るのは妹の婿とその親のこの人しかいないはず.\nつまり歴史を紐解くキーパーソンの可能性がある.\n 宇土為光について謀反とか乗っ取りとか野心家とか下剋上とか，悪く書かれているものしかない. この偏見バイアスはなんなんだ？みんなことごとく洗脳されてるぞ？\nref: 宇土古城 宇土城 宇土為光と名和顕忠～9回に及んだ豊福城攻防戦も | お城解説「日本全国」1100情報【城旅人】\n この宇土為光は、甥の菊池重朝から無理難題をふっかけられて争いに巻き込まれ「家中一致」で菊池家当主にと望まれたようなので、決して野心だけで肥後守護職を狙った訳ではなさそうです。\n この文を都合がいいように解釈すると, 21代の重朝に意地悪されていじめられ, さらにそのあとの22代が12歳で当主なら当然乗っ取りを考えるでしょう. だって12歳の小学生が熊本県知事ならだめでしょう. 宇土市長が熊本県知事を兼務したほうがいい.\nref: 1日で1万句!武門の名家が誇る教養に、都も騒然\n21代重朝, こいつだよ. 1万句読むとか絶対暇でしょ. 暇つぶしに無理難題を押し付けて笑ってたのか？現在に喩えればTwitterで1日のうちに1万ツイートをするノリだぞ？そんな何の価値もない活動のために農民は働いてるんだぞ！仕事しろよ.\nしかし逆賊として負ければ悪く書かれて子孫も処刑されて葬り去られるのは歴史としてしょうがない. 真相はわからないし，推理することは面白い. 菊池氏が24代で滅びてしまったのなら当主の舵取りが悪かったわけで, 仮に謀反に成功していたらまだ存続出来てた可能性も在り, うちが菊池氏族本流だった可能性もあるわけで.\n宇土姓が今も熊本県宇土市になってるくらいだ,そんなに悪く書かなくてもいいじゃないか\u0026hellip;歪められた歴史め\u0026hellip;\nまあ滅亡向けてにケリを入れたお騒がせ張本人には違いないかな笑\nいや22代の小学生が悪いな.\n update. mixiのコミュニティ内で15年前の自分の書き込みを発見.\nhttps://mixi.jp/view%5Fbbs.pl?comm%5Fid=731708\u0026page=9\u0026id=5360381\n僕は第４０代目らしく、僕の祖先は、男子であれば必ず名前のはじめに「経」の字がつきます。 初代の名前は「原田七郎経かね」だったと思いますが、よく覚えていません。 家紋は「丸に並び鷹の羽」です。 はじめは熊本に住んでいたそうですが、鹿児島の島津家？の家来として集められて、 鹿児島県の蒲生に長い間住んでいて、その後、明治ごろに、東京に移ってきました。 僕はあまり詳しくないのですが、僕のおじいちゃんがめちゃくちゃ詳しいので、 今度あったときによく聞いてみて、また追加します。 僕の家系について詳しく知っている人がいらっしゃったら、教えてください。 さっきの追加ですが、 僕の家系は、藤原姓菊池氏族原田氏で、室町時代？ごろに菊池氏のお嬢さんと結婚して、家紋をもらったそうです。 ここで大事なのは, 菊池氏のお嬢さんと結婚 という部分.\n史実では, 為光, 子の重光, 孫の宮満丸の3人が隈府で処刑. (3人まとめて親・子・孫の順番に処刑したのか？衝撃\u0026hellip;) 孫まで処刑ということはつまり一族もろとも滅亡ということになる. 普通は親だけ, もしくは子まででは？孫は戦に参加してない.\nそして, 為光の娘は名和顕忠と結婚して2人の子を持ったという史実がある.\nなので可能性としては名和氏と宇土氏の間に出来た子供が初代であり, これが史実に現れる人物なのか, もしくは隠し子として育てられたのかは不明. 孫まで処刑を考えると隠されて育てられた可能性は高い.\nこれ以上の追跡はネットだけでは難しい. 宇土氏と名和氏の繋がりの深堀りは宇土市の図書館にいき, 新宇土市史という分厚い本を読む必要がある. 国会図書館でもいいかも.\n 宇土為光墓:\nhttp://www.kikuchi-family.jp/kikuchi/tamemitutomb.html\n大変寂しいところに葬られているのでいつか供養にいかないと\u0026hellip;\nhttps://www.google.com/maps/d/u/0/viewer?hl=ja\u0026gl=jp\u0026ie=UTF8\u0026oe=UTF8\u0026msa=0\u0026mid=1yYlUHE3SrlsTFDeN4IzxO2%5FDCG0\u0026ll=32.63247700000001%2C130.582917\u0026z=18\n 宇城市不知火町大見. 鉄塔の下まで来たら少し行き過ぎだが、むしろその鉄塔横のスペースに車を止めて少し歩くのがよい。\n References     宇土為光 - Wikipedia 宇土城 - Wikipedia 宇土市公式ウェブサイト 宇土市 - Wikipedia 名和氏 - Wikipedia 第一回「中世の宇土城主・宇土氏と名和氏」｜宇土市公式ウェブサイト  "},{"id":200,"href":"/notes/20220312122425/","title":"📝宣言型プログラミング(Declarative Programming)","parent":"🎓Keido HOME","content":"up: 📁プログラミングパラダイム\n宣言型プログラミングとは     広義:  処理方法ではなく対象の性質などを宣言することでプログラミングするパラダイム.   狭義:  純粋関数型プログラミング, 論理プログラミング, 制約プログラミングの総称. 数学のための言語. 状態を持たない.    宣言型プログラミング - Wikipedia\n Imperative Programing の対になる概念. \u0026ldquo;Function without State\u0026rdquo; Imperative vs Declaretive is also Stateful vs Stateless  HTML は Stateless, Declarative Programming language.\n状態はクッキーを導入してしばしば実現する.\n"},{"id":201,"href":"/notes/20220418001106/","title":"📝小咄集","parent":"🎓Keido HOME","content":"tags: 🏷落語\n学生のころに書き溜めたもののバックアップ.\n 夫婦喧嘩２    ３日も家空けて帰ってきて、\n「あら、あんた、今ちょうど救急車呼んだところよ」\n「なんか僕に事故があったと思ったの？」\n「事故はこれからよ」\n夫婦喧嘩    「喧嘩よしなよ。いったいどっちがわるいんだ」\n「このひとが悪いのよ。だって殴り返してきたんだもの・・・」\n夫婦喧嘩３    「私の将来を占ってください」\n「近い将来、あなたの家に悲しいことが起こります。ご主人が災難でしなれます」\n「それは”当たり”です。それよりあたしが捕まるかどうか見てください」\n家庭料理    「ねえ、あなた、”家庭料理”って看板の店があるわよ。入らない？」\n「外に出たときくらい美味しいものをたべようよ」\n写真    「写真屋さん、なによ、あたしのこの写真。ヒドイじゃないの」\n「取る前に気づくべきですよ」\n目覚まし時計    「目覚まし時計で目を覚ましたよ」\n「ベルが鳴ったのかい」\n「いや、女房のやつ、時計でオレの頭を叩きやがった」\n武士と娘    「こら、娘、言うことを聞かぬと赤い血をみせるぞ」\n「言う事をきくと」\n「白い血を見せるぞ」\n列車事故    「列車事故にあったことありますか？」\n「あるよ、汽車がトンネルに入ったとき、\n娘にキスしたつもりが、父親にしてしまったんだ」\n 職業安定所    失業者が職業安定所で、\n「私は結婚していてこどもが十四人いるんです」\n「他にできることは」\n休養    「君、すこし休養したらどうだい？」\n「けど、会社は休みたくないんだ」\n「君が休んでもなんとかなるだろう」\n「それがわかると困るしね」\n酔っぱらい運転    「オイ、しっかり運転しろ」\n「なに、運転しているのはお前じゃないのか」\n「随分よっているね、歩いて帰れるかい」\n「おまわりさん大丈夫です、車がありますから」\n ボタン    「おい、ウエイター、シチューの中からボタンがでてきたぞ」\n「そこにありましたか。随分探したんですよ」\n中華料理    中国へ行ってきた。ある店に入って、\n\u0026ldquo;北京ダック\u0026quot;ってったら、 \u0026ldquo;ありません\u0026rdquo; \u0026ldquo;フカヒレスープ\u0026rdquo; \u0026ldquo;できません\u0026rdquo; \u0026ldquo;なんだ代表的なものがねえのか\u0026rdquo;\n他のものはあるっていうんだけれども、この２つがねえっていうんだ、何だこれ。\n「\u0026ldquo;可もなし、不可もなし\u0026quot;だな」\n殴り合い    「お巡りさん来てください、パパがうちで殴りあいをやっているんです」\nお巡りさんがきた。\n「二人のどっちがお父さん」\n「そのことで殴り合っているんです」\n鳥の羽毛    「おばさん、なぜ鳥には羽毛がないの」\n「それは、もしなかったら醜く見えるからよ」\n「それじゃ、どうしておばさんには羽毛がないの」\n「坊や、まだお母さんのおっぱい飲んだり触ったりしているんだろう」\n「それはお父ちゃんだ」\n 虫歯    「歯を抜くの、いくらですか」\n「二万円」\n「わずか数秒の間に二万円！」\n「いいですよ、ゆっくり抜いても・・・」\nナボレオン    「君はナポレオンですか」\n「もちろんです」\n「誰が決めたんだ」\n「神ですよ」\n隣にいたやつが\n「いつ俺がそんなこと言った」\n物忘れ    「先生、近頃物忘れが激しくて・・・」\n「いつごろから・・・」\n「・・・なんの話ですか？」\n盲目の娘    「ママ、なんで私は目が見えないの」\n「神にお祈りが足りないからだよ」\n「どう祈ればいいの」\n「神に百万回祈ってご覧、目が開くから」\n百万回祈った娘が、\n「ママ、目が開かない」\n「今日は、エイプリルフールだよ」\n海水浴    ある家族が海水浴にでかけた\n「あまり遠くへ泳いでいってはダメよ」\n「お父さんは僕よりも沖へ泳いでいくよ」\n「お父さんはいいのよ」\nトイレットペーパー    「奥さん、トイレットペーパーはちょうど品切れです。明日また入ると思いますが」\n「困りますわ。明日までは我慢できませんもの・・・」\nジャングルの暴走    「ジャングルの中を百二十キロで飛ばして、いきなり木に衝突してね」\n「よく助かったね」\n「ゴムの木だったんだよ」\n傘    「傘なくしちゃってね」\n「いつ気がついたの？」\n「雨がやんだろ？傘をすぼめようとして気がついた」\n往復切符    「往復一枚ください」\n「どこまでですか？」\n「ここまでです」\n回転ドア    「弱ったぞ、出るところだったか、入るところだったか、わからなくなってしまった」\n駅のホーム    「すみません、五番ホームはどこですか」\n「四番と六番の間です」\nパラシュート    飛行機から飛んで、\nあっしまった。パラシュート忘れた。\nインディアン    インディアンが村から森に入っていく。あとを付けていくと、木の陰で用をたしていた。終わって木の葉で拭いた。\n「おい、手が汚れないかい」\n「インディアン、クソつかない」\n 「どこへ行くんだい」\n「どこへもいかないよ」\n「だって、どこかへいくんだろ」\n「行かないよ、帰りだもの」\n 「釣れますか」\n「釣れませんねー」\n「そりゃそうでしょう。そこ、水たまりですから」\n  珍しいもの    「鎌倉時代の拳銃があるんだけれどもね、珍しいものだよ」\n「鎌倉時代の拳銃・・・そんな時代に拳銃はなかったはずだよ」\n「だから珍しいんですよ」\n"},{"id":202,"href":"/notes/20220305083612/","title":"📝手続き型プログラミング","parent":"🎓Keido HOME","content":"up: 📁Programming Paradigms ref: 📝Imperative Programming\n手続き型プログラミングとは    Procedural Programming, 手続き型プログラミング.\nプログラムに構造性とモジュール性を持たせたプログラミングパラダイム.\n手続き型プログラミング - Wikipedia\n手順やチェックリストはプログラムではないが, 命令型プログラミングのスタイルに似たコンセプトである. それらのステップが命令であり, 実世界が状態を保持している.\nサブルーチン    サブルーチン - Wikipedia\nサブルーチンをプロシージャともいう.\n"},{"id":203,"href":"/notes/20220214053417/","title":"📝探索的プログラミング(Exploratory Programming)","parent":"🎓Keido HOME","content":"探索的プログラミング.\n慣れてない言語やAPIをもちいる場合に, いろいろインタラクティブに試しながらコードを書くこと.\nREPLがとても適しているが, こまめなコンパイルで評価でもTDDでもいい.\n 🏷ソフトウェア開発手法\nrefs:\n Exploratory programming - Wikipedia  "},{"id":204,"href":"/notes/20220318202503/","title":"📝文芸的プログラミング(Literate Programming)","parent":"🎓Keido HOME","content":"tags: 🏷ソフトウェア開発手法 🏷org-babel\n文芸的プログラミング(Literate Programming)とは    ドナルド・クヌースさん(Art of Computer Programmingの人)の提唱したプログラミングのスタイル.\n「本を書くようにプログラムを書こう」という運動とそのためのツール.\n具体的にはソースコードとドキュメントを別々のファイルではなく一つのファイルに記述してそこからドキュメントとソースコードを生成することで情報の一元管理を目指す.\n個人的にはorg-babelで発展してJupyter Notebookで完成したとおもった.\n関連ワード     散文的プログラミング Jupyter Notebook org-babel Run book Automation  🔗References     文芸的プログラミング - Wikipedia 🔗coursera で Reproducible Research をうけた | Futurismo 🔗散文的ブログラミングの哲学につら抜かれたCleanCodeでカルチャーショック体験 | Futurismo  "},{"id":205,"href":"/notes/20220217172513/","title":"📝東條英機","parent":"🎓Keido HOME","content":"📂先祖代々の歴史\n都市伝説かもしれないが, おばあちゃんの妹が東條英機の息子と結婚したとか.\n ことによると親戚かもしれない. 血縁関係はない. なぜこれが怪しいかというと, 最近までおばあちゃんすら知らなかったということ.  おばあちゃんの妹の葬式で発覚したとか. ネットで検索しても三男の情報がほぼない.   東條英機と東條家の「家訓」 - kakunist ページ！  「一切語るなかれ」 - 東條英機が遺族に託した家訓 この言葉がとても重いのかもしれない\u0026hellip;   祖父東條英機「一切語るなかれ」 (文春文庫) | 東條 由布子 - Amazon  物騒なタイトルを持つ書籍すらある.    幸か不幸かうちには何も教えられてないんだけど\u0026hellip;\nReferences     東條英機 - Wikipedia  "},{"id":206,"href":"/notes/20220311143538/","title":"📝池田敏雄","parent":"🎓Keido HOME","content":"ref: 池田敏雄 - Wikipedia\n富士通を富士通たらしめた人, 日本コンピュータの父.\nAppleのJobs, TwitterのJackのような, 奇人異端児が1つの企業を作り変える物語.\n私が入社したときも沢山の人たちが過去にカルフォルニアアムダール出張を経験していた. つまり池田さんと富士通のコンピュータ開発への熱意を若い頃に刻みつけされた人たち.\nrefs:\n 池田敏雄ものがたり - 池田記念室 : 富士通 IBMに勝った男! コンピュータ界の隠れた巨人!! - YouTube  "},{"id":207,"href":"/notes/20220327054349/","title":"📝神曲 - ダンテ","parent":"🎓Keido HOME","content":"イタリア文学の古典.\nそれ以前の文学がラテン語で書かれたのに対してこれはとすかーな方言で書かれた. つまり庶民に向けて書かれた.\n 神曲 - Wikipedia 神曲:地獄 - 青空文庫  地獄の門    地獄の門 - Wikipedia\n地獄篇第3歌における描写.\n 我を過ぐれば憂ひの都あり、我を過ぐれば永遠の苦患あり、我を過ぐれば滅亡の民あり\n義は尊きわが造り主を動かし、聖なる威力、比類なき智慧、第一の愛、我を造れり\n永遠の物のほか物として我よりさきに造られしはなし、しかしてわれ永遠に立つ、汝等こゝに入るもの一切の望みを棄てよ\n 上野の国立西洋美術館の入口となりにロダンの地獄の門がある.\nここを過ぎて悲しみの街    NHK大河ドラマ: 黄金の日日 にて原田喜右衛門が最期にダンテ神曲の一節を引用して殺される.\n太宰華の道化の華はこの一節から始まる.\n ここを過ぎて かなしみの都。ここを過ぎて、涙の都。さばかりも つれなき海をあとにしてかくてかの 第二の国を歌わまし。人の霊 そこに清まり天高く登るにも ふさわしき者とこそなれ\n 地獄の門をくぐる前のシーンか？(推測).\n神曲のクラシック音楽への影響     リストがダンテ交響曲を作曲している. マーラー交響曲第1番第4楽章は神曲との関連を強く感じる.  表題は「地獄から天国へ」, さらにここだけイタリア語. 第2部は人間喜劇.   モーツァルトがそれ以前のオペラがイタリア語で書かれていたのに対し, 魔笛をドイツ語で書いたと同じモチベーション.  🏷クラシック音楽\n🎓パニックゾーンとコンフォートゾーンはダンテ神曲の地獄と天国の関係に似ている    成長のためには苦痛を通して学ぶ必要がある.\n パニックゾーン ラーニングゾーン コンフォートゾーン  これらの3層レイヤははまさに地獄篇, 煉獄篇, 天国篇と対応するのでは？\n🏷コンフォートゾーン\n"},{"id":208,"href":"/notes/20220309185051/","title":"📝組み込みシステムパターン","parent":"🎓Keido HOME","content":"組込みシステムにおけるパターンまとめ.\nrefs: 📁Software Design 🏷組込み開発\n有限オートマン    Finate State Machine\n有限オートマン. 状態遷移のための制御方法.\n 有限オートマトン - Wikipedia  以下の 5 つの構成要素からなる.\n Inputs Outputs States State Transition Graph (STG)  Tree Matrix   Output Determination  Moore Machine    ムーアマシン. 出力が (入力によらず) 現在の状態によってのみ決定される有限オートマトン.\nNextState = f (Input, CurrentState) Output = g (CurrentState) Mealy Machine    ミーリマシン. 出力が現在状態と入力によって決定される有限オートマトン.\nOutput = h (Input, CurrentState) 実装方法    #define N = 2  typedef enum { yes, no} state; struct FSM { unsigned char out; /* レシジスタへの出力 */ unsigned char next[N] /* 次の状態グラフ. ここでは Matrix */ }; イベント 駆動型プログラミング    ref: 📝イベント駆動型プログラミング\n構造化プログラミング    References     Patterns for Distributed Real-time and Embedded Systems  "},{"id":209,"href":"/notes/20220310100907/","title":"📝組込みソフト開発概論","parent":"🎓Keido HOME","content":"わたしは長年組込みソフトエンジニアだった気がした.\nhttps://github.com/tsu-nera/futurismo/blob/main/wiki/src/programming/domains/embedded_system.org\n"},{"id":210,"href":"/notes/20220327060654/","title":"📝自己肯定感","parent":"🎓Keido HOME","content":"🏷心理学\n自己肯定感と自己効力感の違いは現実を受け入れるか立ち向かうか    自己肯定感とはありのままの自分を認めること. 自己効力感とはやればできるという自信.\nこの2つの言葉がややこしいのは，対概念として2つとも自己否定や自己嫌悪というものがある. もう駄目だ，なにもできない，という感情である.\nもう駄目だと思ったときに，そのことを受け入れて受け流せれば自己肯定感. もう駄目ではないと立ち向かうのが自己効力感. つまり受け入れるか立ち向かうか.\nどちらも大事だが，世の中にはどうしようもないことも多いので自己効力感による解決では限界があることも事実. そういう場合は，現実を受け入れて受け流すのが幸せなこともある.\n"},{"id":211,"href":"/notes/20211211065505/","title":"📝苫米地英人","parent":"🎓Keido HOME","content":" tags:  🏷Lisp 📝Common Lisp   desc:  とまべちひでとと読む. Common Lispの伝説的ハッカーとか. Paul Graham のともだちがとまべち😕   refs:  苫米地英人 - Wikipedia 苫米地さんってLisperだったんだよね。 - YouTube 💻【超絶IQ列伝】苫米地メソッド EX 「抽象度とは何か？」苫米地英人  https://www.youtube.com/watch?v=pjUzD3I6u-Q   【CEO動画】エンジニア募集に向けて | エンジニア採用 【CEO動画】国内GAFAMで働く皆さんへ | エンジニア採用 💻Sun Developer News - 21世紀に相応しい仕事をしよう 🖊天才LISP Hacker苫米地英人さんの都市伝説のなぞ | Futurismo    "},{"id":212,"href":"/notes/20220209051608/","title":"📝菊池氏族原田家","parent":"🎓Keido HOME","content":"ref: 📝宇土為光 📝薩摩藩姶良郡蒲生町 up: 📂先祖代々の歴史\n 第四十代当主は原田経道？ 初代は, 原田七郎経兼.  正確には, 菊池氏族宇土氏の史実上の最後 宇土為光 の次からが初代経兼が始まる.   家紋は並び鷹の羽. 肥後熊本からから薩摩に移り住み島津家に代々仕える.  薩摩の島津家には原田性は大隈氏族と菊池氏族の２つある. うちは菊池氏族のほう. 鹿児島県姶良郡蒲生町が先祖代々の土地.  ひいひいひいおじいちゃんが蒲生八幡神社の神主兼村長とか.     代々男子には経の字がつく.  おそらく菊池氏の慣習. Wikipediaをみると菊池氏で経の字を持つものが多い(2~6代目). 菊池氏は経ではなく， 武 をひたすらつける風習がある.  アナロジーみたいな感じでひたすら 経 をつけてきたのか？     西郷隆盛も菊池氏族.  西郷さんは30歳くらいで菊池源吾と名乗り子どもたちに菊の字をあてがったのはきっと菊池氏族の影響.    Reference     同族の可能性あり.  📝原田喜右衛門 📝原田孫七郎   熊本県菊池市 菊池一族特設サイト  かっこよすぎるじゃないか，バカなの笑？   菊池氏 - Wikipedia https://mixi.jp/view_bbs.pl?comm_id=155950\u0026id=1854391 https://mixi.jp/view_bbs.pl?comm_id=178096\u0026id=1530864  手元の資料にこんなものがあります。 肥後国球磨群に原田邑あり『菊池系図』に「持朝-為光（号宇都宮）-経兼（原田七郎、弟実遠」とある。 宇都宮ではなく宇土ですね。 『菊池系図』からの写し間違いかな。   http://www.harimaya.com/o_kamon1/seisi/61-70/harada.html  菊地系図に「(宇都宮)為光－経兼(原田七郎)」と見ゆ。    "},{"id":213,"href":"/notes/20220217152406/","title":"📝薩摩藩姶良郡蒲生町","parent":"🎓Keido HOME","content":"refs: 📝菊池氏族原田家 📝宇土為光 up: 📂先祖代々の歴史\n  蒲生の大クスと蒲生八幡神社が観光名所になっている.  大クスは日本一の大きさ.   先祖代々の地.  たしか上久徳か下久徳のどちらか.   ひいひいひいおじいちゃんが蒲生八幡神社の神主と蒲生町の村長とか.  ひいひいひいおじいちゃんは18歳, その弟は16歳で西南戦争参加, 生きて帰った.  田原坂決戦敗北後薩摩に向かって逃げてきたが, 18歳という若さだったため西郷さんから君たちは若いので逃げろと言わ城山での戦いの前に隊列を離れたとか.  MAPをみると撤退ルートに蒲生がある.  西南戦争をたどる②／撤退敗走。西郷は終焉の地・城山へと向かう 恐ろしいな, 8/31に蒲生を通過してそれから1ヶ月以内に西郷どんは死亡. もっとも西南戦争自体が血気盛んな士族の若者たちが勝手に騒いだ結果はじまったけど\u0026hellip;18歳\u0026hellip;          References     蒲生町 (鹿児島県) - Wikipedia 蒲生八幡神社公式ホームページ | 鹿児島 神社 蒲生麓（姶良市） | 薩摩の武士が生きた町 〜武家屋敷群「麓」を歩く〜  おじいちゃんいわく, コレは観光用に整備された通りなので実際は裏の方にある. うちもこの並びにはない. 川の方にあった記憶がある.    "},{"id":214,"href":"/notes/20211215145811/","title":"📝西郷隆盛","parent":"🎓Keido HOME","content":"薩摩藩士. 菊池氏族西郷家, つまりうちの親戚.\n ３３歳で奄美大島に３年間流刑, ３6歳で沖永良部島に２年間流刑.  海をみながらひたすら座禅をした.  菊池氏族は曹洞宗.   沖永良部島 - Wikipedia   ３０代で菊池源吾を名乗る. 子供に菊の字をつける.  自分の名前を菊池にして子供にも菊をつけるくらい菊池氏族を意識していた. それはそうかもしれない, 流刑生活だと人生の終わりを悟っていたと思う. ルーツを愛したくなったのだろう.   島津久光に地ゴロ発言をしてしまい激怒させる.  空気読めないエピソードが菊池氏族おおくないか？ ref: 📝原田孫七郎    名言    命もいらぬ, 名もいらぬ, 官位も金もいらぬというような人物は処理に困るものである. このような手に負えない人物でなければ, 困難を共にして, 国家の大業を成し遂げることはできない.\n何度も何度もつらく苦しい経験をしてこそ, 人の志は初めて堅くなるのだ. 真の男は玉となって砕けることを本懐とし, 志を曲げて瓦となって生き長らえることを恥とせよ.\nその他     うちの家に西郷さんが寄って書をかいていったとという言い伝えがあった. 鑑定士に見てもらったら偽物だったとか. お父さんは西郷家は薩摩の下士でありうちの家系は上士であり尊敬してはいけないと言っていた.  しかし私は西郷さんをとても尊敬している. そもそもうちが上士なことも怪しい. 郷士の間違いでは？ 城下町に住んでないぞ？ そもそも菊池氏族の枠組みならば同じ 菊池十八外城 を治めた西郷氏と宇土氏であり, さらには菊池氏族は 菊池家憲 という合議制をとっていたのでいわば自民党と民主党程度の違いしかなかったはず.    "},{"id":215,"href":"/notes/20211215145133/","title":"📝許光俊","parent":"🎓Keido HOME","content":"クラシック音楽の批評家.\n🏷クラシック音楽 🏷批評家\n📚Books    もっと時間をかけてバラバラに分解して思想をタグ付けして自分の考えたことを付け加えて成熟させよう.\n📚クラシック批評という運命 - 青弓社    江戸川乱歩は, あふれんばかりの残虐, 奇形, 流れる血, 病的な官能の夢想, グロテスクなものに対する偏愛をこれでもかと表現した.\n\u0026lt;猟奇心\u0026gt;とは, なにやらわけのわからない不気味なもの, 美しいもの, 特別なものに引き付けられていく心のあり方である. 猟奇心を通じて, 日常世界の秩序の壊乱に接するのである.\nどういう形であれ音楽が日常から逃れ去る方向を持つものだとしたら, 音楽は猟奇の気配を漂わせているに違いない. それどころか, そんな猟奇事件の中でこそ音楽は本来の力をはっきりして日常性を切り裂くことができよう.\n猟奇と同じく, ロマン性もまた常識的な秩序への反抗である. ロマンティクはラテン的, 古典的価値観に対する異議申し立てなのであり, また文明と理性に対する, 夢想と不合理の夜の反撃なのだ.\n📚生きていくためのクラシック - 許光俊    私の生は, もう十分に退屈で, つまらない. 平凡で, 卑俗だ. 生が何が何でも生きるに値するものとは, どうしても考えられない.\nもっとも, このような思いは, 死を真近に控えつつある人からすれば, 腹が立つほどの戯言だろう. 文明社会の都市文化に青白く咲く, デカダンなセンチメントに過ぎないであろう. とはいえ, 私がこのような思いを吹っ切れないのも事実なのである. 翻ってこう反論することも可能ではないか. 肉体的に生存することが困難でない状態にいるからこそ, 「生は生きるに値しない」という思いはいっそう純粋なのだと.\n私が生きながらえている最大の理由は, なんとなく死が怖いからに過ぎない. そして, 生が何が何でも生きるに値するものとはどうしても考えられないが, 死が何がなんでも死ぬに値するものとはどうしても考えられないからに過ぎない.\nそれゆえに, 私は, そのつまらない生を, たとえ束の間であれ, 生きるに値すると思わせてくれるものを求めずにはいられないのである.\nかつてチェリビダッケやヴァントが指揮するものすごい演奏に遭遇したとき, 私は心底, 「このようなものを聴けるのだったら, 生は意味がある. 豊かである. このようなものが聴けるとは幸福以外の何物でもない」と思い込むことができた. 彼らの次のコンサートを聴くまでは, 絶対に死ねないと思った. 愚かさと悲惨さにあふれた世界の中に, たとえごくわずかであろうとも, すばらしい驚異が存在すると信じることができた.\n私にとって, 「世界最高のクラシック」とは, 生が生きるに値すると納得させてくれるものなのだ.\n📚オペラにつれてって! 完全版 - 許光俊, 青弓社    恋や愛こそ何にもまして重大で価値があるのだ - こんな考えが現代には蔓延している.\n現代社会は偏執狂的に愛にこだわっている. それはなぜだろう.\n豊かになって恋や愛にうつつを抜かす余裕ができた, というのはひとつの理由だ. しかも, 愛=結婚, 愛=家庭を作る, ということではなくなってきている. 人によっては, 不倫関係を延々と続けるつもりになっている.\nしかし, それだけではない. 思うに, 既存の宗教や道徳が説得力を持たなくなって, 権威が白々しいものになった今, 愛や恋は一種の擬似宗教の役割を果たしているのだ. 心の安らぎや充実を求める対象が, 神ではなく恋人, 愛になっているのだ.\nそうなって考えてみると, キリスト教がウソっぽくなり, フォイエルバッハやニーチェといったさまざまな哲学者がキリスト教への批判を繰り出した 19 世紀という時代が, 愛を歌い上げるオペラの最盛期となったのはあまりにも当然である. 21 世紀の現代になっても, 基本的にはこの思潮が続いている. たぶん, 愛に完全に取って代わる新たな宗教が生まれない限り, これは続いていくはずだ. そして, 付け加えれば, まさしく今, 愛が滅びつつあるがゆえに, あるいは, 完全な愛など存在しないがゆえに, 各メディアはこぞってこれを貴重品として取り上げていることを忘れてはならない.\n滅ぼしているのは何かって? たぶん, お金, もっと正確に言うなら, 「底なしに柔軟な」資本の論理である.\n📚オレのクラシック - 許光俊, 青弓社    大学生のときに読んでおそらく人生観に最も影響を受けてしまった本のひとつ(笑)\nあとで精査して分解したい. 思想をタグ付けして自分の考えたことを付け加えて成熟させよう.\n大学生活と優等生について    note: このエッセイを読んで私も授業をサボりまくった.\n オレの大学生活はつまらなかった.\n面白い授業など皆無だった. 大学教員なんてたいしたことないやとなめていた. 周囲の学生もそろいもそろってバカばかりで, 相手をする気は全然なかった. オレの考えはこうだ. 本屋や図書館に行けば数え切れないくらい本がある. 単に勉強したいなら, 片っ端からそれを読んだほうが, 大学へ通うよりよほど手っ取り早い. 勉強などというものは自分でするべきものである. 人にあれこれ指図されてするようなものじゃない.\nただ, 優秀な人間からは刺激が受けられる. それは授業中だろうが飲み会だろうが, どこでもいいのであって, 必ずしも, 決められた枠組みの中である必要はない. もちろん, 大学でなくて一向にかまわない. 本当はソクラテスみたいに, 教室なんか必要じゃなく, 道端で立ち話でもいいのだ.\n「大学がつまらない」「大学ってこんなものですか」といってくる学生はいる. 大体そういうやつらは, 人並み以上に優秀な連中だ. オレは「大学なんておもしろいわけないじゃん. 我慢するのを勉強するところだよ」と言ってやる. 大学をおもしろいと思うようでは, 人間が小さいし, きわめて凡庸と言うほかない. 要するに, オレが大学で働いているのは, 給料欲しさと同時に, 「学校なんてくだらないんだよ」と教えるためなのだ.\nついでに言うと, 俺は優等生が嫌いである. 毎回欠席しないで全ての授業を受け, ちゃんと勉強してテストでいい点を取る. こんなことをするのは「この先生は優秀だ」「この先生はダメだ」「この授業はくだらない」「明日は休んでデートに行っても大丈夫」「この科目は大事じゃないから成績は C でもいい」という何が大事何が大事でないかという自分の判断ができないからなのだ. 自分の判断で休む勇気がないからだ.\n音楽批評のスタンス    オレの音楽評論の方法はきわめて明快だ.\nいいものは褒める. つまらないものはけなす.\nそれだけ. オレはある演奏家のすべてを否定するということはしない. オレは, その演奏をけなしているのであって, 人格攻撃はしない.\nオレは, 基本的には聴衆はバカだと思っている. バカと言うのがいいすぎなら, 理解力に乏しいといっておこう. くだらない演奏で, 大喝采する. 単に音がデカくて盛り上がるだけで, 歓声の嵐だ. 実に幼稚きわまりない. 盛り上がる音楽で興奮する. これは確かに音楽の楽しみ方の一つである.\nオレの気に食わないのは, どうして喜びをそれほど露骨に表現するのかということだ. 満足したなら, せいぜい一生懸命拍手すればいいではないか. どうして罵声をあげなければ気がすまないのか. 自分は単純ばかだということを周囲に知らせているようなものではないか. こんな輩が多いから, とにかく盛り上げよう, 熱狂のおおやす売りが氾濫する.\nオタク論と快楽主義    note: オレは快楽主義者だというフレーズにしびれる.\n オタクにとって大事なのは, 情報, そしておのおのの情報間の差異だ. オタクはとにかく情報や経験を集めたがる. (何年録音と何年録音はここがちがうとか). 要するに, 情報を集めたり整理したりするのが面倒くさくてたまらないズボラな人間,\n物をためこむのが嫌いな人間はオタクにはならないのである. 俺がいい席に座ろうとこだわったり, すごそうなコンサートが聴きたくて海外に行ったりなどは, これすべてより大きな快楽を求めてゆえにほかならない. つまり, オレは単に, 快楽という点においてシビアなだけなのだ.\n快楽にはこだわるが, あるものとあるものの差異には, 本質的に興味がないのだ. だからこそ, オレは快楽主義者なのである.\nCD 評論なんて, ナンセンスである. オーディオ装置によって印象がちがう, どころじゃない. もっと, 全然, 決定的に変わってしまうのだ. 音楽の基本的な要素であるフレージングとか和声とかがきちんと聞こえてくる, これこそが, 音楽を再生装置で聴くことができる最低条件なのである.\nクラシック滅亡論と宗教としてのクラシック    クラシックはもう滅びたと思っている.\nクラシックは, 人間の普遍的な真実, 世界の真理を表すものである. この世のものでありつつ, この世を越えたものをあらわすもの, と言って言いすぎなら, 予感させるものである. つまり, 感覚でとらえられるものだが, 感覚を超えなければならない(精神性をもたなければならない).\nというのが, モーツアルトから第二次世界大戦前後に至るまで, クラシックの大きな特徴だった. けれども, 普遍性, 真実, 真理, 理念, 理想, 永遠・・・そういったクラシックを支えていた概念は, いまやウソっぽいものとなった. というより, そうであるべきなのだ. 結局, 普遍性とか真実とか, 真理とか理念とかのほとんどは, ただ, 特定の人が信じ込んで, 他人に強要していただけにほかならない.\nそれらはウソとまでは言わないにしろ, 一部の人にとってしか, 正しくないことがはっきりした. 別の人間は別の信実や理念をもっている可能性も明確に意識されるようになった. そうして, 近代の生み出したクラシックは, 突然, 古くなってしまったのだ. 西洋文化・西洋文明が相対化されたのと同時に. 西洋が西洋であることを反省的に眺める可能性が強まったのと平行して. 現代の演奏家たちは, 壮大な真理や理念を語ったりはしなくなった. もっと個人的な感じ方を語る. そして, 精神的なことを問題にするより, 感覚的なことを問題にする. あるいは歴史的な事実に興味をもつ.\n現在の地点から眺めるなら「クラシック」はウソである. 夢である. 妄想である.\nクラシック, あるいは近代の「個人」が作り出した芸術は, その芸術家独自の宗教なのだ. 体系なのだ.\n「オレには世界がこう見える」「人間とはこういうものだ.人間とはこうならねばならない」\nという世界観・人間観の表明なのだ. あらゆる宗教がそうであるように.\nクラシック評論に面白い若手が出てこない理由    note:\nこのエッセイはたしか2000年代に書かれた. 2022年現在, 音楽はサブスクて無料できくことが当たり前になり, さらに状況は変わりつつある\u0026hellip;\nもはや令和の今はほとんど無料で聞けるし, 特にクラシック音楽の名盤なんて著作権が50年で切れる仕組みが加速させる.\n 強烈な個性を持つ演奏家を生であれこれ聞けたのは, 1980, 90 年代初めあたりまで. CD が安くなりすぎ (また, 刺激的なガイドブックも出版されすぎ?) 日本の社会全体を見て, 若い人々が「趣味」を持たなくなっている. そのときの流行でありこれやってみるだけ. 景気が悪くなったせいで, むやみやたらと合理化が叫ばれ, 無駄が嫌われるようになった. これまた不景気のせいで, 実用的で食える学問を志向する人が増えた. 優秀な人間が, 人文諸分野に少なくなった.\n日本人の優等生的価値観と個人的幸福論    オレが外からの目で見て, 日本人って変だな, と同時にかわいそうだなと思うことがひとつある. それは, 何でもかんでも優秀な成績を取らないと気がすまないということだ. かつてなら経済成長, いろいろなスポーツ分野, 今ではサッカー・・・どうして自分がやることすべてにおいて優秀でないときがすまないのだろう. 優等生と同じで, 不出来な教科がひとつでもあると, 不安で仕方がないようだ. 世界的に見てもユニークな芸術や文化をいろいろ持っているのだから, 苦手なことがあったって全然かまわないのに.\n言い換えると, 自分自身に満足できないということ. これは, とても不幸なことだ. 本来, 幸福とは, 自分に満足することだろう.\n「オレは大金持ちじゃないが, 食うに困ることはない. ありがたいことだ」「俺はモテモテじゃないが, 性格のいい奥さんをもらって, かわいい子供もいる. ありがたい」. つまり, 他人がどう思おうと, 「オレは幸せだなあ」と思えれば幸せなのだ.\n本当なら, 日本人はもっと幸せに感じていいんじゃないだろうか. 戦争はない. 身分制度はない. 食うに困らない. 犯罪が増えたといっても, パリやローマみたいに終始すりやひったくりに気をつけなくてもいい. でも, なんだか, 自分に満足することを怖がっているみたいだ. いつでも目標を立てて, がんばる. それを達成するためにストレスをためる. 達成したら自信と同時に「オレは最高だ」とヘンな傲慢さを持つ. 達成できない人はコンプレックスを感じて屈折する.\n大人も子供もストレスで自殺しちゃうような社会. これはまずい. まじめな人ほどうつ病になりやすいようだ. 適当な手の抜き方を知っておいたほうがいいぞ.\n最近はやたら競争といわれるようになってきた. が, これは大いにまずい. 競争したい人がするのがいいが, 強いられた競争は, ストレスを増加させ, 社会を殺伐とさせる. 何より, 競争の究極の姿が戦争, 殺し合いだということをお忘れなく. つまるところ, 競争して幸せになれるのはごく一部にすぎないのだ.\nそして, 芸術もまた, 本当は競争とは何の関係もないことであり, 自分が満足するまで徹底的に何かを窮め尽くすことに他ならない.\n日本人と宗教観    オレが日本人を見ていて, かわいそうだなと思うもうひとつのことは, 現在の日本人は明確な宗教を持たないことだ. オレたちの世界では, 突然, 想像もできないことがおきる. 大災害, 大地震・・・いつ何時, 突拍子もない不幸に見舞われるかもしれない. 宗教とは, そんな目にあった人を慰めるのに有益なのだ.\n[どうして, よりによってオレの娘があの電車に乗り合わせたんだ? 」 [どうして何の罪もないオレが, 病気に感染しなければならなかったんだ? 」\nテレビや新聞はそうした声でいっぱいだ. もちろん, そうした悲しみはよく理解できる. だが, これらは問うても仕方がない問いなのだ. 当然ながら, だれもが答えられるはずがない. 答えがない質問をおこなうというのは, よほど意図的に, よく考えてでないとマズい.\nそんな質問は自分を苦しめることにしかならない. 苦しみから抜け出すのに時間がかかる. だから, そういう問いは立てないようにするというのは, 生きていくうえでの知恵のひとつなのだ.\nもうひとつの知恵が, 神や宗教を持つことなのである. 宗教といえば, 平たく言えば,\n「神のお考えになっていることはわからない」「運命とは不可解なものだ」「人間様の都合で物事は決まらない」\nということ. そう考えれば, ひどい目にあったのは, 自分が悪いからでもなんでもなく, よくわからないが神や自然や宇宙の意志であるらしいと考えられる. [人生とはそういうもの」だ. 「なぜ? 」と論理的な理由を求めるのは, 最初からバカげているのである.\nもしかしたら, 論理的理由があるのかもしれないが, 少なくとも人間の手に届くところにはない.\n宗教とはある地点で思考停止することである. が, まさにそれだからこそ, 楽になるということである. ハッキリ言って, よほど優秀で強靭な人間でなければ, 神や宗教を信じたほうがいい. 考えても仕方がないことは放り出して, 他人に任せ, この場合は神様任せにしてしまったほうがいい. そうしたほうが人生を楽に生きられるとオレは思っている.\nさらに, 宗教とは, ある社会がスムーズに機能するためのルールでもある. 合理性だけで考えるなら, 納得がいかないことは世の中にいくらでもある. そこを, 神様の教えがそうだからという超越的な権威を持ち出して鎮めることができる.\n今の自由思想や人権思想だって一種の宗教のようなものである. あらゆる人間が自由で平等であるというのは, 神の存在と同じく, いやもしかしたらそれ以上に証明が難しいかもしれない. しかし, そういう「疑ってはならない」大きな枠組みを最初に打ち立ててしまえば, あとはそれを基準にして細かいことが決められる.\n少なくともオレには, 宗教よりは, 自由思想や人権思想を大きな枠組みとしたほうが快適に思える.\n最後に, 愛や家族も宗教の一種だと付け加えておこう. 「宗教とは, 非合理的なものであり, 思考停止であり, 社会を成り立たせ, それゆえ人間を楽にするもの」と定義するなら.\n美的なものに共通するルール - 節制と快楽    贅沢なんて数日であきてしまう. 贅沢はたまたまだから楽しいのだし, 慣れてしまう. ミシェル・フーコーが言っているように, 快楽のためには節制が大事なのだ.\nじつは料理を支えている感覚も, 音楽も, 美術も, 文学も, 通い合うものがあること. つまり, 味覚的だろうと, 聴覚的だろうと, 視覚的だろうと, 美的なるものに共通するルールがあるということ.\nオレはあたかもマーラーの交響曲を聞くようにコース料理を食べ, 小説を読むようにブルックナーの交響曲を聴き, 極上のスープを味わうように絵を見る.\n各要素のバランスの取り方,\n時間のコントロール, 空間のコントロール, 刺激のコントロール・・・\nみんな同じなのである.\n自然保護と人工美    オレは思うのだが, この現代で, すなわち人間の開発の手があるとしたら, それは自然でない. 極度の人工なのである.\n人間が「ここはそのままにして置こう」と考えを人間の意志によってそうなっているという点で, 完全に人工なのだ.\n自然保護とは, じつは極度の自然管理主義のことなのだ. もっともオレは自然と人工という素朴な区別が納得できない. 人間は自然の一部である. だとしたら, 人間がおこなうことは, 動物の行動と同じく, 自然の一部ではないのか. 人間がある行動をおこなうことが, 人間には理解できない自然の摂理であるという可能性は否定できないのではないか. たとえば, 人間をしに至らせるがんもまた自然の摂理であるのと同様に.\nオレは, 人間が死滅して悪い理由は何もないと思う. しかし, 多くの人が無邪気に信じているように, 仮に人類が存続せねばならないとするなら, 人間が自然を管理しなければならない. これは間違いない.\nならば, 問われるべきは「どのような自然をわれわれはもつべきなのか」である. そうした問いを無視して, 「日本の本来の自然」などと言っているのは, たんなる情緒主義, センチメンタリズムであり, 容易に暴走する可能性があるという点で, きわめて危険なのである. アノルドがいっているように, 「本来」などという言葉は自分に都合がいいことをごり押しするときに使われる言葉なのだ.\n昨今のナショナリズムの台頭とともに, 「日本独自の自然」と強く言われるようになってきた. しかし, 何が日本独自の自然なのかは深く問われないし, そもそも自然は変化するものなのである. さらに, なぜ日本独自の自然は守らねばならないのかを問う必要もある.\n多くの人にとって, 自然とは個人的なノスタルジーでしかない. 自然とは何か, どういうものなのか, どうあるべきか, 人間とは何か, どうするべきかという思考を経ずして, つまり, 大きな思想なくして情緒に流され「自然を守れ」などと叫ぶのは無意味どころか, 有害なのだ.\nそして, 死期を悟ったら, ヨハン・シュトラウスの『こうもり』序曲をかけて, 死ぬのだ.\n📚クラシック B 級快楽読本 許光俊 鈴木淳史 洋泉社 (2003)    邪悪論    世の中が実にとてつもなくマイナー志向を強めている. 東京という大都市のそこかしこには, いつしか, さまざまな変気な趣味人たちを相手にするちっぽけな店が増殖し始め, 続いて, 大型店までがそんなお客を取り込まんとマイナーの一大集積場となるに至った.\nなぜに? おそらく, まずは単純にルサンチマン=復讐心・嫉妬心から. この真理はかつてはメジャーの脇でひっそりと, あるいはメジャーの王位を簒奪せんという野心に身を辛く焦がしながら生きながらえていたものだった. マイナーであることは, 大衆からの優越したエリートであることの証であるかのような, 理解されない天才を任じるのが, この種の人々の常である. 今, 私たちは隣人がどのような愉楽を味わっているか, メディアを通じてことごとく知らされている. そんな時代, ルサンチマンはより陰湿で偏在したものになる. マスメディアが宣伝し, 演出する幸福から取り残されがちなものは, いきおいマイナーの中に別種の幸福を探す. 苦甘い幸福を.\nマイナーのもうひとつの姿は, 大量消費者である. 彼の本質は永遠の欲求不満であり, 終わりなき運動, つまり, 欲望そのものである. 恐ろしく虚無的な相対主義の申し子である彼は, 疲労困憊のはてまで, 生温かい湿った欲望の海に漂い続けることだろう, 資本主義の模範的な騎士, ただただ差異を求めての大航海. その実, 狭い球の中をぐるぐる回るだけの監禁.\nそこに邪悪が登場する. \u0026lt;邪悪\u0026gt;は, まず第一に, 価値の絶対的な高さを主張しない. ましてや, あるものを, それが知られていないにもかかわらず高価値であると主張することは, 邪悪にとってはさして重要なことではない. むしろ, 価値の低さは, まさに低さゆえに特徴として受け入れるのが\u0026lt;邪悪\u0026gt;なのである.\nそのとき, 価値の低さは低いままにつまらなくなくなるという魔術的な変貌を見せる. 万事はどこまでも平らな価値基準の砂浜にばら撒かれた貝殻である. それをいかに見つけ, どう把握するかが優れた手際の見せ所なのだ. 乱暴に言ってしまえば, 存在論ではなく, 認識論なのである. 判断ではなく, 批評なのである. つまらないものがいかなる関係性の中で面白いものに化けるか, その生き生きとした遊戯が\u0026lt;邪悪\u0026gt;なのである.\n邪悪は, メジャー志向の王座を奪おうという要求など微塵も抱いてはいない. ただ, その土台にひびを入れて, 人々に王座は絶対でもなんでもないと思わせることを目論む. 仮に王座が倒れたとて, \u0026lt;邪悪\u0026gt;が王座につくことはなく, 彼は新たな王に再度軽やかで鋭い攻撃をいかけようとするだろう.\nある意味では,\u0026lt;邪悪\u0026gt;は生が狭い範囲に限定される貧しさに対する極度の恐怖でもある.数十もの同曲異盤があるというのにわずか数種類の決定版にしがみつく昇進さ・臆病さを笑って,秩序の統制の糸が切れた空間に身を躍らせる痛快さが,\u0026lt;邪悪\u0026gt;を特徴づける.聴き手が画一的にひとつの音楽に喜びを見出せるはずもない. 快楽主義たる\u0026lt;邪悪\u0026gt;がそうした状況に満足できようか?\nでは, なぜそうした邪悪が誕生したのか? 二〇世紀は激しくデータベース化する時代だったから. 二〇世紀は, これから起こる事ではなく, すでに起こった事に対して異常な好奇心を燃やした. 二〇世紀は古文書であれ, 遺跡であれ, 人類の過去を積極的に発見し, それを往時のコンテクストの中で再現することに異常な情熱を注いでいた. そうした情熱の結果, あらゆる価値は, その情熱を取り巻く環境においてのみ有効であることが明らかになった. \u0026lt;邪悪\u0026gt;とは「価値を価値基準とともに眺める」態度である. 価値基準を背景としない価値は存在しないし, 価値基準を視野に入れずに価値を語ることは恐ろしく幸福な幼児段階であるに違いない. そして, さまざまな価値基準が重なり, 反発し, 変化しながら存在しているのが世界なのである. 邪悪はそうした世界を受け入れる. \u0026lt;邪悪\u0026gt;とは両義的な様相を認め, 綱渡り的な危険に進んで身をさらすことである. \u0026lt;邪悪\u0026gt;は硬直した\u0026lt;真理\u0026gt; に背を向ける.\n邪悪は断片を引き剥がし, 新たなコンテクストを作って遊ぶ. そうやって全体性が現れる. だが, おそらくアドルノもいっている類の, 決して見えないような全体性が・・・.\n\u0026lt;邪悪\u0026gt;は自由であることの孤独である. \u0026lt;邪悪\u0026gt;はモナリザとは反対に「すべてを知ることができないもの」の寛容の微笑を浮かべる.\nげいじゅつの胡散臭さ    クラシックがキライである. 音楽そのものはさておき, 音楽に接するときのみの寄せ方置き所, その作法うんちくのあれこれが嫌いである. たとえば, 「芸術性」なるものを錦の御旗に, たかいの不快の壮大の, 身の丈過ぎたる言葉あまた振りかざし, およそ味噌汁のにおいの届かぬところに祭り上げて, 美の感動と言いつのる. その真摯な素振りの裏側に紛々とにおい立つスノビッシュな脱俗志向, あるいはいまだに亡霊のように浮かび上がってくる脱亜入欧なるコンプレックスが実に鬱陶しいのだ.\nだいたい金科玉条と押し頂く「芸術」というしろもの, そりゃ一体なにもんだ. 鍛え上げられ磨き抜かれた芸であり技のことか. どうやら違う. 何か得たいの知れぬ「高み」に通ずるもの, 人間存在の深みに触れるもの. 巷の株音極に現をぬかす朴念仁には理解の届かぬ, 知識と教養と畏敬の念をもってして初めてお近づきになれる選ばれた世界てか?bull shit! 勘弁してくれ. その「高み」に触れて感動してなにをする. いかがわしいねぇ, どうにもくせぇ. それらクラシックに思いを寄せる心情の表層からしみだしてくるものには, 抜きがたく差別を生み出す明治伝来の構造がはりついているんじゃないのか. 表れとしては, 昨今いささかとっちらかって排他的カルト趣味の顔をしているかもしれないが, 「部外者」に対する閉鎖性の中心に「好き・嫌い」というレベルを超えた「優秀」を弄する価値観がぶら下がっている. それが芸能の大衆的徒労性を逸脱していて, たまらなく鬱陶しいのだ.\n音楽, 芸能だぜ. しろうと大衆に開かれ, その心情に落ちてトキメキを生み出さない芸能はいわば「かたわ」である. 作法に縛られ, ファナティックな愛好者の偏愛にしか供さない音楽はすでに死んでいる.\nまずは音楽に「理会」することから始めなければならない. 切り口は「芸」である. 音楽における芸とは, 音の扱う技のことであり, そこに込めたこだわりの想いである. そこに突き抜けた「狂」があり, それが何かに触発されて飛び散る瞬間に「華」が生まれ「色」が香る. その華や色が聴き手の情に滑り込んで響きあい, トキメキに触れる. 「狂」に突き抜けさせるものは, 響きに対する惑溺であり, 技に対する矜持である. それなくして華は生まれない. 「感動」の身振りはこの際捨ててかかろう. 言葉で音を「補完」した瞬間に音楽は文学に変質してしまう.\n「粋」という言葉がある. 意味は混じりけがないこと, あるいは飛びぬけて質がいいこと. 芸や世知人情に, つ, と隅々まで通じている様子を表す, ひとつの美意識を表象した言葉である. そうありたいと思いつつ, ついと地がこぼれてなかなか捕まえられない. ふ, 情けねぇ, と一人笑ってそれがまたたまらない. 「粋」は通人の世界である. そのまわりを巡ってなりきれぬもの, およばざる無粋, 過ぎたる粋狂, 畢竟, これが大衆のものである. だから「野暮の口から行き過ぎの, 粋の粋ほどハマリは強く」とばかり, そのなりきれなさに突出してゴリゴリとこだわる心情に「庶民」が同期する. というわけで, 測情に分け入るそのトバ口は, 無粋と粋狂.\n粋狂を踏み外すと「怪異」になり, 無粋を伏し拝むと「風格」になる.\nイッちゃったということ    「イッちゃった」って何? 私の日本語のバイブル (知る人ぞ知るフフフの辞書), 「新明解国語辞典」 (三省堂) にお伺いを立ててみましょう.\nいく→ゆく→「物事が」好ましい状態に達する. 「狭義では合体時にクライマックスに達することを指す) ・・・ある状態になる・・・決定的な状態に近づく.\nなんと, さすがは「新明解」. そう, イッちゃった演奏家とは, あたかもセックスのときの女性のごとく (男も?) 己の快楽をケダモノのようにすすりこむうちに, 目を見開きつつも周囲が見えなくなり, エクスタシーに溺れ, 頭も身体 (特に顔ですね) もトリップしっちゃった決定的状態でものすごい演奏をする人たちです (様子だけでイッちゃって, 演奏自体はだめな人もいますが).\nイッちゃった人, イッちゃった状態には, まともな常識, 羞恥心, 他者の存在は通じません. とするなら, イッちゃうとは一種の絶対, 悟りともいえるでしょう. しかし, これこそ音楽の, 否, 舞台芸術の醍醐味と言わずして何とする? この妖しい魅力を知らない善良なあなたのためのおいしいメニューをごらん遊ばせ.\n📚クラシック CD 名盤バトル 許光俊, 鈴木淳史 洋泉社 (2002)    名盤・・・けち臭い. この CD を買えば損をしないという訳だ. 卑小だ. 芸術はそもそも無限の可能性を誇るべきもの. それをたかが一つの解釈に限定されてたまるものか. 反動的. 永遠の名盤だの, 不滅の名盤だの, 名盤は時代を超えて生きると信じられているようだ.\nそんなこと, ありはしない. 人間の考え方, 感じ方, 趣味はあれこれと移りゆくもの. それについて価値や評価が変わるのはあまりにも当然. もしそうでないとしたら, よほど鈍いか, 馬鹿か, いずれにしても反動的なのである. 不滅とか普遍とかいった言葉は, その反動性を隠蔽するための不器用な美辞麗句に過ぎない.\n芸術とは, 生まれたそばから, さらなる可能性を求めてもがき苦しむもののはずだ. あるところに停滞していることを最も拒むもののはずだ. 名盤は, 名盤であることによって, すでに批評の対象にならねばならない.\n芸術の価値は, 時速何キロで走れるとかいう, 客観的事実とは一切かかわりがない. 「よい」演奏とはなんなのか? 客観的によい演奏などあるのか? そもそも客観なんてあるのか? 私がある演奏についていえるのはただ, 現在の私にとっておもしろい, 美しい, 発見がある, 胸をしめつけられる, イライラする, 身体がかゆくなるということだけである. こういうことを書くと, 「要するに自分勝手気ほめたりけなしたりするだけじゃないか」と思う人もいるかもしれない. ズバリ, その通りだ. 私は私の審美眼を信じるしかない. もちろん例外もあるとはいえ, 基本的にはよいもの, 悪いものにたくさん触れれば, どれがよいのか, 悪いのかは, おおよそわかるようになるはずなのだ.\n今日, 言語化しにくい経験はますます排斥されつつある. なんでも説明しなければならないというのはくだらぬ衆愚主義でありうる. もしかすると, 私が一生懸命音楽の言語化に励めば励むほど, この衆愚主義に加担しているのではないかという気持ちがなくはないのだ. やはり一番よいのは, 「これのどこがすごいかはキミが考えなさい」ではないか. すごさを人に言われなくても自分で見つけられることができないで, どうして美を味わえるのだろう.\n最近, 音楽や芸術を語ることは自分の経験を語ることでしかないという思いがますます強く持っている. それに対し, 音楽を聴くこと, 聴き方があまりにも社会的に強要されているのが今の状況だ. 個人と社会が無反省に結びついてやしないか. そう思うがゆえに, あえて個人性にこだわってみたのである.\n"},{"id":216,"href":"/notes/20220324071728/","title":"📝通信プロトコル(Communication Protocol)","parent":"🎓Keido HOME","content":"通信に関する規約.\nup: 📂ソフトウェア開発ドメイン\nOSI参照モデルの分類によるリスト     第1層 第2層 第3層 第4層 第5層(セッション層)  📝HTTP Protocol   第6層 第7層  "},{"id":217,"href":"/notes/20220305080412/","title":"📝関数型プログラミング","parent":"🎓Keido HOME","content":" up: 📁Programming Paradigms refs  📝Clojure Functional Programming 関数型言語 - Wikipedia     関数型言語    すべての計算や処理などを関数の定義の組み合わせとして記述していくタイプのプログラミング言語.\n「同じ入力には必ず同じ出力を返す」「関数の評価が他の関数に影響を及ぼさない」など数学における関数と似た性質を持った関数の定義としてプログラミングを行い, プログラムの実行は記述された関数群の評価として行われる.\nref: 関数型言語とは 【 functional language 】: IT 用語辞典\n広義の意味では, What をコンピュータに示すもの (How を示さない). 狭義の意味では, プログラミングの中で数学を用いたもの (Function, Relation).\n 式と関数でプログラムを組み上げる (Use of MathMatics) 関数を値として扱える (Higher-order programming) 副作用を起こさない (Impliclite State, Stateless)  関数が第一級オブジェクトである言語.\n関数型プログラミング    狭義の意味では,\n 状態をもたない 一時変数を持たない loop を持たない 手続的制御構造を持たない  広義の意味では,\n 関数に focusing したプログラミング. 数学での関数とプログラミングでの関数 | Futurismo  関数型言語の意味は変わりつつある     昔は, 高階関数 をサポートする言語という緩い定義だった. 現代のモダンな言語 (Haskell, Scala など) は,  数学的理論を背景にプログラムを記述する言語\n以下に数学的概念と関数型言語の対応マップがある.\n Modegramming Style: 関数型プログラミング技術マップ 2014  背景    ハードウェアのメニーコア, 大容量メモリ化によって, 性能のボトルネックが I/O ではなくて, アプリケーションとなってきた. アルゴリズムが勝負の世界. アプリがボトルネックになってきた. そのため, 言語レベルで平行・並列処理が書きやすい言語が求められるようになった.\nCloud Computing において, 異常が発生したら全体をとめるのではなくて, 一部を停止して運用を継続させる必要がある.従来の例外処理では処理するのが複雑になってきた.そのため, 言語レベルで分散コンピューティングや Fault Tolerant をサポートするような言語が求められるようになった.\n計算の考え方    命令型では, 計算の基本は蓄えられている値を変えること.\n関数型では, 計算の基本は引数に関数を適用すること.\nLanguages     狭義の意味では Lisp, XPath, Haskell,,, 広義の意味では, Scheme, Clojure, ocame, F#, Scala, Smalltalk, Ruby\u0026hellip;  メリット     コード量が少なくなる 高階関数を使った技が使える 最適化がしやすい 並列処理が書きやすい バグりにくい (定理と証明) ドキュメントが少なくなる  デメリット     関数実行のオーバヘッドが大きい メモリ大量消費 スタック使用量が見積もれない (再帰)  コンパイル = 証明    コンパイルを通すということは, 正しさを証明すること\n関数型言語では, コンパイルが通るとバグがほとんどでない. 純粋関数の世界でプログラミングをすることによって, 実現できる. 背景には数理論理学がある. (Curry-Haward 対応)\nこのことがなぜ大事かというと, 並列プログラミングのバグとりは大変. テストですべてのバグをとれたという保証ができない.\n関数型ならば数学をベースにして, バグがないことを証明することができる\n命令型プログラミングと関数型プログラミングの比較    🏷Imperative Programming\nimpelative paradium      ループで反復構造を実行\n  異なる関数の間で共有する状態を変更\nvar i = 0 while (i \u0026lt; args.length) { if (i != 0) { print (\u0026#34; \u0026#34;); } print (args (i)); i += 1; } println ();   functional paradium     再帰で反復構造を実行 arg は変数ではなくて, 不変な定数   args.foreach (arg =\u0026gt; println (arg)) for (arg \u0026lt;- args) println (arg) 不定性 | Immunity    副作用を起こさない.\nImplicate (declarative) State    暗黙的状態. 宣言的状態, Stateless, ともいう.\n 関数の実行結果が値をもつ 同じ入力には必ず同じ出力を返す. Explicite State との対概念. 参照透明性.  Referential Transparency: 参照透過性    式の値はその構成要素 (例えば変数や関数) によってのみ定まる.\n参照透過性 - Wikipedia\n 変数の値は最初に定義した値と常に同じ 関数は同じ変数を引数として与えられれば同じ値を返す  pure function: 純粋関数    同じ引数を渡す限り, どのような順番で何度呼んでも同じ結果が返るような関数.\n同じ式を評価すると, いつも同じ結果になる参照透過性を持っていること.\n副作用がある関数の対概念.\nSide effect: 副作用    ある機能がコンピュータの (論理的な) 状態を変化させ, それ以降で得られる結果に影響を与えること.\n 副作用 (プログラム) - Wikipedia  あるいは,\n 状態を参照することで出力が変化すること 状態に変化を与えることで出力が変化すること  例としては,\n 破壊的代入 I/O 制御 (write/print 等)  破壊的代入    代入というのは, 「右辺にあるものを左辺に代入する」という意味.\n左辺にある変数内のデータを消し, 新しく右辺にあるデータを代入する」とも言い換えられます. この仕組みのことを「破壊的代入」という.\nMonad |モナド    (理解不十分\u0026hellip;)\nモナド (プログラミング) - Wikipedia\n以下のような問題は, モナドという概念で説明できるらしい.\n 入出力等をもたらすプログラム 例外を返すプログラム 引数に対して値を返さない (停止しない) プログラム 同じ引数でも返り値が異なる可能性のあるプログラム  値およびその値を使う計算の並びという観点からいえば, 計算を構造化 する方法.\nIntroduction\n-\u0026gt; 詳細は Haskell の章に移動.\nリスト内包表記 | List Comprehensions    リスト内包表記, List Comprehensions.\n既存の集合から新しい集合を生成する.\n 生成器 \u0026hellip; 集合からの取り出しかたの定義 ガード \u0026hellip; 生成する条件  高階プログラミング | Higher-order programming    高階プログラミング.\n高階関数(=procedure value) をサポートしている言語でのプログラミング技術.\n 関数を引数としてわたす能力. 関数を戻り値としてかえす能力.  われわれはプログラマとして, プログラムの根底にある抽象をみつけ, より強力な抽象化ができるように努めてなければならない.\n高階手続きの重要さは, それにより抽象をプログラム言語の要素して確かに表せ, 他の計算要素として扱えるようになる点にある.\n関数における orderとは    帰納的定義は以下.\n first order: A function whose inputs and output are not functions. Nth order: if its inputs and output contain a function of maximum order N.  第一級オブジェクト(first-class object)    たとえば生成, 代入, 演算, (引数・戻り値としての) 受け渡しといったその言語における基本的な操作を制限なしに使用できる対象のこと.\n第一級オブジェクト - Wikipedia\n以下のような特徴をもつ (関数プログラミング実践入門)\n リテラルがある 実行時に生成できる 変数に入れて扱える 手続きや関数の引数として与えることができる 手続きや関数のの結果として返すことができる.  関数型言語とは, 関数が第一級オブジェクトであること.\nSICP から (p43)\n 変数として名前がつけられること 手続きに引数として渡せる 手続きの結果として返される データ構造に組み込める  Lisp は手続きに完全な First Class を授与した.\n第一級関数(first-class function)    関数を第一級オブジェクトとして扱うプログラミング言語の性質.\n第一級関数 - Wikipedia\nmapやfilterなどと高階関数をつかってプログラムを組む言語にとっては当たり前かもしれないが, 関数型パラダイムから外れるとそうではない. たとえばC 言語には関数ポインタがある. C 言語は 第二級オブジェクト. 2 階関数.\nGenericity    引数に関数を受け取るもの.\ndeclare fun {Map F L} case L of nil then nil [] H|T then {F H}{Map F T} end end Instantiation    戻り値に関数を渡すもの.\ndeclare fun {MakeAdd A} fun {$ X} X+A end end 高階関数 | High-order functions    第一級関数 をサポートしているプログラミング言語のなかで以下のいずれかを満たす関数.\n 関数を引数としてわたす能力. 関数を戻り値としてかえす能力.  高階プログラミング言語だからって書き方で高階関数でないものも書ける.\n高階関数はいろいろ種類があるが, ３大高階関数といえば以下でしょう.\n map filter reduce  map(高階関数)    リストの各要素に関数を適用する.\nPrelude\u0026gt; map (+1) [1,3,5,7] [2,4,6,8] filter(高階関数)    リストの各要素で条件に一致したものを取り出す.\nPrelude\u0026gt; filter even [1..10] [2,4,6,8,10] reduce(高階関数)    T.B.D.\n無名関数(Annonimous Functions)    無名関数. 名前付けされずに定義された関数.\nFunction Literal (関数リテラル), 匿名関数といわれることもある.\n 無名関数 - Wikipedia  メリットは,\n 一度しか使わない関数の名前を付けなくて済む. 名前の衝突を考えなくて済む. 関数の引数などに直接渡せる  examples:\n Ruby {|x, y| x + y} Scala (x :Int, y :Int) =\u0026gt; x + y , (x, y) =\u0026gt; x + y Haskell \\ x y -\u0026gt; x + y  Closure | クロージャ    引数以外の変数を実行時の環境ではなく, 自身が定義された環境 (Static Scope) において解決する.\n クロージャ - Wikipedia  Procedure Value (Oz), Lexical Scoped Closure ともいう.\n関数とそれを評価する環境のペアとも言える.\nProcedure value は ペアでメモリ上の値にバインドされる.\n Procedure code Contextual environment   Javaの無名クラスもクロージャの一種.\nRubyだと ブロック(do - end)という表現で登場する. 必ずしも表現が無名関数ではない.\nContextual environments    関数の内部で参照されていて, 関数の外部で宣言されているすべての識別子の集合を, その関数の contextual environments という.\n関数オブジェクト    関数をオブジェクトとしたもの.\n 関数オブジェクト - Wikipedia  note: Java7以前でよく登場したかな？今はきかないな.\ncf. クロージャは関数オブジェクトと環境のペア.\nラムダ式     Ruby: lambda{|x, y| x + y} Scala: Haskell:  デリゲート    オブジェクトへの参照と関数オブジェクトへの参照をペアにして持つもの.\nC#, Visual Basic .NET などの, .NET Framework のプログラミング言語にある機能.\n デリゲート (プログラミング) - Wikipedia  部分適用    一部の引数を固定化して新しい関数を作り出すことを部分適用と呼ぶ.\nカリー化 | Currying    カリー化. 複数の引数をとる関数を以下であるような関数にすること.\n 引数が「もとの関数の最初の引数」で 戻り値が「もとの関数の残りの引数を取り結果を返す関数」  カリー化 - Wikipedia\n部分適用を容易にすることが可能になるというメリットがある.\n refs.  Ruby の無名関数についての整理メモ | Futurismo Clojure: 無名関数/部分適用/関数合成    💡カリー化と部分適用の違い    よく混同されやすい. 答えられるようにしたいところ.\n 関数を引数1つずつに分割してネストさせることをカリー化と呼ぶ. 一部の引数を固定化して新しい関数を作り出すことを部分適用と呼ぶ.  カリー化は元の関数の表現を変えたにすぎない. カリーな表現. 一方, 部分適用はもはや別の関数を新たに生成している.\nカリー化や部分適用はHaskellやJavaScriptの例で検索でよくみかける. Haskellはデフォルトで引数は一つであり, わかりやすい表現のために複数引数で表現したとしても内部の処理ではカリー化されて処理される(automatic curryingいう？).\nref: カリー化と部分適用の違いと誤用 - Togetter\n x,y,z -\u0026gt; V をx -\u0026gt; (y-\u0026gt;(z-\u0026gt;V)) に変換するのがカリー化。x,y,z-\u0026gt; Vのyに値を束縛して結果的にx,z-\u0026gt;Vという関数になるのが部分適用。どこが同じなんだろうか。\n なぜ混同するかはよく一緒に登場するからか？カリーで表現された関数から別の関数をつくる.\nアリティ | arity    関数が取りうる引数の個数. 関数型パラダイムや計算機科学でよく使われる.\nref: アリティ - Wikipedia\ninvariant programming    不変式プログラミング. 再帰的に呼ばれる度に, 数学的に真になる式.\n 不変条件 - Wikipedia  Recursion    再帰的プログラミング.\ntail-recursion    末尾再帰.\nその中にただ 1 つの再帰呼び出しがあり, かつその呼び出しが手続き本体の最後にあるもの.\n関数がそれ自身を最後の処理で呼び, かつ, 関数のスタックが再利用されるもの.\ntail-recursion の例. Factorial\ndeclare fun {Fact N} local Fact1 in % tail-recursive でない % 計算のたびにスタックがたまる. fun{Fact1 N} if N==1 then 1 else N*{Fact1 N-1} end end local Aux in % tail-recursive % 計算のたびにスタックがたまらない. fun {Aux N Acc} if N==0 then Acc else {Aux N-1 {Fact1 N}|Acc} % call Fact on N here!!! end end {Aux N nil} end end end State pattern    関数型パラダイムでの実装\nfun {While S} if {isDone S} then S else {While {Transform S}} end /* tail recursion */ end 手続き型パラダイムでの実装\nstate whileLoop (state s) { while (!isDone (s)) // 終了条件  s = transform (s) // 再帰  return s; } Accumulator    C++ の, numeric ライブラリ (accumuulate など) で利用されている.\nスタックのサイズが均一なことが特徴的.\nSpecification    Principle of communicating vases    % principle of communicationg vases % n! = i! * a % = i * (i-1)! * a % = (i-1)! * (i*a) % We have: i\u0026#39; = i-1 and a\u0026#39; = i*a declare fun {Fact2 I A} if I==0 then A else {Fact I-1 I*A} end end Type: 型    Algebraic data type: 代数データ型    関数型パラダイムで利用される.\n 代数的データ型 - Wikipedia  それぞれの代数的データ型の値には,以下をもっている.\n 1 個以上のコンストラクタ 各コンストラクタには 0 個以上の引数  2 引数で与えられた他のデータ型の値を, コンストラクタで包んだようなもの.\n Java で代数的データ型 - いじわるだねっ  Visual Basic    Variant 型. なんでも入れることが出来る型だが, メモリ使用量が多いので乱用はさける.\n Variant 型とは 〔 バリアント型 〕 - 意味/ 解説/ 説明/ 定義 : IT 用語辞典  Haskell    Haskell では, 以下を合わせて代数データ型と呼ぶ\n 列挙型他の言語における enum 直積型 直和型  参考:\n Haskell 代数的データ型 超入門 - Qiita  Enum: 列挙型    プログラマが選んだ各々の識別子をそのまま有限集合として持つ抽象データ型.\n 列挙型 - Wikipedia  番号を持たないカテゴリ変数. 一意の文字.\n実行時には, 番号が振られることが覆いが, 言語によっては番号はプログラマに見えないこともある.\nMonadic Programming    モナドを中心にプログラムを組む方法.\n Monadic Programming  モナドとは,\n コンテナ パイプライン インタプリタ  モナドにはいろいろな種類がある.\n IO モナド State モナド Future モナド \u0026hellip;  モナドの使い方は難しいのだけれども, パターンがあるのでなれれば簡単.\nFunctinal Reactive Programming    ある変化に応じて動作する, イベント駆動のプログラミング方法.\nReactive Programmig には, 2 つの種類があるそうだ.(浅海さんのプレゼンから)\n Actor Model Monadic Model  以下の記事がわかりやすい.\n Q. (関数型) リアクティブプログラミングとは何ですか? | POSTD 【翻訳】あなたが求めていたリアクティブプログラミング入門 - ninjinkun\u0026rsquo;s diary   GUI, インフラ, ビッグデータ処理など様々な場面で浸透しつつあります. 今までは複雑すぎて作ることが難しかったアプリケーションが簡単に設計できるようになっていくでしょう.\n 時間とともに変化する\u0026quot;値を表すデータ型.\nFRP は非同期データストリームを用いるプログラミングである ( FRP is programming with asynchronous data streams)\n Principles of Reactive Programming | Coursera  シグナル    シグナルとは, 時間とともに変化する値. このシグナルを扱ってイベントを処理する方法.\nシグナルには以下の面倒をみる責務がある.\n 現在の値 現在の値に対応する評価 その値に依存する他のシグナル (Observers)  リアクティブ性    2015 年に備えて知っておきたいリアクティブアーキテクチャの潮流 - Qiita\nリアクティブと一言で言った時に, 現状では 2 つの含意があります.\n アーキテクチャの各要素をメッセージ駆動でつなげ, 反応的に変化させること. メッセージの送受信を隠蔽し値同士の関係 (data-flow) を宣言的 (関数型的) に記述するプログラミングパラダイム  変数 a, b について, 以下のように情報を更新したとき,\n a = 3 b = 2 + a a = 1  最終的には, a = 1, b = 3 になるようにする. 手順 3 で, a の更新に対して b も更新されるところがリアクティブ.\nリアクティブ宣言    リアクティブ宣言なんという, かっこいい文章も存在する.\n リアクティブ宣言 The Reactive Manifesto 日本語訳 - 自由課題  4 つの原則がある\n Responsive:即時応答する Elastic:伸縮自在である Message Driven:メッセージ駆動である Resilient:回復力がある  Object-Functional Programming (OFP)    オブジェクト指向のパラダイムと関数型のパラダイムの両方を利用してプログラミングする.\n オブジェクト指向開発における Object-Functional Programming Object-Functional Programming – A Beautiful Unification or a Kitchen Sink? // Speaker Deck  上流工程では, 今までどおりオブジェクト指向設計で考えることになる. ユースケースで今までどおり要件定義をして, コンポーネント分割までする. そこから, オブジェクトかファンクションのどちらかつかって責務を実現する. なので, OOP と FP は共存関係にある.\nOFP 新三種の神器.\n トレイト モナド 型クラス  OFP を導入することメリットは, 以下.\n 高階関数 や DSL を書くことで 開発効率 をあげる Monadic Programming を行うことで並列処理の品質をあげる  どこに Functional Programming を適用するか?    Functinal Programming で書くと, バグが出にくいので, Functonal Programming の割合をできるだけ増やしていくのがベスト.\nシステム開発では, OO:FP の割合は 6:4 くらいか??\nFP でつくるのに適した部分は, DSL の部分. OOP で, Framework と呼ばれている部分.\nアプリ開発は Java でもいい. アプリ開発の基盤にある DSL 部分を 関数型でかく.\nDSL    DSL とは,特定のタスク向けに設計されたコンピュータ言語. DSL は一種類のタスクをうまく実行することに集中したもの.\n ドメイン固有言語 - Wikipedia  そして, FP (というよりも Scala) は, DSL を書くことに適している (Scalable language). なぜなら, 簡単に独自の型や制御構造を定義できるので.\nFunctional Programming Patterns    Based on bellows.\n Functional Programming Patterns (BuildStuff \u0026lsquo;14) http://fsharpforfunandprofit.com/fppatterns/ http://www.ndcvideos.com/#/app/video/2311  recursion    list 型のデータ構造を扱うときの手法.\ntail recursive    pattern matching    tuple 型のデータ構造を扱うときの手法.\noverlapping pattern: 重複パターン    ボリモーフィズムによってパターンマッチをする方法.\n Meaning of overlapping pattern in Haskell - Stack Overflow  数学的帰納法によって, 定義される関数.\nlast :: [a] -\u0026gt; a last [x] = x last (_ : xs) = last xs Links     Patterns in Functional Programming | Exploiting the relationship between data structure and program structure  数学的背景    数学対応マップ    以下に数学的概念と関数型言語の対応マップがある.\n Modegramming Style: 関数型プログラミング技術マップ 2014  ラムダ計算    数理論理学    Curry-Howard 同型対応    プログラミング言語理論と証明論において, 計算機プログラムと証明との間の直接的な対応関係のことである.\n 「プログラム=証明」 (proofs-as-programs) 「型=命題」 (formulae-as-types)  カリー=ハワード同型 (Curry-Howard isomorphism) は, 数学の一見無関係に思えるふたつの領域, 型理論と構造論理を結びつける実に驚くべき関係\n カリーハワード同型対応についてのまとめ - きしだのはてな カリー=ハワード同型対応 - Wikipedia Haskell/ カリー=ハワード同型 - Wikibooks  コンパイル = 証明    コンパイルを通すということは, 正しさを証明すること\n関数型言語では, コンパイルが通るとバグがほとんどでない. 純粋関数の世界でプログラミングをすることによって, 実現できる. 背景には数理論理学がある. (Curry-Haward 対応)\nこのことがなぜ大事かというと, 並列プログラミングのバグとりは大変. テストですべてのバグをとれたという保証ができない.\n関数型ならば数学をベースにして, バグがないことを証明することができる\n抽象代数学    Functional Laws    Based on Brian Lonsdorf\u0026rsquo;s Great Presentation.\n ▶ Functional programming patterns for the non-mathematician (cut) - YouTube https://github.com/DrBoolean/patterns_talk http://www.slideshare.net/drboolean/functional-patterns-for-the-nonmathematician http://vimeo.com/user7981506  Composition laws    Currying     https://gist.github.com/eschulte/6167923  Lenses laws    A function that acts as both a getter and setter.\n http://vimeo.com/104807358  Fmap laws    Null checking    Error handling    Monad laws    Future values    Functor    Nesting    Applicative laws    Monoid laws    Accumulation    Monoid    Arrow laws    Combinators    Arrows    Functional Design Patterns    Functional Design Patterns\nBookmarks     Haskell 脳と Emacs Lisp 脳 【翻訳】 US トップ大学でも関数型プログラミングが余り教えられていない現実 | POSTD   関数型言語でプログラミングすることで, 学生は, データが帰納的に定義出来ることや, たくさんの興味深いアプリケーションが基本的にデータ型のパターンマッチを使っていることや, コードは本質的にデータとは異なることや, 副作用を最小限に抑えることで連結が楽になることなど, 重要な見識を広げます. これらは例えあなたが Java や C++ でプログラミングするつもりであったとしても有用な見識なのです\n 有名なページだけど理解できなかった. またあとで.\n なぜ関数プログラミングは重要か Ruby を使って「なぜ関数プログラミングは重要か」を読み解く (改定) ─ 前編 ─ 但し後編の予定なし  Active Recalls    カリー化と部分適用の違いはなんですか？    カリー化は複数の引数を受け取る関数の表現を一つの引数を受け取る関数の連鎖に書きすこと.\n部分適用は関数の一部の引数を固定化して新しい関数を作り出すこと.\nカリー化は元の関数の表現の変形にすぎないが部分適用は元の関数とは別の新たな関数.\n"},{"id":218,"href":"/notes/20220120043742/","title":"📝集中力が上がる時間管理まとめ","parent":"🎓Keido HOME","content":"ウルトラディアンリズム    体内時計の90分，20分のリズム.\n57/19    ポモドーロテクニック    "},{"id":219,"href":"/notes/20220114203239/","title":"🔬Startup Ideas","parent":"🎓Keido HOME","content":"とりあえず100個を目指す.\n 💡一人暮らしワンルームのベランダにおける自給自足マシンが欲しい 💡Software-Defined Cooking Mahchine 💡紙の本の電子化の自動化サービス 💡哲学を学ぶ学生のための思考ツールを提供するサービス 💡コンパイラ周りの技術を元に知的生産技術のためのツールを開発 💡ウーバーイーツをゲーミフィケーションの報酬として自動注文できるシステム ウェアラブルデバイスと連携する人生ドラクエ化サービス snsへの投稿を秒でブロックチェーンに魚拓 💡初音ミクと暮らす  "},{"id":220,"href":"/tags/BOOK/","title":"BOOK","parent":"Tags","content":""},{"id":221,"href":"/tags/clojure/","title":"clojure","parent":"Tags","content":""},{"id":222,"href":"/tags/CONCEPT/","title":"CONCEPT","parent":"Tags","content":""},{"id":223,"href":"/tags/debug/","title":"debug","parent":"Tags","content":""},{"id":224,"href":"/tags/DOC/","title":"DOC","parent":"Tags","content":""},{"id":225,"href":"/tags/Emacs/","title":"Emacs","parent":"Tags","content":""},{"id":226,"href":"/tags/IDEA/","title":"IDEA","parent":"Tags","content":""},{"id":227,"href":"/notes/20220214041907/","title":"Index of Clojure","parent":"🎓Keido HOME","content":"Clojureについて.\ntags: 🏷Lisp 🏷JVM 🏷Clojure\n 📂Clojure Core Languages 📂Clojure Development 📂Clojure Books  "},{"id":228,"href":"/notes/20220322081948/","title":"Index of Twitter Development","parent":"🎓Keido HOME","content":"refs: 🏷Twitter 🏷Development\n 📝Twitter API 📝Twitter Scraping 📝Twitter Private API 📝Twitter Technologies 📝Twitter Development with Clojure  "},{"id":229,"href":"/notes/20220327060450/","title":"Index of 心理学","parent":"🎓Keido HOME","content":" 📝コンフォートゾーン 📝自己肯定感  up: 🎓Keido HOME\n"},{"id":230,"href":"/notes/20220327055651/","title":"Index of 文学","parent":"🎓Keido HOME","content":" 📝神曲 - ダンテ 📂落語  up: 🎓Keido HOME\n"},{"id":231,"href":"/notes/20220120031935/","title":"Index of 食事","parent":"🎓Keido HOME","content":" 📝パレオさんの食事についての情報まとめ  "},{"id":232,"href":"/tags/ISSUE/","title":"ISSUE","parent":"Tags","content":""},{"id":233,"href":"/","title":"Keido","parent":"","content":""},{"id":234,"href":"/notes/20211111225741/","title":"List of Clojure Notes","parent":"🎓Keido HOME","content":" 📂Clojure 📝Clojure/ClojureScriptの参考リンクまとめ 📝Clojurians 📝Clojureの思想 🏛Clojureの考察 📝Clojureモチベ 📝Datomic 📝Overtone  "},{"id":235,"href":"/notes/20220304090213/","title":"List of Erik Meijer","parent":"🎓Keido HOME","content":"アロハシャツの愉快な変なおじさん, Haskell Hacker.\n 🔗Erik Meijer (computer scientist) - Wikipedia 🖊coursera で Principles of Reactive Programming を受けた | Futurismo 🖊Haskell で 関数型言語入門! edX の Introduction to Functinal Programming を受けた | Futurismo  "},{"id":236,"href":"/notes/20220406175843/","title":"List of Founders","parent":"🎓Keido HOME","content":" 📝Jack Dorsey 📝Paul Graham 📝Peter Thiel  "},{"id":237,"href":"/notes/20220214041241/","title":"List of JVMs","parent":"🎓Keido HOME","content":" 📝JVM共通技術 🏷Clojure 🏷Java  "},{"id":238,"href":"/notes/20220114080415/","title":"List of Lisp Languages","parent":"🎓Keido HOME","content":"LISPとLispの2つの表現があるが, 表記の統一のためにこのサイトではLispで統一していく.\n 📝Lisp Base Concepts 📝Lispの思想 📝Common Lisp 📝Clojure  "},{"id":239,"href":"/notes/20220228062520/","title":"List of Robert C.martin aka. ボブおじさん","parent":"🎓Keido HOME","content":"最近は愉快なYoutuberか？\n https://twitter.com/unclebobmartin Clean Coders - YouTube https://github.com/unclebob  まあそう入っても未だに情報発信に熱心なのは嬉しい限り.\n私の中ではKent Beckさんと双璧をなして憧れている.\n 📝Clean Architecture 🖊散文的ブログラミングの哲学につら抜かれたCleanCodeでカルチャーショック体験 | Futurismo 🖊断片的なプロ意識に感銘！プログラマは[CleanCoder]でプロの感性を学ぼう。 | Futurismo  "},{"id":240,"href":"/notes/20220319071205/","title":"List of クラシック音楽","parent":"🎓Keido HOME","content":" 📝ベートーヴェン 📝モーツァルト 📝許光俊 📝神曲のクラシック音楽への影響  "},{"id":241,"href":"/notes/20220228063204/","title":"List of プログラマ","parent":"🎓Keido HOME","content":" 🏷Robert C.Martin 🏷Rich Hickey 🏷Paul Graham 🏷苫米地英人 🏷Erik Meijer 📝池田敏雄  "},{"id":242,"href":"/notes/20220305123936/","title":"List of プログラミングモチベ","parent":"🎓Keido HOME","content":" 📝Clojureモチベ 🔗プログラマは芸術家となりえるか？クヌース先生のプログラム論を読んだ読書メモ | Futurismo  アートとしてのプログラミングについてのクヌース先生のエッセイ    "},{"id":243,"href":"/notes/20220307152757/","title":"List of プログラミング言語","parent":"🎓Keido HOME","content":" 📝Java 📝Clojure 📝Common Lisp  "},{"id":244,"href":"/notes/20220310060448/","title":"List of プログラミング言語設計思想","parent":"🎓Keido HOME","content":" 📝Lispの思想 📝Clojureの思想  📂Programming\n"},{"id":245,"href":"/notes/20220319071239/","title":"List of 作曲家","parent":"🎓Keido HOME","content":" 📝ベートーヴェン 📝モーツァルト  "},{"id":246,"href":"/notes/20220119145227/","title":"List of 個人開発","parent":"🎓Keido HOME","content":" 📝Tech系のアダルトサイト制作事例まとめ  "},{"id":247,"href":"/notes/20220319071651/","title":"List of 批評家","parent":"🎓Keido HOME","content":" 📝許光俊  "},{"id":248,"href":"/tags/MOC/","title":"MOC","parent":"Tags","content":""},{"id":249,"href":"/tags/naming/","title":"naming","parent":"Tags","content":""},{"id":250,"href":"/tags/ONLINE/","title":"ONLINE","parent":"Tags","content":""},{"id":251,"href":"/tags/PERSON/","title":"PERSON","parent":"Tags","content":""},{"id":252,"href":"/tags/SOURCE/","title":"SOURCE","parent":"Tags","content":""},{"id":253,"href":"/tags/TAG/","title":"TAG","parent":"Tags","content":""},{"id":254,"href":"/tags/","title":"Tags","parent":"Keido","content":""},{"id":255,"href":"/tags/TALK/","title":"TALK","parent":"Tags","content":""},{"id":256,"href":"/tags/TOC/","title":"TOC","parent":"Tags","content":""},{"id":257,"href":"/notes/20220116173918/","title":"What I Worked On - Paul Graham(2022)","parent":"🎓Keido HOME","content":" title: 私が取り組んだこと（What I Worked On） authors: Paul Graham url:  https://hiroshi-manabe.github.io/translation/what_i_worked_on/ http://www.paulgraham.com/worked.html   notes:  感動した. Belというプログラミング言語という芸術作品を作った話.  \u0026gt; 「ポール・グレアムってまだプログラミングしてるの？」   彼は画家になりたかった，ハッカーになった. しかし，ハッカーの道を求道した結果，プログラミング言語という芸術作品をつくった. 作曲家が交響曲を書くのとハッカーがプログラミングを書くこと，ここには何も違いがない.    "},{"id":258,"href":"/tags/WIKI/","title":"WIKI","parent":"Tags","content":""},{"id":259,"href":"/notes/20220114205119/","title":"コンパイラ周りの技術を元に知的生産技術のためのツールを開発","parent":"🎓Keido HOME","content":"プロジェクトに閉じたノートはすべてgithub管理でソースコードと扱ってもいいかも.\n結局アイデアとコードは一つにまとまってたほうがいい. アイデアをソースコードと同じノウハウで処理したい.\nプログラミングからしたら拡張子が.cか.orgの違いにすぎないでしょ. これは面白い考えで、lispでの字句解析や構文解析, もっと言えばコンパイルの勉強をしたい. コンパイルの勉強をして知識をコードで扱いたい。\n開発言語はCommon Lispを採用したい. よくわからない先例のない領域を切り開くのは Lispでしょ.\nref: 🎓知恵をノートで管理してコンパイルすることによりアウトラインを生成する\n"},{"id":260,"href":"/notes/20220309182946/","title":"🏛Clojure考察","parent":"🎓Keido HOME","content":"個人的なポエム of Clojure.\nrefs: 🏷Clojure 📝Clojureモチベ 📝Clojure思想\n 🖊シンプルさが前に進む力となる Clojure | Futurismo  💡考察: ClojureはJavaよりもシンプルに行数が短く書けるのは本当か？    同じ主張はScalaでもされている.\nJava8 で登場した Stream API記法をつかったコードで比較しているのかは気になる.\nfor文やif文を多用したJava7以前の記法のコードと比較してClojureはコードが少なく書けるんですよ!といってもそこには比較が片手落ちなきがする.\nJava8以降のより関数型に近い記法でJavaを書いたらどうなるのか気になる.\n🏷Java\n💡考察: Clojureのデータと関数は分けるを深ぼる    データと操作を1つのデータ構造に納めるのがクラスでありJava流. データと操作は別々に定義するのがClojure流.\n操作というものも関数値(Cの関数ポインタ)と捉えれば, 構造体への参照と関数への参照を1つのデータ型にまとめたものがクラス.\nしかし整理のために, 具体的にはデータとそれに対する操作は一緒にしておかないと, わたしの脳が忘れるというコーディング上の課題? への解決策としては, 1つのファイルrecordを定義したらその下にそのデータ構造を操作する関数を書く.\n仮にnamespaceをアプリのドメインごとに切るとすると, 1つのnamespace，1つのファイルには１つのrecordを定義することになるのかな？そしてそのドメインに対する操作をそのファイルに書く.\nこの考察の派生として, 悪い書き方は recordに対するprotocolを定義するのだれども, そのprotocolがrecord専用となってしまい, そのnamespaceにbindingsしてしまうことだ.\nこれをやりそうになったがこれはJavaの呪いであり, OOPからFPへ慣れてないからな気がした.\nprotocolはドメインのnamespaceではなくて, リスト操作を想定してそのリストの定義するところに定義するべき.\nref: Clojure Architecture Visitor Pattern Iterator Pattern\n💡考察: ClojureのImmutable Dataによってprivateという概念はなくなる？    privateやらカプセル化やらはデータがMutableな世界において以下にバグを出さないかというためのGood Practiceとして発展したので, そもそもデータがImmutableな世界ではその概念が不要か？\nそれでもnamespaceでprivateな関数を宣言するのはコンピュータというよりは開発やそれを開発する人の都合か？\nあるチームの関数を許可なく勝手に使うなよみたいな. 昔組込み開発していたときうちのチームの開発した便利ツールを勝手にみんな使ってさらにそのツールがバグってて苦情を言われるみたいなことがあった, 迷惑.\n"},{"id":261,"href":"/notes/20220128180332/","title":"🏛DarkHorse","parent":"🎓Keido HOME","content":" 🎓隼たれということわざにフィットという解釈を加える 🎓DarkHorseとは芸術家のような生き方  ref: 📝DarkHorse up: 📂虚無との戦い\n"},{"id":262,"href":"/notes/20220217170710/","title":"🏛Startup","parent":"🎓Keido HOME","content":" 🎓火縄銃のリバースエンジニアリングは日本の歴史的ハッキング  "},{"id":263,"href":"/notes/20220222191519/","title":"🏛お金","parent":"🎓Keido HOME","content":" 🎓AI所有というキャッシュフロークワドラントの第5象限を切り開く  "},{"id":264,"href":"/notes/20220128184659/","title":"🏛プログラミング","parent":"🎓Keido HOME","content":"ハッカーマインド\n 🎓Web Private APIのハッキングは人間のツボを探求することだ 🎓作曲家が楽譜を書くのとハッカーがコードを書くことに違いはない 🎓コードに働かせるというキャッシュフロークワドラントの第5象限ハッカーになりたい 🎓タテとヨコからプログラミング言語を学ぶ 🎓プログラミングの初級者から中級者への上達はコードリーディング 🎓駆け出しエンジニアが実務で使えない問題はWeb業界の問題 🎓プログラミングスクールというのが壮大なムーンショット実験 🎓焦りではなくワクワク感を行動のモチベーションにしたい 🎓Wikiの整理はソースコードのリファクタリングをするときの心構えでやる  up: 🏛HOME\nJournals     プログラミングに興味がなくなってしまった | Futurismo プログラミングの喜びを集めてみた | Futurismo  "},{"id":265,"href":"/notes/20220314213239/","title":"🏛マインドフルネス","parent":"🎓Keido HOME","content":" 🎓部屋が乱れは心の乱れの鏡である 🎓GTDのキモはマインドフルネス状態を目指してマインドワンダリングを制御すること 🎓GTDで管理するものはタスクではなく気になることである  up: 🏛HOME\n"},{"id":266,"href":"/notes/20220114203056/","title":"🏛仕事","parent":"🎓Keido HOME","content":" 🎓UberEats配達員は麻薬密売人 🎓憧れの職業としてのエンジニアが気持ち悪い  "},{"id":267,"href":"/notes/20220128184558/","title":"🏛勉強","parent":"🎓Keido HOME","content":" 🎓Wikiの整理はソースコードのリファクタリングをするときの心構えでやる 🎓これからおじさんになる私の勉強は抽象度と知恵を意識する 🎓タテとヨコからプログラミング言語を学ぶ 🎓プログラミングの初級者から中級者への上達はコードリーディング 🎓自分の脳, 第2の脳Wiki, 第3の脳Googleの順で知識を検索する  up: 🏛HOME\n"},{"id":268,"href":"/notes/20211230094251/","title":"🏛心理学","parent":"🎓Keido HOME","content":" 🎓パニックゾーンとコンフォートゾーンはダンテ神曲の地獄と天国の関係に似ている  up: 🏛HOME\n"},{"id":269,"href":"/notes/20211222185123/","title":"🏛生産性","parent":"🎓Keido HOME","content":" 🎓生産性を高めるためにはまず環境と体調を整えることが最優先 🎓生産性と創造性は矛盾する概念であり同時に求めることは難しい 🎓わたしには生産性よりも創造性のほうがより重要な価値観 🎓焦りではなくワクワク感を行動のモチベーションにしたい 🎓集中力のランナーズハイは存在するか 🎓GTDで管理するものはタスクではなく気になることである 🎓GTDのキモはマインドフルネス状態を目指してマインドワンダリングを制御すること 🎓GTDにおいてタスクの優先度は私で決めるのではなくてシステムが決めるもの  up: 🏛HOME\n"},{"id":270,"href":"/notes/zettelkasten/","title":"🏛知恵まとめ (Zettelkasten)","parent":"🎓Keido HOME","content":"a.k.a. Zettelkasten.\n 🏛勉強 🏛お金 🏛心理学 🏛美と芸術 🏛生産性 🏛マインドフルネス 🏛プログラミング  🏛Clojure   🏛仕事 🏛スタートアップ  🎓Keido HOME\n"},{"id":271,"href":"/notes/20220209051021/","title":"🏛経道とは","parent":"🎓Keido HOME","content":"📂虚無との戦い\n 🎓経道とは道を経る者 🎓経道とはThreadである 🎓経道とは仏教を統べる者  "},{"id":272,"href":"/notes/20220310220603/","title":"🏛美と芸術","parent":"🎓Keido HOME","content":" 🎓フルベンオタクなのでシンプルなものは美しい 🎓作曲家が楽譜を書くのとハッカーがコードを書くことに違いはない  up: 🏛HOME\n"},{"id":273,"href":"/notes/20220216154041/","title":"🏷Clojurians","parent":"🎓Keido HOME","content":"Clojureが好きそうな人 a.k.a. Rich Hickeyと愉快な仲間たち.\n Rich Hickey Alex Miller Stuart Halloway Eric Normand Dmitri Sotnikov(@yogthos) James Reeves(@weavejester) Stuart Sierra  References     Clojure: dosync radio ClojureにフォーカスしたいYoutubeチャンネル - YouTube  by https://twitter.com/iku000888    "},{"id":274,"href":"/notes/20220112095806/","title":"🏷Emacs","parent":"🎓Keido HOME","content":" 📝Emacs 📝Org-mode 📝Org-roam 📝ox-hugo 📝Clojure Emacs Config  ref: ⚡My Emacs Config - Nothung\n"},{"id":275,"href":"/notes/20220215183442/","title":"🏷Firebase","parent":"🎓Keido HOME","content":"Firebaseは Google Cloud のなかで特にアプリケーション開発に使うものをパッケージングして名前をつけたもの.\nrefs: 🏷Domains 🏷Google Cloud\nList of Firebase     📝Firebase with Clojure  "},{"id":276,"href":"/notes/20220105160323/","title":"🏷List of Coursera Lectures","parent":"🎓Keido HOME","content":" 💻Learning How to Learn - Barbara Oakley(coursera)  "},{"id":277,"href":"/notes/20220215162654/","title":"🏷Rich Hickey","parent":"🎓Keido HOME","content":"Creator of Clojure Language.\n🏷Clojure\n"},{"id":278,"href":"/notes/20211217143718/","title":"🏷Twitter","parent":"🎓Keido HOME","content":" 📝Jack Dorsey 📝Twitter Histories 📝Twitter ルール 📝Twitter検索オプション 📝Twitterシャドウバン 📁Twitter Development  "},{"id":279,"href":"/notes/20220220094636/","title":"🏷Web Development","parent":"🎓Keido HOME","content":"List of Web Development Notes.\n 📝Web Development Basic 📝Clojure Web Development  ref: 📂プロダクト開発\n"},{"id":280,"href":"/notes/20220227213744/","title":"🏷アニメ","parent":"🎓Keido HOME","content":"好きなアニメ. 後で整理したい.\n 忍たま乱太郎 ドラえもん 魔法陣グルグル ダイの大冒険 ドラゴンボール ワンピース 弱虫ペダル 溝の口サンレッド  ドラえもん -\u0026gt; 忍たま乱太郎 -\u0026gt; ダイの大冒険 -\u0026gt; 魔法陣グルグル -\u0026gt; ロードオブザリング -\u0026gt; ニーベルングの指環\nアニメというより途中からドラクエ一筋かも. どちらかというとアニメは中学生からはみてない. 小5から中１は魔法陣グルグルが読みたかったのでジャンプではなくガンガンを買ってた. 中2からジャンプになったけど高校生になったらもうジャンプも読んでない.\n"},{"id":281,"href":"/notes/20220214053235/","title":"🏷ソフトウェア開発手法","parent":"🎓Keido HOME","content":" 📝Clojure REPL Driven Development 📝Exploratory Programming 📝文芸的プログラミング(Literate Programming)  ref: 📂プロダクト開発\n"},{"id":282,"href":"/notes/20220228210333/","title":"🏷ブログ構築","parent":"🎓Keido HOME","content":"WikiやBlogの作成ノート.\nKeido Wiki     🗒Keido Tips 🗒Keido Note Rules  Futurismo Blog     🖊Futurismo Wiki 立ち上げ(Dokuwiki) 🖊ScrapboxによるFuturismo Wiki復活 🖊Futurismo Wiki復活🎉(3回目) with Sphinx 🖊Futurismo Wikiを閉鎖して新たにデジタルガーデンを立ち上げます  "},{"id":283,"href":"/notes/20211211072935/","title":"🏷落語","parent":"🎓Keido HOME","content":" 🏷落語家 👨立川談志 👨立川志らく 📝小咄集  "},{"id":284,"href":"/notes/20211215150649/","title":"🏷落語家","parent":"🎓Keido HOME","content":" 立川流  👨立川談志 👨立川志らく    "},{"id":285,"href":"/notes/20220107073312/","title":"🗒Keido Note Rules","parent":"🎓Keido HOME","content":"知的生産基盤の運用ルールのまとめ.\nup: 🏷ブログ構築 ref: 🗒Keido Tips\nNote種別     Zettelkasten  Fleeting(litetature)  Journal Note Inbox   Concept Note(Permanent Note) Structure(reference note)  Tag MOC   Output Note   Wiki  Source(biblio)  Book Talk Online Paper   WIKI Note TOC Note   GTD  Area Note Project Note Goal Note   BML  Issue Note Fact Note Test Note  Interview Search Data Analsis Experiment      Note種別とタグと絵文字の対応まとめ     📚Book Note - BOOK - Books 📝Wiki Note - WIKI - Memo  👨Person(Man) Note - WIKI - Man 👩Person(Woman) Note - WIKI -Woman subtree  💡Insight(他者の考察) - Electric Light Bulb 🤔Thought(自己の考察) - Thinking Face     📂TOC Note(for wiki) - TOC - Open File Folder 🎓Concept Note - CONCEPT - Graduation Cap 🏛MOC Note(for concept) - MOC - Classical Buildling 🏷Tag Note - TAG - label 🗒Doc Note - DOC - Spiral Note Pad 🖊Output Note - Lower Left Ballpoint pen 💎Fact Note - Gem Stone Test Note Issue Note 🔨Project Note - Hammer ☑Area Note - Ballot Box with Check 🏆Goal Note - Trophy 🦊DardFox Note - Fox Face 🔗External Link - Link ⌛Journal Link  Wiki 設計    Wiki Note     Wikiには外部の知識を書く. 他者の意見と自分の意見を分けてかく. Wiki Noteのタイトルには📝をもちいる.  TOC Note    知識のタテの流れを構成するノート.\nWiki NoteはTOC Noteを兼ねる. Wiki Noteを拡張して TOC Noteにする. Wiki Noteに書く内容が大きくなってきたらTOC NoteとサブWikiノートに分割する.\n コンテンツを持たない場合は,  titleは \u0026ldquo;List of xxx\u0026rdquo; aliasで \u0026ldquo;📂 xxx\u0026rdquo;   コンテンツを持つ場合  titleは \u0026ldquo;📝 xxx\u0026rdquo; aliasで \u0026ldquo;📂 xxx\u0026rdquo;    TAG Note    知識のヨコの流れを構成するノート.\nWiki NoteはTAG Noteを兼ねる. Wiki Noteを拡張して TAG Noteにする. Wiki Noteに書く内容が大きくなってきたらTOC NoteとサブWikiノートに分割する.\n コンテンツを持たない場合は,  titleは \u0026ldquo;List of xxx\u0026rdquo; aliasで \u0026ldquo;🏷 xxx\u0026rdquo;   コンテンツを持つ場合  titleは \u0026ldquo;📝 xxx\u0026rdquo; aliasで \u0026ldquo;🏷 xxx\u0026rdquo;    Noteの関連     あるWiki Noteから別のWiki Noteへの関連は refs: 📝xxxをもちいる. Wiki Noteの親子関係は TOC Noteをもちいる.  サブWiki Noteか親Wiki Noteへの関連は refs: 📁xxx 親Wiki Note(TOC Note)からサブWikiノートへの関連は, Titleが Index of XXX   複数のWiki Noteの関係は, TAG Noteをもちいる.  TAG Noteは複数Wiki Noteを列挙して, Titleが List of XXX あるWiki Noteから TAG Noteへの関連は refs: 🏷xxx   あるWiki Noteの上位の抽象概念をTOC Noteでまとめる. あるWiki Noteの属性をTAG Noteでまとめる.  Note 設計memo    wikiノートとtagノート, tocノートは応じて同じでもいい. はじめはすべて分けていたのだが, 同じtitleのノートが3つできると管理が面倒になったので統一する.\ntitleの表現が日本語と英語があれば, SEOを考慮する. だいたいの場合において, 日本語と英語の両方を書いてしまえばいい. また, titleの次の見出しに, (title) とはのようにSEOを意識したまとめを書く.\ntitleとはじめの見出しの間は検索では無視される部分のため, ここにtagsやupを使って別のNoteとの関連を貼る.\nZettelkasten 設計    T.B.D.\n"},{"id":286,"href":"/notes/20220305081605/","title":"🗒Keido Tips","parent":"🎓Keido HOME","content":"Keido構築のTipsを書き溜めていく.\nref: 📝ox-hugo 🗒Keido Note Rules\nox-hugoはwikiのみに使っているわけではないので, このページではとくにkeido wikiに特化したノウハウをまとめる.\nM-x org-hugo-auto-export-mode    ox-hugoの機能.\nOrg-modeで書かれたメモからのMarkdownの変換を保存をトリガにして自動化できる.\n"},{"id":287,"href":"/notes/20220128151558/","title":"🦊虚無との戦い","parent":"🎓Keido HOME","content":"暇なときにコツコツ復活させたい.\nhttps://github.com/tsu-nera/futurismo/tree/main/wiki/src\nWiki     📂先祖代々の歴史 📝DarkHorse  Zettelkasten     🏛経道とは 🏛DarkHorse  "}]