+++
title = "📝Clojure Bindings and Namespaces"
tags = ["WIKI"]
draft = false
+++

Clojureでは，変数の名前空間と束縛の関係は以下のようになる.

ref: [📂Clojure Core]({{< relref "20220112142936.md" >}})


## Clojure: namespace {#clojure-namespace}

Clojure の名前空間を namespaceという. ns で宣言する. \\\*ns\\\* で参照する.

ある名前空間から別の名前空間を参照するには requireをつかう.

-   require のみ 省略なしの表記でアクセスできる(namespace/symbols)
-   require :as 省略した表記でアクセスできる(省略namesapce/symbols)
-   require :refer :all 名前空間を書かない表記でシンボルにアクセスできる(symbols)

[🏷environments]({{< relref "20220305075933.md#valuables-変数" >}})


### Clojure: scope {#clojure-scope}

Clojureはデフォルトで静的スコープを採用している.

[🏷Scope]({{< relref "20220305075933.md#scope-スコープ" >}})


#### Dynamic Scope {#dynamic-scope}

動的スコープ. Emacsなら常識か.

ClojureのDynamic Scopeは **bindings** マクロで定義する.
名前空間を超えて, 同一スレッド内なら値(var)が参照可能.

Lispの慣例として, アスタリスク(\*)でsymbolを囲む.

そういう意味だと, スレッドローカルといえるかも.
スレッドをまたぐ方法はまた別にある?
(未調査, keyword: "binding conveyance").

refs: [Clojure - Vars and the Global Environment](https://clojure.org/reference/vars)


## Clojure: Bindings {#clojure-bindings}

-   変数の名前空間への束縛をdef
    -   list formでbindingする.
    -   ex.) (def developer "Alice")
    -   無名関数はfn
-   変数の一時的な束縛を let
    -   vector formでbindingする.
    -   ex.) (let [developer "Alice in wonderland"])
-   関数の定義はdefn
    -   これはdefのシンタックスシュガーでもある.
-   無名関数はfn
    -   \#() でも表現可能.

[🏷bindings]({{< relref "20220305075933.md#valuables-変数" >}})


### Clojure: clojure.lang.Var {#clojure-clojure-dot-lang-dot-var}

**def** マクロは, clojure.lang.Varオブジェクトを生成する.

```clojure
user> (def x)
;; => #'user/x
user> x
;; => #object[clojure.lang.Var$Unbound 0x7d08131d "Unbound: #'user/x"]
```

varのリーダマクロは, **#'**

varにはMetaDataを設定できる. よく見かける代表的なのは,

-   :dynamic
    -   同一スレッド内で再定義可能.
    -   (def ^:dynamic foo 1)
-   :private
    -   namespaceを超えて参照不可.
    -   (def ^:private bar 2)

ref. [Clojure: MetaData]({{< relref "20220116162321.md#clojure-metadata" >}})


### Clojure: defonce {#clojure-defonce}

defもdefonceも名前空間に変数束縛をするが,
すでに変数が存在する場合, defは上書きをする. defonceはスキップする.

ref: [What is the difference between def and defonce in Clojure? - Stack Overflow](https://stackoverflow.com/questions/37346984/what-is-the-difference-between-def-and-defonce-in-clojure)


#### defonceとatomとhotreload {#defonceとatomとhotreload}

defonceはhotreloadの文脈でatomと合わせて登場することが多い.

再起動のときにメモリをたくさん使ったり外部通信して時間がかかったりするときに,
いちいちインスタンスを再作成してるとボトルネックになるのでdefonceをつかう.

ただしreplの再起動でよく利用される tools.namespace.replのrefresh関数は,
たとえdefonceで定義されていたとしても初期化するので注意.

ref: <https://github.com/clojure/tools.namespace#reloading-code-preparing-your-application>

たとえばM-x cider-eval-bufferをうっかりEmacsで実行してバッファまるごと読み込み直しても,
defonceで宣言しているならばその変数束縛はスキップされる.

まあこのあたりのhotreloadによるDX改善は自分で考えるよりもベストプラクティスを真似るのがいいのかも.

ref: [Reloaded Workflow]({{< relref "20220117205249.md#reloaded-workflow" >}})


## ✅ Active Recalls {#active-recalls}


### Clojure の 無名関数のシンタックスはなんですか？ {#clojure-の-無名関数のシンタックスはなんですか}

fn or #()


### Clojureの名前空間の宣言方法と参照方法はなんですか? {#clojureの名前空間の宣言方法と参照方法はなんですか}

ns と \\\*ns\*


### Clojureで名前空間を参照するためのシンタックスはなんですか? {#clojureで名前空間を参照するためのシンタックスはなんですか}

require


### Clojure nsの属性で :requireと:importの違いはなんですか？ {#clojure-nsの属性で-requireと-importの違いはなんですか}

どちらもnamespaceに他のnamespaceで定義された宣言を取り込むが,
requireはclojureのライブラリ, importはJavaのクラスで利用する.


### Clojureでdefとdefonceの違いはなんですか？ {#clojureでdefとdefonceの違いはなんですか}

名前空間に変数束縛するとき,すでに変数が存在する場合の挙動が違う.

defは上書きをする. defonceはスキップする.
