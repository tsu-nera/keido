+++
title = "ğŸ“Clojure Exception: ä¾‹å¤–"
tags = ["WIKI"]
draft = false
+++

Clojureã«ãŠã‘ã‚‹ä¾‹å¤–å‡¦ç†ã‚„ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã«ã¤ã„ã¦ã¾ã¨ã‚.

refs. [ğŸ·Exceptions]({{< relref "20220305075933.md#ä¾‹å¤–-exceptions" >}}) [ğŸ“‚Clojure Core Languages]({{< relref "20220112142936.md" >}})


## Clojure-Java Exception Interop {#clojure-java-exception-interop}

Javaã®ä»•çµ„ã¿ã‚’ä½¿ã†.

-   Javaã®ã‚ˆã†ã«try/catch/finallyãŒåˆ©ç”¨ã§ãã‚‹.
-   throwã‚·ãƒ³ã‚¿ãƒƒã‚¯ã‚¹ã§ä¾‹å¤–ã‚’å¼•æ•°ã«ã¨ã‚Šé€£å¤–ã‚’ç™ºç”Ÿã•ã›ã‚‹.
    -   ä¾‹å¤–ã¯Javaã®ã‚¯ãƒ©ã‚¹ã§ä½œæˆã§ãã‚‹(Exception. )
    -   Clojureã®è¨˜æ³•ã§ex-infoã¯messageã¨mapã‚’å—å–ãƒªä¾‹å¤–ã‚’ç™ºç”Ÿã•ã›ã‚‹.
    -   Clojureã®è¨˜æ³•ã§ex-dataã¯ex-infoã§å…¥åŠ›ã—ãŸmapã‚’å±•é–‹ã™ã‚‹.

<!--listend-->

```clojure
(try
  (throw (ex-info "bad" {:a 1 :b 2}))
  (catch clojure.lang.ExceptionInfo e
    (prn "caught" e)))
```


## é€£ç¶šçš„ãªãƒ—ãƒ­ã‚·ãƒ¼ã‚¸ãƒ£å‘¼ã³å‡ºã—ã®ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã©ã†ã™ã‚‹ã‹å•é¡Œ {#é€£ç¶šçš„ãªãƒ—ãƒ­ã‚·ãƒ¼ã‚¸ãƒ£å‘¼ã³å‡ºã—ã®ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã©ã†ã™ã‚‹ã‹å•é¡Œ}

Clojureã§ã‚·ã‚¹ãƒ†ãƒ ã®å¤–éƒ¨ã¨ã‚„ã‚Šã¨ã‚Šã‚’ã™ã‚‹ã¨ãã«ï¼Œãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ä½¿ã£ã¦ä¸€é€£ã®å‹•ä½œã‚’ã™ã‚‹ã‚·ãƒ¼ãƒ³ãŒã‚ˆãã‚ã‚‹. ã“ã®ã¨ã, ä¾‹å¤–å‡¦ç†ã‚’ã©ã†ã™ã‚‹ã‹å•é¡Œ. ã¨ãã«RESP APIå‘¼ã³å‡ºã—ã‚„DBã¨ã®é€šä¿¡ãªã©ã§é »ç™ºã™ã‚‹.

```clojure
(try
   (let [value (func-that-throws)]
      (act-on-value value))
   (catch Exception e
      (log/error e "func-that-throws failed")))
```

threading-macroã‚’ã‚«ã‚¹ã‚¿ãƒ ã™ã‚‹ã‚ˆã†ã«Railway oriented programming?ã§è¨˜è¿°ã™ã‚‹ã»ã†ã»ã†ã¨, try-catchã¨ifã‚’ç”¨ã„ã¦ã‚´ãƒªã‚´ãƒªå‡¦ç†ã™ã‚‹æ–¹æ³•ãŒã‚ã‚‹ã‚ˆã†ã .

ref. [Clojure ã¨ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚° at 2021 - Qiita](https://qiita.com/MeguruMokke/items/530159edf0c41a9df6b1)

æ‰‹ç¶šãçš„ãªå‡¦ç†ã‚’letã«ãšã‚‰ãšã‚‰æ›¸ã„ã¦ã„ãã®ã¯ã©ã†ã‚‚é•å’Œæ„ŸãŒã‚ã‚‹(å€‹äººçš„ãªæ„Ÿæƒ³). ãã†ã™ã‚‹ã¨ã‚¹ãƒ¬ãƒƒãƒ‡ã‚£ãƒ³ã‚°ãƒã‚¯ãƒ­ã§bodyã«æ›¸ã„ã¦ã„ãã‚¹ã‚¿ã‚¤ãƒ«ã¯ã‚ˆã‚ŠClojureã‚‰ã—ãã¦ã‚³ãƒ¼ãƒ‰ã®è¦‹ãŸç›®ã¯ã‚ˆã„. ã—ã‹ã—ä»•çµ„ã¿ãŒdefaultã§Clojureã«çµ„ã¿è¾¼ã¾ã‚Œã¦ã„ãªã„ã®ã§æ±ç”¨çš„ã§ã¯ãªã„. æ‰‹ç¶šããŒæ•°å€‹ã«éããªã„ãªã‚‰ã°tryã¨letã¨if, ãã†ã§ãªã‘ã‚Œã°railwayã‚’ä½¿ãˆã°ã„ã„ã‹ãª.


### Railway oriented programming(é‰„é“æŒ‡å‘ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°) {#railway-oriented-programming--é‰„é“æŒ‡å‘ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°}

é‰„é“æŒ‡å‘ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã¨ã¯ã€F# ã§æœ‰åã ã£ãŸãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã‚¹ã‚¿ã‚¤ãƒ«. é–¢æ•°ã®è¿”ã‚Šå€¤ã«æ­£å¸¸ç³»ã®çµæœ result ã¨ãã‚Œä»¥å¤–ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ err ã®ã‚¿ãƒ—ãƒ« [result, err] ã‚’æƒ³å®šã—ã€å®Ÿè¡Œãƒ•ãƒ­ãƒ¼ã®å„ãƒ—ãƒ­ã‚»ã‚¹ã§å¾—ã‚‰ã‚Œã‚‹ err ãŒ nil ã§ãªã„æ™‚ Early-Return ã‚’ã‹ã‘ã‚‹æ–¹å¼. (Scalaã‚„Haskellã§ã‚‚åˆã£ãŸæ°—ãŒã™ã‚‹).

-   refs.
    -   [Railway oriented programming, clojure and exception handling: why and how?](https://medium.com/appsflyer/railway-oriented-programming-clojure-and-exception-handling-why-and-how-89d75cc94c58)

---

ã•ã‚‰ã«, Javaã®é–¢æ•°ã‚’å‘¼ã³å‡ºã™ã¨ãã«ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒä¾‹å¤–ã‚’æŒ™ã’ãšã«Nullã‚’è¿”ã™ã¨ãã¯ **some->** ã¨ã„ã†ã‚¹ãƒ¬ãƒƒãƒ‡ã‚£ãƒ³ã‚°ãƒã‚¯ãƒ­ã‚’ä½¿ã†æ–¹æ³•ã‚‚Clojureã®ã‚¬ã‚¤ãƒ‰ã«ã‚ã£ãŸ.

ref. [some-> - Threading Macros Guide](https://clojure.org/guides/threading_macros#_some_some_and_cond)


### try-catch and if-let {#try-catch-and-if-let}

tryã¨letã‚’ã¤ã‹ã£ã¦æ„šç›´ã«æ›¸ã. ã‚³ãƒ¼ãƒ‰ã¯æ±šããªã‚‹ã‚‚ã®ã®å®Ÿè£…ã‚‚ç†è§£ã‚‚ã“ã£ã¡ã¯å®¹æ˜“.

ref. [ğŸ”if-let ã¯å‡¦ç†ã®çµæœã«ã‚ˆã‚‹åˆ†å²ã§ã¤ã‹ã†]({{< relref "20220116083656.md#if-let-ã¯å‡¦ç†ã®çµæœã«ã‚ˆã‚‹åˆ†å²ã§ã¤ã‹ã†" >}})

---

try-letã¨ã„ã†ãƒã‚¯ãƒ­ã‚’æä¾›ã™ã‚‹ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚‚ã‚ã‚‹.

-   refs.
    -   [clojure - How to handle exceptions that occur in let bindings or body - Stack Overflow](https://stackoverflow.com/questions/20335760/how-to-handle-exceptions-that-occur-in-let-bindings-or-body)
    -   [GitHub - rufoa/try-let: Better exception handling for Clojure let expressions](https://github.com/rufoa/try-let)
